<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GongJintao&#39; Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.gongjintao.com/"/>
  <updated>2019-07-01T15:17:04.305Z</updated>
  <id>http://blog.gongjintao.com/</id>
  
  <author>
    <name>Gong Jintao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>机器学习算法源码之感知机</title>
    <link href="http://blog.gongjintao.com/2019/07/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E6%BA%90%E7%A0%81%E4%B9%8B%E6%84%9F%E7%9F%A5%E6%9C%BA/"/>
    <id>http://blog.gongjintao.com/2019/07/01/机器学习算法源码之感知机/</id>
    <published>2019-07-01T15:09:19.000Z</published>
    <updated>2019-07-01T15:17:04.305Z</updated>
    
    <content type="html"><![CDATA[<h2 id="感知机算法的原始形式："><a href="#感知机算法的原始形式：" class="headerlink" title="感知机算法的原始形式："></a>感知机算法的原始形式：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成数据集</span></span><br><span class="line">data = np.asarray([[<span class="number">3</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">1</span>]])</span><br><span class="line">label = np.asarray([<span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化参数</span></span><br><span class="line">w = np.asarray([<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">b = <span class="number">0</span></span><br><span class="line">learning_rate = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 误分类个数为数据集的长度</span></span><br><span class="line">N = len(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> N &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(data)):</span><br><span class="line">        <span class="comment"># 选取数据</span></span><br><span class="line">        sample = data[i]</span><br><span class="line">        <span class="comment"># 计算损失函数</span></span><br><span class="line">        loss = label[i] * (w.dot(sample.transpose()) + b)</span><br><span class="line">        <span class="keyword">if</span> loss &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 更新参数</span></span><br><span class="line">            w = w + learning_rate * label[i] * sample</span><br><span class="line">            b = b + learning_rate * label[i]</span><br><span class="line">            N = N <span class="keyword">if</span> N==len(data) <span class="keyword">else</span> N+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 误分类个数减1</span></span><br><span class="line">            N -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    print(w,b)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line">plt.scatter(data[:<span class="number">2</span>, <span class="number">0</span>],data[:<span class="number">2</span>, <span class="number">1</span>], marker=<span class="string">'+'</span>)</span><br><span class="line">plt.scatter(data[<span class="number">-1</span>, <span class="number">0</span>],data[<span class="number">-1</span>, <span class="number">1</span>])</span><br><span class="line">line_x = np.arange(<span class="number">0</span>,<span class="number">5</span>,<span class="number">0.01</span>)</span><br><span class="line">line_y = -(w[<span class="number">0</span>] * line_x + b) / w[<span class="number">1</span>]</span><br><span class="line">plt.plot(line_x, line_y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[2 2] 0</span><br><span class="line">[1 1] -1</span><br><span class="line">[0 0] -2</span><br><span class="line">[2 2] -2</span><br><span class="line">[1 1] -3</span><br><span class="line">[1 1] -3</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/005XIOOuly1g4kqqhjuk7j30ae070dfs.jpg" alt="png"></p><h2 id="感知机算法的对偶形式"><a href="#感知机算法的对偶形式" class="headerlink" title="感知机算法的对偶形式"></a>感知机算法的对偶形式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span>  np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入数据集</span></span><br><span class="line">data = np.asarray([[<span class="number">3</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">1</span>]])</span><br><span class="line">label = np.asarray([<span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化参数</span></span><br><span class="line">alpha = np.zeros(<span class="number">3</span>)</span><br><span class="line">b = <span class="number">0</span></span><br><span class="line">learning_rate = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算Gram矩阵</span></span><br><span class="line">G = np.asarray([[x.dot(y) <span class="keyword">for</span> x <span class="keyword">in</span> data  ] <span class="keyword">for</span> y <span class="keyword">in</span> data])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 误分类个数为数据集的长度</span></span><br><span class="line">N = len(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> N &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">for</span> i  <span class="keyword">in</span> range(len(data)):</span><br><span class="line">        sample = data[i]</span><br><span class="line">        loss = label[i]*(np.dot(alpha*label,G[:,i]) + b)</span><br><span class="line">        <span class="keyword">if</span> loss &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 更新参数</span></span><br><span class="line">            alpha[i] = alpha[i] + learning_rate</span><br><span class="line">            b = b + learning_rate * label[i]</span><br><span class="line">            N = N <span class="keyword">if</span> N==len(data) <span class="keyword">else</span> N+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 误分类个数减1</span></span><br><span class="line">            N -= <span class="number">1</span></span><br><span class="line">    print(alpha,b)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 求出 w</span></span><br><span class="line">w = np.dot(data.T,alpha*label)</span><br><span class="line">print(w)</span><br><span class="line">    </span><br><span class="line">%matplotlib inline</span><br><span class="line">plt.scatter(data[:<span class="number">2</span>, <span class="number">0</span>],data[:<span class="number">2</span>, <span class="number">1</span>], marker=<span class="string">'+'</span>)</span><br><span class="line">plt.scatter(data[<span class="number">-1</span>, <span class="number">0</span>],data[<span class="number">-1</span>, <span class="number">1</span>])</span><br><span class="line">line_x = np.arange(<span class="number">0</span>,<span class="number">5</span>,<span class="number">0.01</span>)</span><br><span class="line">line_y = -(w[<span class="number">0</span>] * line_x + b) / w[<span class="number">1</span>]</span><br><span class="line">plt.plot(line_x, line_y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[1. 0. 1.] 0</span><br><span class="line">[1. 0. 2.] -1</span><br><span class="line">[1. 0. 3.] -2</span><br><span class="line">[2. 0. 4.] -2</span><br><span class="line">[2. 0. 5.] -3</span><br><span class="line">[2. 0. 5.] -3</span><br><span class="line">[1. 1.]</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/005XIOOuly1g4kqqhnvxzj30ae070dfs.jpg" alt="png"></p><p><strong>本文作者</strong>：Gong Jintao<br><strong>本文地址</strong>： <a href="http://blog.gongjintao.com/2019/07/01/机器学习算法源码之感知机/">http://blog.gongjintao.com/2019/07/01/机器学习算法源码之感知机/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;感知机算法的原始形式：&quot;&gt;&lt;a href=&quot;#感知机算法的原始形式：&quot; class=&quot;headerlink&quot; title=&quot;感知机算法的原始形式：&quot;&gt;&lt;/a&gt;感知机算法的原始形式：&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;tab
      
    
    </summary>
    
      <category term="机器学习" scheme="http://blog.gongjintao.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://blog.gongjintao.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>《统计学习方法》——感知机</title>
    <link href="http://blog.gongjintao.com/2019/07/01/%E3%80%8A%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E3%80%8B%E2%80%94%E2%80%94%E6%84%9F%E7%9F%A5%E6%9C%BA/"/>
    <id>http://blog.gongjintao.com/2019/07/01/《统计学习方法》——感知机/</id>
    <published>2019-07-01T08:59:32.000Z</published>
    <updated>2019-07-01T09:00:24.383Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2-1-感知机模型"><a href="#2-1-感知机模型" class="headerlink" title="2.1 感知机模型"></a>2.1 感知机模型</h1><p><strong>定义</strong>     假设输入空间 （特征空间）是$\mathcal{X}\subseteq R^n$，输出空间是$\mathcal{Y} = \{+1,-1\}$。输入$x \in \mathcal{X}$表示实例的特征向量，对应于输入空间（特征空间）的点；输出$y \in \mathcal{Y}$ 表示实例的类别。由输入空间到输出空间的如下函数</p><script type="math/tex; mode=display">f(x)=\operatorname{sign}(w \cdot x+b)</script><p>称为<strong>感知机</strong>。其中，$w$和$b$为感知机模型参数，$w \in R^n$叫作<strong>权值（weight）或权值向量（weight vector）</strong>，$b\in R$叫作<strong>偏置（bias）</strong>，$w·x$表示$w$和$x$的内积。sign是符号函数。<br>        感知机是一种线性分类模型，属于判别模型。感知机模型的假设空间是定义在特征空间中的所有<strong>线性分类模型（linear classification model）或线性分类器(linear classifier)</strong>，即函数集合$\{f | f(x)=w\cdot x+b\}$。对应于特征空间$R^n$中的一个超平面 $S$，其中$w$是超平面的<strong>法向量</strong>，$b$是超平面的<strong>截距</strong>。这个超平面将特征空间划分为两个部分。位于两部分的点（特征向量）分别被分为正、负两类。</p><p><img src="https://i.loli.net/2019/06/30/5d18a8730c6a837897.png" alt="这里写图片描述"></p><h1 id="2-2-感知机学习策略"><a href="#2-2-感知机学习策略" class="headerlink" title="2.2 感知机学习策略"></a>2.2 感知机学习策略</h1><h2 id="2-2-1-数据集的线性可分性"><a href="#2-2-1-数据集的线性可分性" class="headerlink" title="2.2.1 数据集的线性可分性"></a>2.2.1 数据集的线性可分性</h2><p><strong>定义</strong>   给定一个数据集 $T=\left\{\left(x_{1}, y_{1}\right),\left(x_{2}, y_{2}\right), \cdots,\left(x_{N}, y_{N}\right)\right\}$，其中,$x_i \in \mathcal{X}=R^n, y_i  \in \mathcal{Y}=\{+1,-1\}, \quad i=1,2, \ldots, N$，如果存在某个超平面 $S$</p><script type="math/tex; mode=display">w \cdot x + b=0</script><p>能够将数据集的正实例点和负实例点<strong>完全正确</strong>地划分到超平面的两侧，即对所有 $y_i = +1$ 的实例$i$，有$w·xi+b&gt;0$，对所有 $y_i＝-1$ 的实例 $i$，有 $w·xi+b&lt;0$，则称数据集 $T$ 为<strong>线性可分数据集（linearly separable data set）</strong>；否则，称数据集 $T$ 线性不可分。</p><h2 id="2-2-2-感知机学习策略"><a href="#2-2-2-感知机学习策略" class="headerlink" title="2.2.2 感知机学习策略"></a>2.2.2 感知机学习策略</h2><p>​        感知机确定了一个学习策略，即定义（经验）损失函数并将损失函数极小化，该损失函数即<strong>误分类点到超平面 $S$ 的总距离</strong>。给定训练数据集</p><script type="math/tex; mode=display">T=\left\{\left(x_{1}, y_{1}\right),\left(x_{2}, y_{2}\right), \cdots,\left(x_{N}, y_{N}\right)\right\}</script><p>其中，$x_i \in \mathcal{X}=R^n, y_i  \in \mathcal{Y}=\{+1,-1\}, \quad i=1,2, \ldots, N$。感知机$\operatorname{sign}(w \cdot x+b)$学习的<strong>损失函数</strong>定义为</p><script type="math/tex; mode=display">L(w, b)=-\sum_{x_{i} \in M} y_{i}\left(w \cdot x_{i}+b\right)</script><p>其中$M$为误分类点的集合。这个损失函数就是感知机学习的经验风险函数。感知机学习的策略是在假设空间中选取使损失函数式（4）最小的模型参数$ w,b $，即<strong>感知机模型</strong>。</p><h1 id="2-3-感知机学习算法"><a href="#2-3-感知机学习算法" class="headerlink" title="2.3 感知机学习算法"></a>2.3 感知机学习算法</h1><h2 id="2-3-1-感知机学习算法的原始形式"><a href="#2-3-1-感知机学习算法的原始形式" class="headerlink" title="2.3.1 感知机学习算法的原始形式"></a>2.3.1 感知机学习算法的原始形式</h2><p>感知机学习算法是对以下最优化问题的算法:</p><script type="math/tex; mode=display">\min _{w, b} L(w, b)=-\sum_{x_{i} \in M} y_{i}\left(w \cdot x_{i}+b\right)</script><p>我们采用<strong>随机梯度下降法(stochastic gradient descent)</strong>。算法如下：</p><blockquote><p><em>输入：</em> </p><ol><li><p>$T=\left\{\left(x_{1}, y_{1}\right),\left(x_{2}, y_{2}\right), \cdots,\left(x_{N}, y_{N}\right)\right\}$，</p><p>其中$x_i \in \mathcal{X}=R^n, y_i  \in \mathcal{Y}=\{+1,-1\}, \quad i=1,2, \ldots, N$</p></li><li><p>学习率 $\eta(0&lt;\eta \leqslant1)$</p></li></ol><p><em>输出：</em> $ w,b;感知机模型 f(x) = \operatorname{sign}(w \cdot x+b) $ 。</p><ol><li>选取初值$w_0,b_0$</li><li>在训练集中选取数据$(x_i,y_i)$</li><li>如果$y_i(w \cdot x_i + b) \leqslant 0$</li></ol><script type="math/tex; mode=display">w \leftarrow w + \eta y_ix_i\\b \leftarrow b + \eta y_i</script><ol><li>转至 2 ，直至训练集中没有误分类点。</li></ol></blockquote><h2 id="2-3-2-算法的收敛性"><a href="#2-3-2-算法的收敛性" class="headerlink" title="2.3.2 算法的收敛性"></a>2.3.2 算法的收敛性</h2><p>​        对于线性可分数据集感知机学习算法原始形式收敛，即经过<strong>有限次</strong>迭代可以得到一个将训练数据集完全正确划分的分离超平面及感知机模型。所以只需证明迭代次数$k$有上界即可。</p><h2 id="2-3-3-感知机学习算法的对偶形式"><a href="#2-3-3-感知机学习算法的对偶形式" class="headerlink" title="2.3.3 感知机学习算法的对偶形式"></a>2.3.3 感知机学习算法的对偶形式</h2><p>​        对偶形式的基本想法是，将$w$和$b$表示为实例$x_i$和标记$y_i$的线性组合的形式，通过求解其系数而求得$w$和$b$。设初始值$w_0=0,b_0=0$，误分类点$(x_i,y_i)$在更新过程中被使用的<strong>次数为$ n_i $，</strong>则最后学习到的$w和b$可以分别表示为</p><script type="math/tex; mode=display">w = \sum_{i=1}^{N}\alpha_i y_i x_i\\b = \sum_{i=1}^{N} \alpha_i y_i</script><p>其中，$\alpha_i = n_i \eta i= 1,2,\ldots,N$。<strong>实例点更新次数越多，意味着它距离分离超平面越近</strong>，也就越难正确分类。感知机学习算法的对偶形式具体如下：</p><blockquote><p><em>输入：</em> </p><ol><li><p>$T=\left\{\left(x_{1}, y_{1}\right),\left(x_{2}, y_{2}\right), \cdots,\left(x_{N}, y_{N}\right)\right\}$，</p><p>其中$x_i \in \mathcal{X}=R^n, y_i  \in \mathcal{Y}=\{+1,-1\}, \quad i=1,2, \ldots, N$</p></li><li><p>学习率 $\eta(0&lt;\eta \leqslant1)$</p></li></ol><p><em>输出：</em> $ \alpha ,b; 感知机模型 f(x) =\operatorname{sign}\left(\sum_{j=1}^{N} \alpha_{j} y_{j} x_{j} \cdot x+b\right), 其中a = (a_1,a_2,\ldots,a_N)^{\mathrm{T}}$</p><ol><li><p>$a \leftarrow 0, b \leftarrow 0$</p></li><li><p>在训练集中选取数据$(x_i,y_i)$</p></li><li><p>如果$y_{i}\left(\sum_{j=1}^{N} \alpha_{j} y_{j} x_{j} \cdot x_{i}+b\right) \leqslant 0$</p><script type="math/tex; mode=display">\begin{array}{c}{\alpha_{i} \leftarrow \alpha_{i}+\eta} \\ {b \leftarrow b+\eta y_{i}}\end{array}</script></li><li><p>转至2直到没有误分类数据。</p></li></ol></blockquote><p>​        对偶形式中可知训练实例仅以内积的形式出现。可以预先将训练集中实例间的内积计算出来并以矩阵的形式存储，这个矩阵就是所谓的<strong>Gram矩阵（Gram matrix）</strong>。</p><script type="math/tex; mode=display">G=\left[x_{i} \cdot x_{j}\right]_{N \times N}</script><p><strong>习题：</strong></p><p>​        <strong>2.1</strong>　Minsky与Papert指出：感知机因为是线性模型，所以不能表示复杂的函数，如异或（XOR）。验证感知机为什么不能表示异或。</p><p>​        <strong>解：</strong>异或函数(XOR)表示如下：            </p><div class="table-container"><table><thead><tr><th style="text-align:center">$x_{1}$</th><th style="text-align:center">$x_{2}$</th><th style="text-align:center">$x_{1} \oplus x_{2}$</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr></tbody></table></div><p>​            在图中展示如下：</p><p>​            <img src="http://ww1.sinaimg.cn/large/005XIOOuly1g4kfyxt43tj30jg0elmx0.jpg" alt></p><p>​            显然异或的数据集是线性不可分的，我们无法用一条直线将两类样本划分，所以感知机不能表示异或。</p><p>​        <strong>2.2</strong>　模仿例题2.1，构建从训练数据集求解感知机模型的例子。</p><p>​        <strong>2.3</strong>　证明以下定理：样本集线性可分的充分必要条件是正实例点集所构成的凸壳与负实例点集所构成的凸壳互不相交。</p><p>​        <font color="blue">Todo</font></p><p><strong>本文作者</strong>：Gong Jintao<br><strong>本文地址</strong>： <a href="http://blog.gongjintao.com/2019/07/01/《统计学习方法》——感知机/">http://blog.gongjintao.com/2019/07/01/《统计学习方法》——感知机/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2-1-感知机模型&quot;&gt;&lt;a href=&quot;#2-1-感知机模型&quot; class=&quot;headerlink&quot; title=&quot;2.1 感知机模型&quot;&gt;&lt;/a&gt;2.1 感知机模型&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;     假设输入空间 （特征空间）是$\ma
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://blog.gongjintao.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="《统计学习方法》" scheme="http://blog.gongjintao.com/tags/%E3%80%8A%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《统计学习方法》》——概论</title>
    <link href="http://blog.gongjintao.com/2019/06/30/%E3%80%8A%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E3%80%8B%E3%80%8B%E2%80%94%E2%80%94%E6%A6%82%E8%AE%BA/"/>
    <id>http://blog.gongjintao.com/2019/06/30/《统计学习方法》》——概论/</id>
    <published>2019-06-30T09:23:10.000Z</published>
    <updated>2019-06-30T10:08:43.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-1-统计学习"><a href="#1-1-统计学习" class="headerlink" title="1.1 统计学习"></a>1.1 统计学习</h1><blockquote><p><strong>定义</strong>：统计学习（statistical learning）是关于计算机基于数据构建概率统计模型并运用模型对数据进行预测与分析的一门学科。统计学习也称为统计机器学习（statistical machine learning）。</p></blockquote><a id="more"></a><h2 id="1-1-1-特点"><a href="#1-1-1-特点" class="headerlink" title="1.1.1 特点"></a>1.1.1 特点</h2><blockquote><ol><li>建立在计算机及网络之上的</li><li>以数据为研究对象</li><li>目的是对数据进行预测与分析</li><li>以方法为中心</li><li>包含了概率论、统计学、信息论、计算理论、最优化理论及计算机科学等多个领域，并且在发展中逐步形成独自的理论体系与方法论。</li></ol></blockquote><h2 id="1-1-2-对象"><a href="#1-1-2-对象" class="headerlink" title="1.1.2  对象"></a>1.1.2  对象</h2><blockquote><p>​        统计学习的对象是数据（data）。它从数据出发，提取数据的特征，抽象出数据的模型，发现数据中的知识，又回到对数据的分析与预测中去。</p><p>​        统计学习关于数据的基本假设是同类数据具有一定的统计规律性，这是统计学习的前提。由于它们具有统计规律性，所以可以用概率统计方法来加以处理。比如，可以用随机变量描述数据中的特征，用概率分布描述数据的统计规律。</p><p>​        在统计学习过程中，以变量或变量组表示数据。数据分为由连续变量和离散变量表示的类型。</p></blockquote><h2 id="1-1-3-目的"><a href="#1-1-3-目的" class="headerlink" title="1.1.3 目的"></a>1.1.3 目的</h2><blockquote><p>​        统计学习总的目标就是考虑学习什么样的模型和如何学习模型，以使模型能对数据进行准确的预测与分析，同时也要考虑尽可能地提高学习效率。</p></blockquote><h2 id="1-1-4-方法"><a href="#1-1-4-方法" class="headerlink" title="1.1.4 方法"></a>1.1.4 方法</h2><blockquote><p><em>统计学习包括：</em></p><ol><li>监督学习(supervised learning)</li><li>非监督学习(unsupervised learning)</li><li>半监督学习(semi-supervised learning)</li><li>强化学习(reinforcement learning)</li></ol><p>监督学习的方法可以概括成：从给定的、有限的、用于学习的<strong>训练数据(training data)集合</strong>出发，假设数据是<strong>独立同分布</strong>产生的；并且假设要学习的模型属于某个函数的集合，称为<strong>假设空间(hypothesis space)</strong>；应用某个<strong>评价准则(evaluation criterion)</strong>，从假设空间中选取一个<strong>最优的模型</strong>，使它对已知训练数据及<strong>未知测试数据(test data)</strong>在给定的评价准则下有最优的预测；最优模型的选取由<strong>算法</strong>实现。所以统计学习方法的三要素，分别为<strong>模型（model）、策略（strategy）和算法（algorithm）</strong>。</p><p><em>实现统计学习方法的步骤如下：</em></p><ol><li>得到一个有限的<strong>训练数据集合</strong>；</li><li>确定包含所有可能的模型的<strong>假设空间</strong>，即学习模型的集合；</li><li>确定模型选择的准则，即学习的<strong>策略</strong>；</li><li>实现求解最优模型的算法，即学习的<strong>算法</strong>；</li><li>通过学习方法选择最优模型；</li><li>利用学习的最优模型对新数据进行<strong>预测或分析</strong>。</li></ol><p><em>监督学习的主要应用问题：</em></p><ul><li>分类问题</li><li>标注问题</li><li>回归问题</li></ul></blockquote><h2 id="1-1-5-研究"><a href="#1-1-5-研究" class="headerlink" title="1.1.5 研究"></a>1.1.5 研究</h2><blockquote><p>统计学习研究一般包括<strong>统计学习方法（statistical learning method）、统计学习理论（statistical learning theory）及统计学习应用（application of statistical learning）</strong>三个方面。</p><ul><li>统计学习方法：开发新的学习方法</li><li>统计学习理论：探求统计学习方法的有效性与效率，以及统计学习的基本理论问题</li><li>统计学习应用：考虑将统计学习方法应用到实际问题中去，解决实际问题</li></ul></blockquote><h2 id="1-1-6-重要性"><a href="#1-1-6-重要性" class="headerlink" title="1.1.6 重要性"></a>1.1.6 重要性</h2><blockquote><ol><li>统计学习是处理海量数据的有效方法。</li><li>统计学习是计算机智能化的有效手段。</li><li>统计学习是计算机科学发展的一个重要组成部分。</li></ol></blockquote><h1 id="1-2-监督学习"><a href="#1-2-监督学习" class="headerlink" title="1.2 监督学习"></a>1.2 监督学习</h1><h2 id="1-2-1-基本概念"><a href="#1-2-1-基本概念" class="headerlink" title="1.2.1 基本概念"></a>1.2.1 基本概念</h2><blockquote><ol><li><strong>输入空间（input space）</strong>: 输入的所有可能取值的集合。</li><li><strong>输出空间（output space）</strong>: 输出的所有可能 取值的集合。</li><li><strong>特征空间（feature space）</strong>：每个具体的输入是一个<strong>实例（instance）</strong>，通常由<strong>特征向量（feature vector）</strong>表示。这时，所有特征向量存在的空间称为<strong>特征空间（feature space）</strong>。<font color="blue">模型实际上都是定义在特征空间上的</font>。</li></ol><p><em>根据输入、输出变量的不同类型，对预测任务给予不同的名称：</em></p><ul><li>均为连续变量：回归问题</li><li>输出变量为有限个离散变量：分类问题</li><li>均为变量序列：标注问题</li></ul><ol><li><strong>联合概率分布</strong>: 监督学习假设输入与输出的随机变量 X 和 Y 遵循联合概率分布P(X,Y)。P(X,Y)表示分布函数，或分布密度函数。</li><li><strong>假设空间（hypothesis space）</strong>: 监督学习的目的在于学习一个由输入到输出的映射，这一映射由模型来表示。模型属于由输入空间到输出空间的映射的集合，这个集合就是假设空间。</li></ol><p>监督学习的模型可以是概率模型或非概率模型，由条件概率分布P(Y|X)或决策函数（decision function）Y=f(X)表示，随具体学习方法而定。对具体的输入进行相应的输出预测时，写作P(y|x)或Y=f(x)。</p></blockquote><h2 id="1-2-2-问题的形式化"><a href="#1-2-2-问题的形式化" class="headerlink" title="1.2.2 问题的形式化"></a>1.2.2 问题的形式化</h2><p><img src="https://i.loli.net/2019/06/28/5d158c3b1400839934.png" alt="监督学习问题"></p><h1 id="1-3-统计学习三要素"><a href="#1-3-统计学习三要素" class="headerlink" title="1.3 统计学习三要素"></a>1.3 统计学习三要素</h1><blockquote><p>方法 = 模型＋策略 + 算法</p></blockquote><h2 id="1-3-1-模型"><a href="#1-3-1-模型" class="headerlink" title="1.3.1 模型"></a>1.3.1 模型</h2><blockquote><p>在监督学习过程中，模型就是所要学习的条件概率分布或决策函数。模型的假设空间（hypothesis space）包含所有可能的条件概率分布或决策函数。由集合表示如下：</p><script type="math/tex; mode=display">\mathcal{F}=\left\{f | Y=f_{\theta}(X), \theta \in \mathbf{R}^{n}\right\}\\</script><p>或者</p><script type="math/tex; mode=display">\mathcal{F}=\left\{P\left|P_{\theta}(Y | X), \theta \in \mathbf{R}^{n}\right\}\right.</script><p>公式(1)表示定义在决策函数上的集合，公式(2)表示定义在条件概率上的集合。其中$ \theta $ 表示为<strong>参数向量（parameter space）</strong> 。</p></blockquote><h2 id="1-3-2-策略"><a href="#1-3-2-策略" class="headerlink" title="1.3.2 策略"></a>1.3.2 策略</h2><blockquote><p>首先引入损失函数与风险函数的概念。</p><ul><li><p><strong>损失函数(loss function)</strong>度量模型一次预测的好坏，和<strong>代价函数(cost function)</strong>表示的意义相同</p><blockquote><p><strong>常用的损失函数有以下几种：</strong></p><ol><li>0-1损失函数（0-1 loss function）</li></ol><script type="math/tex; mode=display">L(Y, f(X))=\left\{\begin{array}{ll}{1,} & {Y \neq f(X)} \\ {0,} & {Y=f(X)}\end{array}\right.</script><ol><li>平方损失函数（quadratic loss function）</li></ol><script type="math/tex; mode=display">L(Y, f(X))=(Y-f(X))^{2}</script><ol><li>绝对损失函数（absolute loss function）</li></ol><script type="math/tex; mode=display">L(Y, f(X))=|Y-f(X)|</script><ol><li>对数损失函数（logarithmic loss function）或对数似然损失函数</li></ol><script type="math/tex; mode=display">L(Y, P(Y | X))=-\log P(Y | X)</script></blockquote></li><li><p><strong>风险函数(risk function)</strong>度量平均意义下模型预测的好坏，也称为<strong>期望损失（expected loss）</strong>，定义如下：</p><blockquote><script type="math/tex; mode=display">R_{\mathrm{exp}}(f)=E_{P}[L(Y, f(X))]=\int_{\mathcal{X} \times \mathcal{Y}} L(y, f(x)) P(x, y) \mathrm{d} x \mathrm{d} y</script></blockquote></li></ul><p>​        </p><p>​        学习的目标就是选择期望风险最小的模型。但是由于联合分布$P(X,Y)$是未知的，$R_{exp}(f)$不能直接计算。于是引入<strong>经验风险</strong>。</p><ul><li><p><strong>经验风险（empirical risk）</strong>：模型f(X)关于训练数据集的平均损失，也称<strong>经验损失（empirical loss）</strong>；记作$R_{emp}$:</p><blockquote><script type="math/tex; mode=display">R_{\mathrm{emp}}(f)=\frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right)</script></blockquote></li></ul><p>​        </p><p>​        根据大数定律，当样本容量N趋于无穷时，经验风险$R_{emp}f$趋于期望风险$R_{exp}f$。但是，由于现实中训练样本数目有限，甚至很小，所以用经验风险估计期望风险常常并不理想，要对经验风险进行一定的<strong>矫正</strong>。这就关系到监督学习的两个基本策略：<strong>经验风险最小化和结构风险最小化。</strong></p><ul><li><p><strong>经验风险最小化（empirical risk minimization，ERM）</strong>：按照经验风险最小化求最优模型就是求解最优化问题；</p><blockquote><script type="math/tex; mode=display">\min _{f \in \mathcal{F}} \frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right)</script><p>其中，$\mathcal{F}$ 是假设空间。</p></blockquote></li><li><p><strong>结构风险最小化（structural risk minimization，SRM）</strong>：是为了防止过拟合而提出来的策略。结构风险最小化等价于<strong>正则化（regularization）</strong>。结构风险在经验风险上加上表示模型复杂度的<strong>正则化项（regularizer）或罚项（penalty term）</strong>。</p><blockquote><script type="math/tex; mode=display">R_{\mathrm{srm}}(f)=\frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right)+\lambda J(f)</script><p>其中$J(f)$为模型的复杂度，是定义在假设空间 $\mathcal{F}$上的泛函。模型 $f$ 越复杂，复杂度$J(f)$就越大；反之，模型 $f$ 越简单，复杂度$J(f)$就越小。$\lambda \ge 0$是系数，用以权衡经验风险和模型复杂度。所以求最优模型，就是求解最优化问题：</p><script type="math/tex; mode=display">\min _{f \in \mathcal{F}} \frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right)+\lambda J(f)</script></blockquote></li></ul><p>这样，监督学习问题就变成了经验风险或结构风险函数的最优化问题。这时经验或结构风险函数是最优化的<strong>目标函数</strong>。</p></blockquote><h2 id="1-3-3-算法"><a href="#1-3-3-算法" class="headerlink" title="1.3.3 算法"></a>1.3.3 算法</h2><blockquote><p>​        算法是指学习模型的具体计算方法。统计学习基于训练数据集，根据学习策略，从假设空间中选择最优模型，最后需要考虑用什么样的计算方法求解最优模型。这时，统计学习问题归结为最优化问题，统计学习的算法成为求解最优化问题的算法。    </p></blockquote><h1 id="1-4-模型评估与模型选择"><a href="#1-4-模型评估与模型选择" class="headerlink" title="1.4 模型评估与模型选择"></a>1.4 模型评估与模型选择</h1><h2 id="1-4-1-训练误差与测试误差"><a href="#1-4-1-训练误差与测试误差" class="headerlink" title="1.4.1 训练误差与测试误差"></a>1.4.1 训练误差与测试误差</h2><blockquote><p>​        当损失函数给定时，基于损失函数的模型的<strong>训练误差（training error）</strong>和模型的<strong>测试误差（test error）</strong>就自然成为学习方法评估的标准。训练误差的大小，对判断给定的问题是不是一个容易学习的问题是有意义的，但本质上不重要。测试误差反映了学习方法对未知的测试数据集的预测能力，是学习中的重要概念。通常将学习方法对未知数据的预测能力称为<strong>泛化能力（generalization ability）</strong>。</p></blockquote><h2 id="1-4-2-过拟合与模型选择"><a href="#1-4-2-过拟合与模型选择" class="headerlink" title="1.4.2 过拟合与模型选择"></a>1.4.2 过拟合与模型选择</h2><blockquote><p>​        如果一味追求提高对训练数据的预测能力，所选模型的复杂度则往往会比真模型更高。这种现象称为<strong>过拟合（over-fitting）</strong>。过拟合是指学习时选择的模型所包含的参数过多，以致于出现这一模型对已知数据预测得很好，但对未知数据预测得很差的现象。</p></blockquote><h1 id="1-5-正则化与交叉验证"><a href="#1-5-正则化与交叉验证" class="headerlink" title="1.5 正则化与交叉验证"></a>1.5 正则化与交叉验证</h1><h2 id="1-5-1-正则化"><a href="#1-5-1-正则化" class="headerlink" title="1.5.1 正则化"></a>1.5.1 正则化</h2><blockquote><p>​        模型选择的典型方法是<strong>正则化（regularization）</strong>。正则化是结构风险最小化策略的实现，是在经验风险上加一个<strong>正则化项（regularizer）或罚项(penalty term)</strong>。正则化项一般是<strong>模型复杂度的单调递增函数</strong>，模型越复杂，正则化值就越大。比如，正则化项可以是模型参数向量的范数。</p><p>​        正则化一般具有如下形式：</p><script type="math/tex; mode=display">\min _{f \in \mathcal{F}} \frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right)+\lambda J(f)</script><p>其中，第1项是经验风险，第2项是正则化项，$\lambda \ge 0$为调整两者之间关系的系数。</p></blockquote><h2 id="1-5-2-交叉验证"><a href="#1-5-2-交叉验证" class="headerlink" title="1.5.2 交叉验证"></a>1.5.2 交叉验证</h2><blockquote><p>​        如果给定的样本数据<strong>充足</strong>，进行模型选择的一种简单方法是<strong>随机地</strong>将数据集切分成三部分，分别为<strong>训练集（training set）、验证集（validation set）和测试集（test set）</strong>。训练集用来训练模型，验证集用于模型的选择，而测试集用于最终对学习方法的评估。在学习到的不同复杂度的模型中，选择对验证集有最小预测误差的模型。</p><p>​        但是，在许多实际应用中数据是不充足的。为了选择好的模型，可以采用交叉验证方法。<strong>交叉验证的基本想法</strong>是重复地使用数据；把给定的数据进行切分，将切分的数据集组合为训练集与测试集，在此基础上反复地进行训练、测试以及模型选择。</p><p>​        有以下几种常用的交叉验证方法：</p><ol><li><strong>简单交叉验证</strong>：首先随机地将已给数据分为两部分，一部分作为训练集，另一部分作为测试集；然后用训练集在各种条件下训练模型，从而得到不同的模型；在测试集上评价各个模型的测试误差，选出测试误差最小的模型。</li><li><strong>S折交叉验证</strong>：首先随机地将已给数据切分为S个互不相交的大小相同的子集；然后利用S-1个子集的数据训练模型，利用余下的子集测试模型；将这一过程对可能的S种选择重复进行；最后选出S次评测中平均测试误差最小的模型。</li><li><strong>留一交叉验证</strong>：S折交叉验证的特殊情形是S＝N，称为留一交叉验证（leave-one-out cross validation）。往往在数据缺乏的情况下使用。</li></ol></blockquote><h1 id="1-6-泛化能力"><a href="#1-6-泛化能力" class="headerlink" title="1.6 泛化能力"></a>1.6 泛化能力</h1><h2 id="1-6-1-泛化误差"><a href="#1-6-1-泛化误差" class="headerlink" title="1.6.1 泛化误差"></a>1.6.1 泛化误差</h2><blockquote><p>​        现实中采用最多的办法是通过测试误差来评价学习方法的泛化能力。但这种评价是依赖于测试数据集的。因为测试数据集是有限的，很有可能由此得到的评价结果是不可靠的。统计学习理论试图从理论上对学习方法的泛化能力进行分析。</p><p>​        首先给出泛化误差的定义。如果学到的模型是$\hat{f}$，那么用这个模型对未知数据预测的误差即为<strong>泛化误差（generalization error）</strong></p><script type="math/tex; mode=display">R_{\mathrm{exp}}(\hat{f})=E_{P}[L(Y, \hat{f}(X))]=\int_{\mathcal{X} \times \mathcal{Y}} L(y, \hat{f}(x)) P(x, y) \mathrm{d} x \mathrm{d} y</script><p>事实上，泛化误差就是所学习到的模型的期望风险。</p></blockquote><h2 id="1-6-2-泛化误差上界"><a href="#1-6-2-泛化误差上界" class="headerlink" title="1.6.2 泛化误差上界"></a>1.6.2 泛化误差上界</h2><blockquote><p>​        学习方法的泛化能力分析往往是通过研究泛化误差的概率上界进行的，简称为<strong>泛化误差上界（generalization error bound）。</strong>泛化误差上界通常具有以下性质：</p><ul><li>它是样本容量的函数，当样本容量增加时，泛化上界趋于0；</li><li>它是假设空间容量（capacity）的函数，假设空间容量越大，模型就越难学，泛化误差上界就越大。</li></ul><p><strong><font color="red">关于对二类分类问题，泛化误差上界不等式的证明，即证明：</font></strong></p><p>​        当假设空间是有限个函数的集合$\mathcal{F}＝{f_1，f_2,…,f_d}$时，对任意一个函数 $f \in \mathcal{F}$，至少以概率$1-\delta$，以下不等式成立：</p><script type="math/tex; mode=display">R(f) \leqslant \hat{R}(f)+\varepsilon(d, N, \delta)</script><p>其中，</p><script type="math/tex; mode=display">\varepsilon(d, N, \delta)=\sqrt{\frac{1}{2 N}\left(\log d+\log \frac{1}{\delta}\right)}</script><p>需要用到Hoeffding不等式：</p><p>​        设是$S_n = \sum_{i-1}^{n}X_i$是独立随机变量$X_1,X_2,…,X_n$之和，$X_i \in [a_i，b_i ]$，则对任意$t &gt; 0$，以下不等式成立：</p><script type="math/tex; mode=display">\begin{array}{l}{P\left(S_{n}-E S_{n} \geqslant t\right) \leqslant \exp \left(\frac{-2 t^{2}}{\sum_{i=1}^{n}\left(b_{i}-a_{i}\right)^{2}}\right)} \\ {P\left(E S_{n}-S_{n} \geqslant t\right) \leqslant \exp \left(\frac{-2 t^{2}}{\sum_{i=1}^{n}\left(b_{i}-a_{i}\right)^{2}}\right)}\end{array}</script><p><strong>证明：</strong></p><p>​        ∵ 对于任意函数$f \in \mathcal{F}$，$\hat{R}(f)$是 N 个独立的随机变量 $L(Y,f(X))$的样本均值，$R(f)$是随机变量$L(Y,f(X))$的期望值。如果损失函数取值于区间$[0,1]$，即对所有$i$，$[a_i，b_i ]＝[0,1]$，那么由Hoeffding不等式可得：</p><script type="math/tex; mode=display">\begin{aligned} P(R(f)-\hat{R}(f) \geqslant \varepsilon) &= P(E[\sum_{i=1}^{N}L\left(y_i,f(x_i) \right)]- \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right) \geqslant N \cdot\varepsilon) \\& \leqslant \exp \left(\frac{-2 (N \cdot \varepsilon)^{2}}{\sum_{i=1}^{n}\left(b_{i}-a_{i}\right)^{2}}\right)\\ & = \exp \left(\frac{-2 (N \cdot \varepsilon)^{2}}{N}\right)\\& = exp \left( -2N\varepsilon^2\right)\end{aligned}</script><p>由于$\mathcal{F}=\{ f_1,f_2,…,f_d \}$是一个有限集合，故</p><script type="math/tex; mode=display">\begin{aligned}P(\exists f \in \mathcal{F}:R(f)-\hat{R}(f) \geqslant \varepsilon) &=P\left(\bigcup_{f \in \mathcal{F}}\{R(f)-\hat{R}(f) \geqslant \varepsilon\}\right) \\& \leqslant \sum_{f \in \mathcal{F}}P(R(f)-\hat{R}(f) \geqslant \varepsilon) \\& \leqslant d  \exp(-2N\varepsilon^2)\end{aligned}</script><p>或者等价的，对任意$f \in \mathcal{F}$，有</p><script type="math/tex; mode=display">P(R(f)-\hat{R}(f)<\varepsilon) \geqslant 1-d \exp \left(-2 N \varepsilon^{2}\right)</script><p>令</p><script type="math/tex; mode=display">\delta=d \exp \left(-2 N \varepsilon^{2}\right)</script><p>则</p><script type="math/tex; mode=display">P(R(f)<\hat{R}(f)+\varepsilon) \geqslant 1-\delta</script><p>即至少以概率$1-\delta$有$\mathrm{R}(\mathrm{f})&lt;\hat{R}(\mathrm{f})+\mathcal{E}，$其中$\mathcal{E}$由式(18)得到，即为式(15)</p></blockquote><h1 id="1-7-生成模型与判别模型"><a href="#1-7-生成模型与判别模型" class="headerlink" title="1.7 生成模型与判别模型"></a>1.7 生成模型与判别模型</h1><blockquote><p>​        监督学习方法又可以分为<strong>生成方法（generative approach）</strong>和<strong>判别方法（discriminative approach）</strong>。所学到的模型分别称为<strong>生成模型（generative model）</strong>和<strong>判别模型（discriminative model）。</strong></p><p>​        生成方法由数据学习联合概率分布P(X,Y)，然后求出条件概率分布P(Y|X)作为预测的模型，即生成模型。之所以称为生成方法，是因为模型表示了给定输入X产生输出Y的生成关系。典型的生成模型有：朴素贝叶斯法和隐马尔可夫模型。</p><p>​        判别方法由数据直接学习决策函数f(X)或者条件概率分布P(Y|X)作为预测的模型，即判别模型。典型的判别模型包括：k近邻法、感知机、决策树、逻辑斯谛回归模型、最大熵模型、支持向量机、提升方法和条件随机场等</p></blockquote><h1 id="1-8-分类问题"><a href="#1-8-分类问题" class="headerlink" title="1.8 分类问题"></a>1.8 分类问题</h1><blockquote><p>​        分类是监督学习的一个核心问题。在监督学习中，当<strong>输出变量Y取有限个离散值时</strong>，预测问题便成为分类问题。这时，输入变量X可以是离散的，也可以是连续的。监督学习从数据中学习一个分类模型或分类决策函数，称为<strong>分类器</strong>（classifier）。</p><p>​        评价分类器性能的指标一般是<strong>分类准确率（accuracy）</strong>，其定义是：对于给定的测试数据集，分类器正确分类的样本数与总样本数之比。</p><p>​        对于二分类问题常用的评价指标是<strong>精确率（precision）与召回率（recall）</strong>。通常以关注的类为<strong>正类</strong>，其他类为<strong>负类</strong>，分类器在测试数据集上的预测或正确或不正确，4种情况出现的总数分别记作：</p><ul><li>TP——将正类预测为正类数；</li><li>FN——将正类预测为负类数；</li><li>FP——将负类预测为正类数；</li><li>TN——将负类预测为负类数；</li></ul><p>则<strong>精确率</strong>定义为</p><script type="math/tex; mode=display">P = \frac{TP}{TP+FP}</script><p><strong>召回率</strong>定义为</p><script type="math/tex; mode=display">R=\frac{TP}{TP+FN}</script><p>此外，还有$F_1$值，是精确率和召回率的调和均值，即</p><script type="math/tex; mode=display">\frac{1}{F_1} = \frac{1}{2}(\frac{1}{P} + \frac{1}{R}) \\F_{1}=\frac{2 T P}{2 T P+F P+F N}</script><p>精确率和召回率都高时，$F_1$值也会高。</p></blockquote><h1 id="1-9-标注问题"><a href="#1-9-标注问题" class="headerlink" title="1.9 标注问题"></a>1.9 标注问题</h1><blockquote><p>​        标注问题的输入是一个<strong>观测序列</strong>，输出是一个<strong>标记序列或状态序列</strong>。标注问题的目标在于学习一个模型，使它能够对观测序列给出标记序列作为预测。</p><p>​        评价标注模型的指标与评价分类模型的指标一样，常用的有标注准确率、精确率和召回率。其定义与分类模型相同。</p><p>​        标注常用的统计学习方法有：隐马尔可夫模型、条件随机场。</p></blockquote><h1 id="1-10-回归问题"><a href="#1-10-回归问题" class="headerlink" title="1.10 回归问题"></a>1.10 回归问题</h1><blockquote><p>​        回归用于预测输入变量（自变量）和输出变量（因变量）之间的<strong>关系</strong>，特别是当输入变量的值发生变化时，输出变量的值随之发生的变化。回归问题的学习等价于函数拟合：选择一条函数曲线使其很好地拟合已知数据且很好地预测未知数据。</p><p>​        回归问题按照输入变量的个数，分为<strong>一元回归和多元回归</strong>；按照输入变量和输出变量之间关系的类型即模型的类型，分为<strong>线性回归和非线性回归</strong>。</p><p>​        回归学习最常用的损失函数是<strong>平方损失函数</strong>，在此情况下，回归问题可以由著名的<strong>最小二乘法（least squares）</strong>求解。</p></blockquote><h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h1><p>​        <strong>1.1</strong>     说明伯努利模型的极大似然估计以及贝叶斯估计中的统计学习方法三要素。伯努利模型是定义在取值为0与1的随机变量上的概率分布。假设观测到伯努利模型n次独立的数据生成结果，其中k次的结果为1，这时可以用极大似然估计或贝叶斯估计来估计结果为1的概率。</p><p>​        <strong>解：</strong> </p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">极大似然估计</th><th style="text-align:center">贝叶斯估计</th></tr></thead><tbody><tr><td style="text-align:center">模型</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">策略</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">算法</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr></tbody></table></div><p>​                定义随机变量$A$为一次伯努利实验的结果，可知$A$的取值为$\{0,1\}$；</p><p>​                设$P\{A = 1\} = \theta$，则$P\{A = 0\} = 1- \theta$</p><p>​                <strong>极大似然估计</strong></p><p>​                首先得到似然函数：</p><script type="math/tex; mode=display">L(\theta) = \prod_{i=1}^{n}P(A_i)= C_{n}^{k}\theta^k(1-\theta)^{n-k} \\</script><p>​                然后取对数得到对数似然函数：</p><script type="math/tex; mode=display">\ln(L(\theta)) = \ln C_{n}^{k} + k \cdot \ln\theta + (n-k) \cdot \ln(1-\theta)</script><p>​                然后在上式两边对 $\theta$ 求导可得</p><script type="math/tex; mode=display">\frac{\partial \ln(L(\theta))}{\partial \theta} = \frac{k}{\theta} - \frac{n-k}{1-\theta}</script><p>​                令上式等于 0 ， 可得</p><script type="math/tex; mode=display">\theta = \frac{k}{n}</script><p>​                <strong>贝叶斯估计</strong></p><p>​                todo</p><p>​        <strong>1.2 </strong>    通过经验风险最小化推导极大似然估计。证明模型是条件概率分布，当损失函数是对数损失函数时，经验风险最小化等价于极大似然估计。</p><p>​        <strong>证明：</strong> 当模型是条件概率分布，即$\mathcal{F}=\left\{P\left|P_{\theta}(Y | X), \theta \in \mathbf{R}^{n}\right\}\right.$；</p><p>​                    损失函数是对数损失函数时，即$L(Y, P(Y | X))=-\log P(Y | X)$;</p><p>​                    则<strong>经验风险</strong>如下：</p><script type="math/tex; mode=display">\begin{aligned}R_{\mathrm{emp}}(f)=\frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right) & = \frac{1}{N}\sum_{i=1}^{N}L(y_i,P(y_i|x_i))\\&= \frac{1}{N}\sum_{i=1}^{N}-\log P_\theta(y_i|x_i)\\\end{aligned}</script><p>​                    则经验风险最小化为：</p><script type="math/tex; mode=display">\hat{\theta} = arg\min _{P \in \mathcal{F}}\frac{1}{N}\sum_{i=1}^{N}-\log P_\theta(y_i|x_i)\\</script><p>​                    <strong>极大似然法：</strong></p><p>​                    先求似然函数，如下：</p><script type="math/tex; mode=display">L(\theta) = \prod_{i=1}^{N} P_{\theta}\left(y_{i} | x_{i}\right)</script><p>​                    所以极大似然估计为：</p><script type="math/tex; mode=display">\hat{\theta}=arg \max_{P\in \mathcal{F}}  \sum_{i=1}^{N}\log P_{\theta}\left(y_{i} | x_{i}\right)</script><p>等价于：</p><script type="math/tex; mode=display">\hat{\theta}=arg \min_{P\in \mathcal{F}}  \sum_{i=1}^{N}-\log P_{\theta}\left(y_{i} | x_{i}\right)</script><p>​                因此证得模型是条件概率分布，当损失函数是对数损失函数时，经验风险最小化等价于极大似然估计。</p><p><strong>本文作者</strong>：Gong Jintao<br><strong>本文地址</strong>： <a href="http://blog.gongjintao.com/2019/06/30/《统计学习方法》》——概论/">http://blog.gongjintao.com/2019/06/30/《统计学习方法》》——概论/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-1-统计学习&quot;&gt;&lt;a href=&quot;#1-1-统计学习&quot; class=&quot;headerlink&quot; title=&quot;1.1 统计学习&quot;&gt;&lt;/a&gt;1.1 统计学习&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;：统计学习（statistical learning）是关于计算机基于数据构建概率统计模型并运用模型对数据进行预测与分析的一门学科。统计学习也称为统计机器学习（statistical machine learning）。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://blog.gongjintao.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="《统计学习方法》" scheme="http://blog.gongjintao.com/tags/%E3%80%8A%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的数组迭代方法总结 </title>
    <link href="http://blog.gongjintao.com/2019/06/30/javascript%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E8%BF%AD%E4%BB%A3%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.gongjintao.com/2019/06/30/javascript中的数组迭代方法总结/</id>
    <published>2019-06-30T01:28:11.368Z</published>
    <updated>2019-06-30T02:57:49.502Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ECMAScript-5中的数组迭代方法总结"><a href="#ECMAScript-5中的数组迭代方法总结" class="headerlink" title="ECMAScript 5中的数组迭代方法总结"></a><em>ECMAScript 5</em>中的数组迭代方法总结</h1><p>在 <strong><em>ECMAscript 5</em></strong> 中为数组定义了5个迭代方法，每个方法都接收两个参数：<a id="more"></a></p><blockquote><ol><li>要在每一项上运行的函数,该函数可接受三个参数(<em>通常只需要第一个参数值，后面两个可以忽略</em>)：<ul><li>数组项的值: <em>item</em></li><li>该项在数组中的位置: <em>index</em></li><li>数组对象本身: <em>array</em></li></ul></li><li>运行调用函数(第一个参数)的作用域对象，为可选参数。如果有第二个参数，则调用的函数被看做是第二个参数的方法。也就是说，在调用函数时传递进去的第二个参数作为它的this关键字的值来使用。</li></ol></blockquote><p>下面依次介绍这5个方法的作用和用法：</p><h2 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h2><blockquote><p>对数组中的每一项运行给定函数，如果该函数对每一项都返回<strong>true</strong>，则返回<strong>true</strong>；否则返回<strong>false</strong>。示例如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> everyResult = arr.every(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert(everyResult); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h2 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h2><blockquote><p>对数组中的每一项运行给定函数，如果该函数对任一项返回<strong>true</strong>，则返回<strong>true</strong>；否则返回<strong>false</strong>。示例如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> someResult = arr.some(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert(someResult); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><font color="red"><em> 注意：</em>every()和some()方法较为相似。要区分它们的判断条件。前者需全部满足才返回true，后者只需一项满足即可。</font><h2 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h2><blockquote><p>对数组中的每一项运行给定函数，返回该函数会返回<strong>true</strong>的项组成的数组。示例如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> filterResult = arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert(filterResult);    <span class="comment">//[3,4,5,4,3]</span></span><br></pre></td></tr></table></figure><h2 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h2><blockquote><p>对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。示例如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mapResult = arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (item*<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert(mapResult);   <span class="comment">//[2,4,6,8,10,8,6,4,2]</span></span><br></pre></td></tr></table></figure><font color="red"> <em>注意：</em> filter()和map()返回的都是新的数组，但不改变原数组的值。</font><h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h2><blockquote><p>对数组中的每一项运行给定函数，这个函数没有返回值,本质上与使用for循环迭代数组一样。示例如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">arr.forEach( <span class="function"><span class="keyword">function</span>(<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 执行某些操作</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'index:'</span>+index+<span class="string">' item:'</span>+item);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><blockquote><p>数组对象是javascript中常用的类型，要熟悉数组的各种方法，需在平常开发中反复练习并理解记忆。</p></blockquote><p><strong>本文作者</strong>：Gong Jintao<br><strong>本文地址</strong>： <a href="http://blog.gongjintao.com/2019/06/30/javascript中的数组迭代方法总结/">http://blog.gongjintao.com/2019/06/30/javascript中的数组迭代方法总结/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ECMAScript-5中的数组迭代方法总结&quot;&gt;&lt;a href=&quot;#ECMAScript-5中的数组迭代方法总结&quot; class=&quot;headerlink&quot; title=&quot;ECMAScript 5中的数组迭代方法总结&quot;&gt;&lt;/a&gt;&lt;em&gt;ECMAScript 5&lt;/em&gt;中的数组迭代方法总结&lt;/h1&gt;&lt;p&gt;在 &lt;strong&gt;&lt;em&gt;ECMAscript 5&lt;/em&gt;&lt;/strong&gt; 中为数组定义了5个迭代方法，每个方法都接收两个参数：
    
    </summary>
    
      <category term="Web前端" scheme="http://blog.gongjintao.com/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://blog.gongjintao.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>CCF认证题库201712-2————游戏</title>
    <link href="http://blog.gongjintao.com/2019/06/30/CCF%E8%AE%A4%E8%AF%81%E9%A2%98%E5%BA%93201712-2%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E6%B8%B8%E6%88%8F/"/>
    <id>http://blog.gongjintao.com/2019/06/30/CCF认证题库201712-2————游戏/</id>
    <published>2019-06-30T01:28:11.244Z</published>
    <updated>2019-06-30T02:52:04.116Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><blockquote><p>　有n个小朋友围成一圈玩游戏，小朋友从1至n编号，2号小朋友坐在1号小朋友的顺时针方向，3号小朋友坐在2号小朋友的顺时针方向，……，1号小朋友坐在n号小朋友的顺时针方向。<br>游戏开始，从1号小朋友开始顺时针报数，接下来每个小朋友的报数是上一个小朋友报的数加1。若一个小朋友报的数为k的倍数或其末位数（即数的个位）为k，则该小朋友被淘汰出局，不再参加以后的报数。当游戏中只剩下一个小朋友时，该小朋友获胜。<a id="more"></a><br>例如，当n=5, k=2时：<br>　　1号小朋友报数1；<br>　　2号小朋友报数2淘汰；<br>　　3号小朋友报数3；<br>　　4号小朋友报数4淘汰；<br>　　5号小朋友报数5；<br>　　1号小朋友报数6淘汰；<br>　　3号小朋友报数7；<br>　　5号小朋友报数8淘汰；<br>　　3号小朋友获胜。<br>　　给定n和k，请问最后获胜的小朋友编号为多少？</p></blockquote><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><blockquote><p>　　输入一行，包括两个整数n和k，意义如题目所述。</p></blockquote><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><blockquote><p>　　输出一行，包含一个整数，表示获胜的小朋友编号。</p></blockquote><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>5 2</p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>3</p></blockquote><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>7 3</p></blockquote><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>4</p></blockquote><h3 id="数据规模和约定"><a href="#数据规模和约定" class="headerlink" title="数据规模和约定"></a>数据规模和约定</h3><blockquote><p>对于所有评测用例，1 ≤ n ≤ 1000，1 ≤ k ≤ 9。</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote><p>可以设置数组初始值为0，淘汰的便设置为1；<br>然后逐步循环；<br>设置判断条件，即数组中0的个数为1，表明只有一个未被淘汰，退出循环汰。</p></blockquote><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>,i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(a[i]==<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        sum++;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum==<span class="number">1</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> n,k,i=<span class="number">0</span>,data=<span class="number">1</span>;</span><br><span class="line">   <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">   <span class="keyword">int</span> arr[n];</span><br><span class="line">   <span class="built_in">memset</span>(arr,<span class="number">0</span>,n);</span><br><span class="line">   <span class="keyword">while</span>(check(arr,n))</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span>(arr[i]==<span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">       data++;</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="keyword">if</span>(data%k==<span class="number">0</span>||data%<span class="number">10</span>==k)</span><br><span class="line">     &#123;</span><br><span class="line">      arr[i]=<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">      i++;</span><br><span class="line">      <span class="keyword">if</span>(i==n)</span><br><span class="line">     &#123;</span><br><span class="line">       i=<span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">     <span class="keyword">if</span>(arr[i]==<span class="number">0</span>)&#123;</span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;i+<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声明：菜鸟拙见，大神勿喷"><a href="#声明：菜鸟拙见，大神勿喷" class="headerlink" title="(声明：菜鸟拙见，大神勿喷)"></a><font color="red" size="4" face="宋体">(声明：菜鸟拙见，大神勿喷)</font></h2><p><strong>本文作者</strong>：Gong Jintao<br><strong>本文地址</strong>： <a href="http://blog.gongjintao.com/2019/06/30/CCF认证题库201712-2————游戏/">http://blog.gongjintao.com/2019/06/30/CCF认证题库201712-2————游戏/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;　有n个小朋友围成一圈玩游戏，小朋友从1至n编号，2号小朋友坐在1号小朋友的顺时针方向，3号小朋友坐在2号小朋友的顺时针方向，……，1号小朋友坐在n号小朋友的顺时针方向。&lt;br&gt;游戏开始，从1号小朋友开始顺时针报数，接下来每个小朋友的报数是上一个小朋友报的数加1。若一个小朋友报的数为k的倍数或其末位数（即数的个位）为k，则该小朋友被淘汰出局，不再参加以后的报数。当游戏中只剩下一个小朋友时，该小朋友获胜。
    
    </summary>
    
      <category term="CCF试题库" scheme="http://blog.gongjintao.com/categories/CCF%E8%AF%95%E9%A2%98%E5%BA%93/"/>
    
    
      <category term="C/C++" scheme="http://blog.gongjintao.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>CCF认证题库201403-4————无线网络</title>
    <link href="http://blog.gongjintao.com/2019/03/03/CCF%E8%AE%A4%E8%AF%81%E9%A2%98%E5%BA%93201403-4%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C/"/>
    <id>http://blog.gongjintao.com/2019/03/03/CCF认证题库201403-4————无线网络/</id>
    <published>2019-03-03T11:27:46.000Z</published>
    <updated>2019-06-30T03:04:33.998Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><blockquote><p>　目前在一个很大的平面房间里有 n 个无线路由器，每个无线路由器都固定在某个点上。任何两个无线路由器只要距离不超过 r 就能互相建立网络连接。<br>　　除此以外，另有 m 个可以摆放无线路由器的位置。你可以在这些位置中选择至多 k 个增设新的路由器。<br>　　你的目标是使得第 1 个路由器和第 2 个路由器之间的网络连接经过尽量少的中转路由器。请问在最优方案下中转路由器的最少个数是多少？</p></blockquote><a id="more"></a><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><blockquote><p>　第一行包含四个正整数 n,m,k,r。(2 ≤ n ≤ 100,1 ≤ k ≤ m ≤ 100, 1 ≤ r ≤ 108)。<br>　　接下来 n 行，每行包含两个整数 xi 和 yi, 表示一个已经放置好的无线 路由器在 (xi, yi) 点处。输入数据保证第 1 和第 2 个路由器在仅有这 n 个路由器的情况下已经可以互相连接 (经过一系列的中转路由器)。<br>　　接下来 m 行，每行包含两个整数 xi 和 yi, 表示 (xi, yi) 点处可以增设 一个路由器。<br>　　输入中所有的坐标的绝对值不超过 108, 保证输入中的坐标各不相同。</p></blockquote><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><blockquote><p>输出只有一个数，即在指定的位置中增设 k 个路由器后，从第 1 个路 由器到第 2 个路由器最少经过的中转路由器的个数。</p></blockquote><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>5 3 1 3<br>0 0<br>5 5<br>0 3<br>0 5<br>3 5<br>3 3<br>4 4<br>3 0</p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>2</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote><p>此题属于求最短路，可以用 BFS (广度优先搜索) 快速方便解出，因为从顶点出发，层序遍历时，最优先到达终点的路径就是最短路径。需要注意的是，增设的路由器只有  k 个，所有对每个点进行遍历时，需要对 k 进行判断。但不是设一个全局的 cnt 来表示增设的路由器，应该是这条路径上的增设的路由器个数，因为如果设全局，即便不在该路径上，但只要遍历到了增设位置， cnt 就会加 1，使得判断失误。所以应该对每个顶点结果体设一个单独的 cnt，用来累计从起点一直到当前点所增设的路由器个数。</p></blockquote><h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">201</span>; <span class="comment">// 最大点数 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dot</span>&#123;</span></span><br><span class="line">ll x, y; <span class="comment">// 点的坐标</span></span><br><span class="line"><span class="keyword">int</span> level; <span class="comment">// 层次，用来计算路径长度</span></span><br><span class="line"><span class="keyword">bool</span> flag; <span class="comment">// 用于判断点是否是新增的点 </span></span><br><span class="line"><span class="keyword">int</span> cnt; <span class="comment">// 用于累计从起点到当前点增设的路由器的个数</span></span><br><span class="line">&#125;Dot[MAXN];</span><br><span class="line"><span class="comment">// 原来路由器个数，另有m个可以摆放路由器的位置，可以增设的路由器个数, 半径 </span></span><br><span class="line"><span class="keyword">int</span> n, m, k, r;</span><br><span class="line"><span class="comment">// 图 </span></span><br><span class="line"><span class="keyword">int</span> G[MAXN][MAXN];</span><br><span class="line"><span class="comment">// 是否被访问 </span></span><br><span class="line"><span class="keyword">bool</span> vis[MAXN] = &#123;<span class="literal">false</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断两点是否可达 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">inRange</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">pow</span>(Dot[u].x-Dot[v].x, <span class="number">2</span>) + <span class="built_in">pow</span>(Dot[u].y-Dot[v].y, <span class="number">2</span>) &lt;= <span class="built_in">pow</span>(r, <span class="number">2</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> st, <span class="keyword">int</span> ed)</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q; </span><br><span class="line">q.push(st);</span><br><span class="line">Dot[st].level = <span class="number">0</span>; <span class="comment">// 初始化顶点层次为 0 </span></span><br><span class="line">Dot[st].cnt = <span class="number">0</span>; <span class="comment">// 初始化访问顶点时，增设点数为 0 </span></span><br><span class="line">vis[st] = <span class="literal">true</span>; <span class="comment">// 设置被访问 </span></span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> u = q.front(); <span class="comment">//取出顶点</span></span><br><span class="line">q.pop(); <span class="comment">// 弹出顶点 </span></span><br><span class="line"><span class="keyword">if</span>(u == ed) <span class="keyword">return</span> Dot[u].level - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 总顶点数为 n + m </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= n + m; v++)&#123;</span><br><span class="line"><span class="comment">// 如果 顶点可达 &amp;&amp; 顶点未被访问 </span></span><br><span class="line"><span class="keyword">if</span>( G[u][v] == <span class="number">1</span> &amp;&amp; vis[v] == <span class="literal">false</span> &amp;&amp; Dot[u].cnt &lt;= k) &#123;</span><br><span class="line">vis[v] = <span class="literal">true</span>; </span><br><span class="line">                <span class="comment">// 对增设的路由进行判断，如果当前是增设的路由，则路径上的增设路由加 1，否则不变</span></span><br><span class="line">Dot[v].cnt = (Dot[v].flag) ? Dot[u].cnt+<span class="number">1</span> : Dot[u].cnt; </span><br><span class="line">q.push(v);</span><br><span class="line">Dot[v].level = Dot[u].level + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;r;</span><br><span class="line">    <span class="comment">// 设图的初值均为 0，表示不可达</span></span><br><span class="line">fill(G[<span class="number">0</span>], G[<span class="number">0</span>] + MAXN*MAXN, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n+m; i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;Dot[i].x&gt;&gt;Dot[i].y;</span><br><span class="line"><span class="keyword">if</span>(i &lt;= n) Dot[i].flag = <span class="literal">false</span>;<span class="comment">// 设置是否是增设位置</span></span><br><span class="line"><span class="keyword">else</span> Dot[i].flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= MAXN; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt;= MAXN; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(inRange(i, j)) G[i][j] = G[j][i] = <span class="number">1</span>;<span class="comment">// 如果在半径内，则设为 1 表示两点可达</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> step = BFS(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;step&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声明：菜鸟拙见，大神勿喷"><a href="#声明：菜鸟拙见，大神勿喷" class="headerlink" title="(声明：菜鸟拙见，大神勿喷)"></a><font color="red" size="4" face="宋体">(声明：菜鸟拙见，大神勿喷)</font></h2><p><strong>本文作者</strong>：Gong Jintao<br><strong>本文地址</strong>： <a href="http://blog.gongjintao.com/2019/03/03/CCF认证题库201403-4————无线网络/">http://blog.gongjintao.com/2019/03/03/CCF认证题库201403-4————无线网络/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;　目前在一个很大的平面房间里有 n 个无线路由器，每个无线路由器都固定在某个点上。任何两个无线路由器只要距离不超过 r 就能互相建立网络连接。&lt;br&gt;　　除此以外，另有 m 个可以摆放无线路由器的位置。你可以在这些位置中选择至多 k 个增设新的路由器。&lt;br&gt;　　你的目标是使得第 1 个路由器和第 2 个路由器之间的网络连接经过尽量少的中转路由器。请问在最优方案下中转路由器的最少个数是多少？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="CCF试题库" scheme="http://blog.gongjintao.com/categories/CCF%E8%AF%95%E9%A2%98%E5%BA%93/"/>
    
    
      <category term="C/C++" scheme="http://blog.gongjintao.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>CCF认证题库201312-4————有趣的数</title>
    <link href="http://blog.gongjintao.com/2019/03/01/CCF%E8%AE%A4%E8%AF%81%E9%A2%98%E5%BA%93201312-4%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E6%9C%89%E8%B6%A3%E7%9A%84%E6%95%B0/"/>
    <id>http://blog.gongjintao.com/2019/03/01/CCF认证题库201312-4————有趣的数/</id>
    <published>2019-03-01T02:27:46.000Z</published>
    <updated>2019-06-30T02:56:30.250Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><blockquote><p>我们把一个数称为有趣的，当且仅当：</p><ol><li><p><strong>它的数字只包含 0, 1, 2, 3</strong>，且这四个数字都出现过至少一次。</p></li><li><p>所有的 0 都出现在所有的 1 之前，而所有的 2 都出现在所有的 3 之前。</p></li><li><p>最高位数字不为 0。<br><a id="more"></a>因此，符合我们定义的最小的有趣的数是 2013。除此以外，4 位的有趣的数还有两个：2031 和 2301。<br>请计算恰好有 n 位的有趣的数的个数。由于答案可能非常大，只需要输出答案除以 1000000007 的余数。</p></li></ol></blockquote><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><blockquote><p>输入只有一行，包括恰好一个正整数 n (4 ≤ n ≤ 1000)。</p></blockquote><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><blockquote><p>输出只有一行，包括恰好 n 位的整数中有趣的数的个数除以 1000000007 的余数。</p></blockquote><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>4</p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>3</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote><p>此题采用动态规划的解法。</p><p>由题可知，1 和 3 分别出现在 0 和 2 之后，所以先考虑 0 或 2 的位置，又由于 0 不能摆在最高位，所以先考虑 2 的摆放。在不考虑所有数字都齐的情况下，则共有如下六种合法的状态：</p><ol><li>只含 2；</li><li>只含 2, 0;</li><li>只含 2, 3;</li><li>只含 2, 0, 1;</li><li>只含 2, 0, 3;</li><li>包含 4 种数字。</li></ol><p>用 <code>dp[i][j],j=1,2,3,4,5</code>，来表示长度为<code>i</code>的整数，满足上面的第<code>j</code>号状态的个数。</p><p>如<code>dp[3][1]=1</code>,即长度为 3， 只包含 2 的整数只有 1 个，即<code>222</code>；</p><p>如<code>dp[3][2]=2</code>，即长度为 3， 只包含 2 和 0 的整数有 2 个，因为所有的 2 必须在 3 前面，则只有三种情况，即<code>223,233</code>；</p><p>如<code>dp[4][3]=3</code>，即长度为4，只包含 2 和 3 的整数有 3 个，因为所有的 2 必须在 3 前面，则只有三种情况，即<code>2223,2233,2333</code>；</p><p>…</p><p>所以我们可以推出状态转移方程如下：</p><ol><li><code>dp[i][1]=1</code>;</li><li><code>dp[i][2]=2*dp[i-1][2]+dp[i-1][1]</code>，即位数为 i 且只含2、0的整数<ul><li>可以由位数为 i-1 且只含2、0的整数在末尾添加 0 或 2 所得；</li><li>可以由位数为 i-1 且只含 2 的整数在末尾添加 0 所得。</li></ul></li><li><code>dp[i][3]=dp[i-1][3]+dp[i-1][1]</code>，即位数为 i 且只含 2、3 的整数<ul><li>可以由位数为 i-1 且只含2、3的整数在末尾添加 3 可得；</li><li>可以由为数为 i-1 且只含 2 的整数在末尾添加 3 可得。</li></ul></li><li><code>dp[i][4]=2*dp[i-1][4]+dp[i-1][2]</code>，即位数为 i 且只含 2、0 和 1 的整数<ul><li>可以由位数为 i-1 且只含2、0 和 1 的整数在末尾添加 1 或 2 可得；</li><li>可以由为数为 i-1 且只含 2 或 0 的整数在末尾添加 1 可得。</li></ul></li><li><code>dp[i][5]=2*dp[i-1][5]+dp[i-1][2]+dp[i-1][3]</code>，即位数为 i 且只含 2、0 和 3 的整数<ul><li>可以由位数为 i-1 且只含2、0 和 3 的整数在末尾添加 2 或 3 可得；</li><li>可以由为数为 i-1 且只含 2 或 0 的整数在末尾添加 3 可得。</li><li>可以由为数为 i-1 且只含 2 或 3 的整数在末尾添加 0 可得。</li></ul></li><li><code>dp[i][6]=2*dp[i-1][6]+dp[i-1][4]+dp[i-1][5]</code>，即位数为 i 且包含 4 种数字的整数<ul><li>可以由位数为 i-1 且包含 4 种数字的整数在末尾添加 1 或 3 可得；</li><li>可以由为数为 i-1 且只含 2 、0 和  1 的整数在末尾添加 3 可得;</li><li>可以由为数为 i-1 且只含 2 、0 和  3 的整数在末尾添加 1 可得</li></ul></li></ol></blockquote><h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1002</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[maxn][<span class="number">6</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">dp[i][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">dp[i][<span class="number">2</span>]=(<span class="number">2</span>*dp[i<span class="number">-1</span>][<span class="number">2</span>] % mod + dp[i<span class="number">-1</span>][<span class="number">1</span>]) % mod;</span><br><span class="line">dp[i][<span class="number">3</span>]=(dp[i<span class="number">-1</span>][<span class="number">3</span>] + dp[i<span class="number">-1</span>][<span class="number">1</span>]) % mod;</span><br><span class="line">dp[i][<span class="number">4</span>]=(<span class="number">2</span>*dp[i<span class="number">-1</span>][<span class="number">4</span>] % mod + dp[i<span class="number">-1</span>][<span class="number">2</span>]) % mod;</span><br><span class="line">dp[i][<span class="number">5</span>]=((<span class="number">2</span>*dp[i<span class="number">-1</span>][<span class="number">5</span>] % mod + dp[i<span class="number">-1</span>][<span class="number">2</span>]) % mod + dp[i<span class="number">-1</span>][<span class="number">3</span>]) % mod;</span><br><span class="line">dp[i][<span class="number">6</span>]=((<span class="number">2</span>*dp[i<span class="number">-1</span>][<span class="number">6</span>] % mod + dp[i<span class="number">-1</span>][<span class="number">4</span>]) % mod + dp[i<span class="number">-1</span>][<span class="number">5</span>]) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[n][<span class="number">6</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声明：菜鸟拙见，大神勿喷"><a href="#声明：菜鸟拙见，大神勿喷" class="headerlink" title="(声明：菜鸟拙见，大神勿喷)"></a><font color="red" size="4" face="宋体">(声明：菜鸟拙见，大神勿喷)</font></h2><p><strong>本文作者</strong>：Gong Jintao<br><strong>本文地址</strong>： <a href="http://blog.gongjintao.com/2019/03/01/CCF认证题库201312-4————有趣的数/">http://blog.gongjintao.com/2019/03/01/CCF认证题库201312-4————有趣的数/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;我们把一个数称为有趣的，当且仅当：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;它的数字只包含 0, 1, 2, 3&lt;/strong&gt;，且这四个数字都出现过至少一次。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;所有的 0 都出现在所有的 1 之前，而所有的 2 都出现在所有的 3 之前。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;最高位数字不为 0。&lt;br&gt;
    
    </summary>
    
      <category term="CCF试题库" scheme="http://blog.gongjintao.com/categories/CCF%E8%AF%95%E9%A2%98%E5%BA%93/"/>
    
    
      <category term="C/C++" scheme="http://blog.gongjintao.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>MVC和MVVM模式特点和区别</title>
    <link href="http://blog.gongjintao.com/2019/01/19/MVC%E5%92%8CMVVM%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://blog.gongjintao.com/2019/01/19/MVC和MVVM的区别/</id>
    <published>2019-01-19T08:07:46.000Z</published>
    <updated>2019-06-30T03:04:15.335Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><blockquote><p>MVC 和 MVVM 都是常见的软件架构设计模式（Architectural Pattern），它通过分离关注点来改进代码的组织方式。它们的不同部分是 C(Controller)、VM(View-Model)，而相同的部分则是 MV(Model-View)。</p></blockquote><a id="more"></a><h1 id="2-MVC"><a href="#2-MVC" class="headerlink" title="2. MVC"></a>2. MVC</h1><blockquote><p><strong>M(Model)</strong>：<strong>数据保存层</strong>，用于存储业务的数据，一旦数据发生变化，Model 将发送到相关的 View，用户得到反馈</p><p><strong>V(View)</strong>：<strong>视图层</strong>，用于向用户展示数据，并传送指令到 Controller</p><p><strong>C(Controller)</strong>: <strong>业务逻辑层</strong>，用于完成用户请求的事件，然后通知 Model 改变数据</p></blockquote><p>图示如下：</p><p><img src="http://gjtblog-images.oss-cn-beijing.aliyuncs.com/MVC.jpg" alt="MVC"></p><blockquote><p>MVC 允许在不改变视图的情况下改变视图对用户输入的响应方式，用户对 View 的操作交给了 Controller 处理，在 Controller 中响应 View 的事件调用 Model 的接口对数据进行操作，一旦 Model 发生变化便通知相关视图进行更新。<font color="red">注意：MVC 中也可以直接通过 Controller 接受指令。</font></p></blockquote><h1 id="3-MVVM"><a href="#3-MVVM" class="headerlink" title="3. MVVM"></a>3. MVVM</h1><blockquote><p><strong>M(Model)</strong>：<strong>数据层</strong>，不同于 MVC 中的 Model , MVVM 中的 Model 层只关注数据本身，不关心任何行为。</p><p><strong>V(View)</strong>：<strong>视图层</strong>，用于向用户渲染展示数据</p><p><strong>VM(View-Model)</strong>: <strong>视图逻辑层</strong>，可以实现数据的双向绑定，当 Model 发生变化，ViewModel 就会自动更新；ViewModel 变化，Model 也会更新。View 的变动，自动反映在 ViewModel，而ViewModel 的更新，也会自动引起 View 的变化。</p></blockquote><p>图示如下：</p><p><img src="https://gjtblog-images.oss-cn-beijing.aliyuncs.com/MVVM.jpg" alt="MVVM"></p><blockquote><p>整体来看，比 MVC/MVP 精简了很多，不仅仅简化了业务与界面的依赖，还解决了数据频繁更新，不用操作DOM。因为在 MVVM 中，View 不知道 Model 的存在，ViewModel 和 Model 也察觉不到 View，这种低耦合模式可以使开发过程更加容易，提高应用的可重用性。</p></blockquote><p><strong>本文作者</strong>：Gong Jintao<br><strong>本文地址</strong>： <a href="http://blog.gongjintao.com/2019/01/19/MVC和MVVM的区别/">http://blog.gongjintao.com/2019/01/19/MVC和MVVM的区别/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.概述&quot;&gt;&lt;/a&gt;1.概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;MVC 和 MVVM 都是常见的软件架构设计模式（Architectural Pattern），它通过分离关注点来改进代码的组织方式。它们的不同部分是 C(Controller)、VM(View-Model)，而相同的部分则是 MV(Model-View)。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Web前端" scheme="http://blog.gongjintao.com/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>ECMAScript6学习笔记</title>
    <link href="http://blog.gongjintao.com/2019/01/06/ECMAScript-6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://blog.gongjintao.com/2019/01/06/ECMAScript-6学习笔记/</id>
    <published>2019-01-06T05:12:15.000Z</published>
    <updated>2019-07-01T04:28:49.937Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-变量"><a href="#1-变量" class="headerlink" title="1.变量"></a>1.变量</h3><blockquote><p><strong><code>var</code>声明变量的问题</strong></p><ol><li>可以重复声明变量</li><li>无法限制修改</li><li>没有块级作用域</li></ol><p><strong>ES6中新增了两个新的声明方法 <code>let</code>和<code>const</code></strong></p><ul><li><code>let</code>     不能重复声明，用于声明变量，有块级作用域</li><li><code>const</code>   不能重复声明，用于声明常量，有块级作用域</li></ul></blockquote><h3 id="2-函数"><a href="#2-函数" class="headerlink" title="2.函数"></a>2.函数<a id="more"></a></h3><h4 id="2-1-箭头函数：-gt"><a href="#2-1-箭头函数：-gt" class="headerlink" title="2.1 箭头函数：()=&gt;{}"></a>2.1 <strong>箭头函数</strong>：<code>()=&gt;{}</code></h4><p>&gt;</p><blockquote><ul><li><p>如果只有一个参数，<code>()</code>则可以省略</p></li><li><p>如果只有一个<code>return</code>,<code>{}</code>可以省略</p></li></ul></blockquote><h4 id="2-2-函数的参数"><a href="#2-2-函数的参数" class="headerlink" title="2.2 函数的参数"></a>2.2 <strong>函数的参数</strong></h4><h5 id="2-2-1-参数扩展-展开"><a href="#2-2-1-参数扩展-展开" class="headerlink" title="2.2.1 参数扩展/展开"></a>2.2.1 参数扩展/展开</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//收集参数</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">a,b,...args</span>)</span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">show(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);  <span class="comment">//...arg会接收剩余的参数(3,4,5)，但必须时最后一个位置</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//展开数组</span></span><br><span class="line"><span class="keyword">let</span> arr =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">...arr; <span class="comment">//相当于将arr展开:1,2,3</span></span><br></pre></td></tr></table></figure><h5 id="2-2-2-默认参数"><a href="#2-2-2-默认参数" class="headerlink" title="2.2.2 默认参数"></a>2.2.2 <strong>默认参数</strong></h5><blockquote><p>即参数一开始就有默认值</p></blockquote><h3 id="3-解构赋值"><a href="#3-解构赋值" class="headerlink" title="3.解构赋值"></a>3.解构赋值</h3><blockquote><ol><li><p>左右两边结构必须一样</p></li><li><p>右边必须是个有值的变量</p></li><li><p>生命和赋值不能分开（必须在一句语句中完成）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]; <span class="comment">//数组</span></span><br><span class="line"><span class="keyword">let</span> &#123;a,b,c&#125; = &#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">2</span>, <span class="attr">c</span>:<span class="number">8</span>&#125;;<span class="comment">//json</span></span><br><span class="line"><span class="keyword">var</span> &#123; bar, foo &#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;;<span class="comment">//对象</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h3 id="4-数组"><a href="#4-数组" class="headerlink" title="4.数组"></a>4.数组</h3><h4 id="1-map-一对一的映射"><a href="#1-map-一对一的映射" class="headerlink" title="1. map(一对一的映射)"></a>1. map(一对一的映射)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">12</span>,<span class="number">5</span>,<span class="number">8</span>];</span><br><span class="line"><span class="comment">/*let result = arr.map(function(item)&#123;</span></span><br><span class="line"><span class="comment">    return item*2;</span></span><br><span class="line"><span class="comment">&#125;)*/</span></span><br><span class="line"><span class="keyword">let</span> result = arr.map(<span class="function"><span class="params">item</span>=&gt;</span>item*<span class="number">2</span>);</span><br><span class="line">alert(result); <span class="comment">//输出24,10,16</span></span><br></pre></td></tr></table></figure><h4 id="2-reduce-一堆对一个"><a href="#2-reduce-一堆对一个" class="headerlink" title="2. reduce(一堆对一个)"></a>2. reduce(一堆对一个)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr =[<span class="number">12</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">33</span>];</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//求平均值</span></span><br><span class="line"> <span class="keyword">let</span> result = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">tmp,item,index</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(index!=arr.length<span class="number">-1</span>)&#123; <span class="comment">//不是最后一次运算</span></span><br><span class="line">         <span class="keyword">return</span> tmp+item;</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;<span class="comment">//最后一次运算</span></span><br><span class="line">        <span class="keyword">return</span> (tmp+item)/arr.length;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;)</span><br><span class="line"> alert(result);<span class="comment">//21</span></span><br></pre></td></tr></table></figure><h4 id="3-filter-过滤器"><a href="#3-filter-过滤器" class="headerlink" title="3. filter(过滤器)"></a>3. filter(过滤器)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">var</span> filterResult = arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (item &gt; <span class="number">2</span>);</span><br><span class="line">   &#125;);</span><br><span class="line">   </span><br><span class="line">   alert(filterResult);    <span class="comment">//[3,4,5,4,3]</span></span><br></pre></td></tr></table></figure><h4 id="4-forEach-迭代"><a href="#4-forEach-迭代" class="headerlink" title="4. forEach(迭代)"></a>4. forEach(迭代)</h4> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line"> arr.forEach( <span class="function"><span class="keyword">function</span>(<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">     <span class="comment">// 执行某些操作</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'index:'</span>+index+<span class="string">' item:'</span>+item);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="5-字符串"><a href="#5-字符串" class="headerlink" title="5.字符串"></a>5.字符串</h3><h4 id="5-1-两个新方法"><a href="#5-1-两个新方法" class="headerlink" title="5.1 两个新方法"></a>5.1 两个新方法</h4><blockquote><p><strong>startsWith(用于判断字符串的开头)</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str =<span class="string">'https://www.baidu.com'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(str.startsWith(<span class="string">'https://'</span>))&#123;</span><br><span class="line">    alert(<span class="string">"加密网址"</span>)；</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    alert(<span class="string">"普通网址"</span>)；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>endsWith(用于判断字符串的结尾)</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str=<span class="string">"name.txt"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(str.endsWith(<span class="string">'.txt'</span>))&#123;</span><br><span class="line">    alert(<span class="string">"文本文件"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(str.endsWith(<span class="string">'.jpg'</span>))&#123;</span><br><span class="line">    alert(<span class="string">"JPG图片"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    alert(<span class="string">"其他"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="5-2-模板字符串-用反单引号-来定义字符串"><a href="#5-2-模板字符串-用反单引号-来定义字符串" class="headerlink" title="5.2. 模板字符串(用反单引号`来定义字符串)"></a>5.2. 模板字符串(用反单引号`来定义字符串)</h4><blockquote><ul><li>可以直接将在字符串中解析变量，将变量写在 ${}中；</li><li>可以定义多行字符串</li></ul></blockquote><h3 id="6-面向对象"><a href="#6-面向对象" class="headerlink" title="6.面向对象"></a>6.面向对象</h3><blockquote><ol><li><p><strong>class关键字、构造器和类分开了</strong></p></li><li><p><strong>class里面可以直接加方法</strong></p></li></ol></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">       <span class="keyword">constructor</span>(id,name)&#123;</span><br><span class="line">           <span class="keyword">this</span>.id = id;</span><br><span class="line">           <span class="keyword">this</span>.name =name;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       showName()&#123;</span><br><span class="line">           alert(<span class="keyword">this</span>.name);</span><br><span class="line">       &#125;</span><br><span class="line">       showId()&#123;</span><br><span class="line">           alert(<span class="keyword">this</span>.id);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> u1 =<span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">'Tom'</span>);</span><br><span class="line">   u1.showName();</span><br><span class="line">   u1.showId();</span><br></pre></td></tr></table></figure><blockquote><p><strong>继承</strong></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VipUser</span> <span class="keyword">extends</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(id,name,level)&#123;</span><br><span class="line">        <span class="keyword">super</span>(id,name);</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    showLevel()&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.level);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v1 = <span class="keyword">new</span> VipUser(<span class="number">2</span>,<span class="string">'Jack'</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">v1.showName();</span><br><span class="line">v1.showId();</span><br><span class="line">v1.showLevel();</span><br></pre></td></tr></table></figure><h3 id="7-Promise"><a href="#7-Promise" class="headerlink" title="7.Promise"></a>7.Promise</h3><blockquote><p>所谓 Promise 对象，就是代表了未来某个将要发生的事件（通常是一个异步操作）。它的好处在于，有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="comment">/*异步操作成功*/</span>)&#123;</span><br><span class="line">       resolve(value);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        reject(error);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//操作成功</span></span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//操作失败</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p><strong>利用ajax请求数据</strong></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">                url: <span class="string">'data/abc.txt'</span>,</span></span><br><span class="line"><span class="javascript">                dataType:<span class="string">'json'</span>,</span></span><br><span class="line">                success(arr)&#123;</span><br><span class="line">                    resolve(arr);</span><br><span class="line">                &#125;,</span><br><span class="line">                error(err)&#123;</span><br><span class="line">                    reject(err);</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">        p.then(<span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">'成功了'</span>+arr); </span></span><br><span class="line"><span class="javascript">        &#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">'失败了'</span>+err);</span></span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>利用ajax请求多个数据</strong></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">createPromise</span>(<span class="params">url</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                $.ajax(&#123;</span></span><br><span class="line">                url,</span><br><span class="line"><span class="javascript">                dataType:<span class="string">'json'</span>,</span></span><br><span class="line">                success(arr)&#123;</span><br><span class="line">                    resolve(arr);</span><br><span class="line">                &#125;,</span><br><span class="line">                error(err)&#123;</span><br><span class="line">                    reject(err);</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;)</span><br><span class="line">         &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="javascript">         <span class="built_in">Promise</span>.all([</span></span><br><span class="line"><span class="javascript">             createPromise(<span class="string">'data/abc.txt'</span>),<span class="comment">//也可直接写一个$.ajax(&#123;&#125;),因为其返回的就是一个Promise对象</span></span></span><br><span class="line"><span class="javascript">             createPromise(<span class="string">'data/json.txt'</span>)</span></span><br><span class="line"><span class="javascript">         ]).then(<span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> [res1,res2] = arr;</span></span><br><span class="line">            alert(res1);</span><br><span class="line">            alert(res2);</span><br><span class="line"><span class="javascript">         &#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">             alert(<span class="string">'至少有一个失败了'</span>);</span></span><br><span class="line"><span class="javascript">             <span class="built_in">console</span>.log(err);</span></span><br><span class="line">         &#125;)</span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="8-Generator"><a href="#8-Generator" class="headerlink" title="8.Generator"></a>8.Generator</h3><blockquote><p>首先，可以把它理解成一个函数的内部状态的遍历器，每调用一次，函数的内部状态发生一次改变（可以理解成发生某些事件）。<br>在形式上，Generator 是一个普通函数，但是有两个特征。一是，function 命令与函数名之间有一个星号；二是，函数体内部使用 yield 语句，定义遍历器的每个成员，即不同的内部状态。</p><p><strong>通过yield传参</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">show</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="string">'a'</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> a = <span class="keyword">yield</span>; <span class="comment">//yield可以传参</span></span><br><span class="line">    </span><br><span class="line">            alert(<span class="string">'b'</span>);</span><br><span class="line">            alert(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> gen = show();</span><br><span class="line">        gen.next(<span class="number">12</span>); <span class="comment">//第一个next()传参并没有用，所以这里弹出'a'</span></span><br><span class="line">        gen.next(<span class="number">5</span>);  <span class="comment">//next()传参会传给yield，所以弹出'b'之后，弹出的是5</span></span><br></pre></td></tr></table></figure></p><p><strong>通过yield返回值</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">show</span>(<span class="params">a</span>)</span>&#123;            </span><br><span class="line">            alert(a);</span><br><span class="line">            <span class="keyword">let</span> tmp = a*<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">yield</span> tmp;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> b = tmp+<span class="number">1</span>; <span class="comment">//11</span></span><br><span class="line">            alert(b);</span><br><span class="line">    </span><br><span class="line">             <span class="keyword">yield</span> b;</span><br><span class="line">    </span><br><span class="line">           <span class="keyword">let</span>  c = b*<span class="number">3</span>;<span class="comment">//33</span></span><br><span class="line">            alert(c);</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> gen = show(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">let</span> res1 = gen.next(); <span class="comment">//&#123;value:10,done:false&#125;</span></span><br><span class="line">        <span class="built_in">console</span>.log(res1);</span><br><span class="line">        <span class="keyword">let</span> res2 = gen.next(); <span class="comment">//&#123;value:11，done:false&#125;</span></span><br><span class="line">        <span class="built_in">console</span>.log(res2);</span><br><span class="line">        <span class="keyword">let</span> res3 =gen.next(); <span class="comment">//&#123;value:33，done:true&#125;</span></span><br><span class="line">        <span class="built_in">console</span>.log(res3);</span><br><span class="line">    <span class="built_in">Promise</span>适合一次性读一堆数据的操作，Generator适合有逻辑性的读取的操作</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="9-模块编程"><a href="#9-模块编程" class="headerlink" title="9. 模块编程"></a>9. 模块编程</h3><blockquote><p>在 ES6 中导入模块，使用 </p><ul><li><p><code>import 模块名 from ‘模块标识符’</code></p></li><li><p><code>import &#39;模块标识符&#39;</code> //例如导入css文件</p></li></ul><p>在 ES6 中使用<code>export default</code> 和 <code>export</code> 向外暴露成员</p><font color="red">注意：</font><ul><li><p><code>export default</code>向外暴露的成员，可以用任意变量来接收</p></li><li><p>在一个模块中，<code>export default</code> 只允许向外暴露一次</p></li><li><p>在一个模块中，可以同时使用 <code>export default</code> 和 <code>export</code> 向外暴露成员</p></li><li><p>使用 <code>export</code> 向外暴露的成员，只能使用<code>{}</code>的形式来接受，这种形式叫做<strong>【按需导出】</strong></p></li><li><p>使用<code>export</code> 向外暴露的成员，必须严格按照导出时的名称来接收，可以用 <code>as</code>来起别名</p></li></ul><p>相比在 <strong>node.js</strong> 中是使用<code>var 名称 = require(&#39;模块表示符&#39;)</code>来导入</p><p><strong>ES6</strong>中是用 <code>module.exports</code>和<code>exports</code>来暴露成员</p></blockquote><p><strong>本文作者</strong>：Gong Jintao<br><strong>本文地址</strong>： <a href="http://blog.gongjintao.com/2019/01/06/ECMAScript-6学习笔记/">http://blog.gongjintao.com/2019/01/06/ECMAScript-6学习笔记/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-变量&quot;&gt;&lt;a href=&quot;#1-变量&quot; class=&quot;headerlink&quot; title=&quot;1.变量&quot;&gt;&lt;/a&gt;1.变量&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;var&lt;/code&gt;声明变量的问题&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以重复声明变量&lt;/li&gt;
&lt;li&gt;无法限制修改&lt;/li&gt;
&lt;li&gt;没有块级作用域&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;ES6中新增了两个新的声明方法 &lt;code&gt;let&lt;/code&gt;和&lt;code&gt;const&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;let&lt;/code&gt;     不能重复声明，用于声明变量，有块级作用域&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const&lt;/code&gt;   不能重复声明，用于声明常量，有块级作用域&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;2-函数&quot;&gt;&lt;a href=&quot;#2-函数&quot; class=&quot;headerlink&quot; title=&quot;2.函数&quot;&gt;&lt;/a&gt;2.函数
    
    </summary>
    
      <category term="Web前端" scheme="http://blog.gongjintao.com/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="ES6" scheme="http://blog.gongjintao.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>Vue中的生命周期</title>
    <link href="http://blog.gongjintao.com/2019/01/05/Vue%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://blog.gongjintao.com/2019/01/05/Vue中的生命周期/</id>
    <published>2019-01-05T14:25:24.000Z</published>
    <updated>2019-06-30T02:58:52.997Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-生命周期定义"><a href="#1-生命周期定义" class="headerlink" title="1.生命周期定义"></a>1.生命周期定义</h4><blockquote><p>生命周期是指：从Vue实例创建、运行、到销毁期间，总是伴随着各种事件的发生，这些事件统称为生命周期。</p></blockquote><a id="more"></a><h4 id="2-生命周期钩子"><a href="#2-生命周期钩子" class="headerlink" title="2.生命周期钩子"></a>2.生命周期钩子</h4><blockquote><p>生命周期钩子即生命周期事件的别名</p><p>生命周期钩子 = 生命周期函数 = 生命周期事件</p></blockquote><h4 id="3-生命周期函数分类"><a href="#3-生命周期函数分类" class="headerlink" title="3.生命周期函数分类"></a>3.生命周期函数分类</h4><blockquote><ol><li>创建期间的生命周期函数<ul><li><code>beforeCreate</code> ：实例刚在内存中被创建出来；此时，还没有初始化好 data 和 methods 属性</li><li><code>created</code> : 实例已经在内存中创建好，此时 data 和 methods 已经初始化好了</li><li><code>beforeMount</code>：表示模板已经在内存中编译完成，还没有渲染到页面中去</li><li><code>mounted</code>: 内存中的模板已经真实的挂载到浏览器中的页面中了，用户已经可以看到渲染好的页面了</li></ul></li><li>运行期间的生命周期函数<ul><li><code>beforeUpdate</code> : 状态更新前执行该函数，此时界面还没有被更新，但是数据已经被更新，因此还没有开始重新渲染DOM节点</li><li><code>updated</code>: 实例更新完毕之后调用该函数，页面和data数据已经保持同步了，都是最新的数据，界面已经被重新渲染好了</li></ul></li><li>销毁期间的生命周期函数<ul><li><code>beforeDestroy</code>: 实例销毁之前调用。Vue实例从运行阶段进入了销毁阶段，实例上的data 和 methods ，过滤器，指令等都处于可用阶段还没有被真正销毁</li><li><code>destroyed</code>:Vue实例已经被完全销毁，实例上的data 和 methods，过滤器，指令等都不可用</li></ul></li></ol></blockquote><h4 id="4-生命周期函数图"><a href="#4-生命周期函数图" class="headerlink" title="4.生命周期函数图"></a>4.生命周期函数图</h4><p><img src="http://gjtblog-images.oss-cn-beijing.aliyuncs.com/lifecycle.png" alt></p><p><strong>本文作者</strong>：Gong Jintao<br><strong>本文地址</strong>： <a href="http://blog.gongjintao.com/2019/01/05/Vue中的生命周期/">http://blog.gongjintao.com/2019/01/05/Vue中的生命周期/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-生命周期定义&quot;&gt;&lt;a href=&quot;#1-生命周期定义&quot; class=&quot;headerlink&quot; title=&quot;1.生命周期定义&quot;&gt;&lt;/a&gt;1.生命周期定义&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;生命周期是指：从Vue实例创建、运行、到销毁期间，总是伴随着各种事件的发生，这些事件统称为生命周期。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Web前端" scheme="http://blog.gongjintao.com/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Vue" scheme="http://blog.gongjintao.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>CCF认证题库201312-3————最大的矩形</title>
    <link href="http://blog.gongjintao.com/2018/09/11/CCF%E8%AE%A4%E8%AF%81%E9%A2%98%E5%BA%93201312-3%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/"/>
    <id>http://blog.gongjintao.com/2018/09/11/CCF认证题库201312-3————最大的矩形/</id>
    <published>2018-09-11T11:27:46.000Z</published>
    <updated>2019-06-30T02:56:24.434Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><blockquote><p>在横轴上放了 n 个相邻的矩形，每个矩形的宽度是 1，而第 i（1 ≤ i ≤ n）个矩形的高度是 hi。这 n 个矩形构成了一个直方图。例如，下图中六个矩形的高度就分别是 3, 1, 6, 5, 2, 3。<br><img src="http://118.190.20.162/RequireFile.do?fid=Fmhrjgtb" alt><br><a id="more"></a>请找出能放在给定直方图里面积最大的矩形，它的边要与坐标轴平行。对于上面给出的例子，最大矩形如下图所示的阴影部分，面积是 10。<br><img src="http://118.190.20.162/RequireFile.do?fid=gNe4DHhD" alt></p></blockquote><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><blockquote><p>第一行包含一个整数 n，即矩形的数量 (1 ≤ n ≤ 1000)。<br>　第二行包含 n 个整数 h1, h2, … , hn，相邻的数之间由空格分隔。(1 ≤ hi ≤ 10000)。hi 是第 i 个矩形的高度。</p></blockquote><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><blockquote><p>输出一行，包含一个整数，即给定直方图内的最大矩形的面积。</p></blockquote><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>6<br>3 1 6 5 2 3</p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>10</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote><p>用的是最直接的思路，所以并非很好的解法。<br>因为对于直方图中的每一个矩形，都会决定一个最大矩形。高即该矩形的高，宽则是左右两个方向比它高的最后一个之间的相隔个数。然后在从这些矩形中找出最大的即可。</p></blockquote><h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">1002</span>;</span><br><span class="line"><span class="keyword">int</span> h[MAXN] = &#123;<span class="number">0</span>&#125;,n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sarea</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> h[])</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> left = i ,right = i; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;<span class="comment">//往左遍历</span></span><br><span class="line"><span class="keyword">if</span>(h[j]&gt;=h[i])&#123;</span><br><span class="line">left = j;        <span class="comment">//若遍历的矩形比该矩形高，则继续，边界left等于当前矩形的序号</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">break</span>;  <span class="comment">//若比该矩形低，则结束</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j= i+<span class="number">1</span>;j&lt;=n+<span class="number">1</span>;j++)&#123; <span class="comment">//向右遍历，同上</span></span><br><span class="line"><span class="keyword">if</span>(h[j]&gt;=h[i])&#123;</span><br><span class="line">right = j;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> v = h[i]*(right-left == <span class="number">0</span>?<span class="number">1</span>:right-left+<span class="number">1</span>);<span class="comment">//若right==left表明最大的矩形只有该矩形一条。</span></span><br><span class="line"><span class="keyword">if</span>(v&gt;ans) ans = v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;h[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;Sarea(n,h);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声明：菜鸟拙见，大神勿喷"><a href="#声明：菜鸟拙见，大神勿喷" class="headerlink" title="(声明：菜鸟拙见，大神勿喷)"></a><font color="red" size="4" face="宋体">(声明：菜鸟拙见，大神勿喷)</font></h2><p><strong>本文作者</strong>：Gong Jintao<br><strong>本文地址</strong>： <a href="http://blog.gongjintao.com/2018/09/11/CCF认证题库201312-3————最大的矩形/">http://blog.gongjintao.com/2018/09/11/CCF认证题库201312-3————最大的矩形/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在横轴上放了 n 个相邻的矩形，每个矩形的宽度是 1，而第 i（1 ≤ i ≤ n）个矩形的高度是 hi。这 n 个矩形构成了一个直方图。例如，下图中六个矩形的高度就分别是 3, 1, 6, 5, 2, 3。&lt;br&gt;&lt;img src=&quot;http://118.190.20.162/RequireFile.do?fid=Fmhrjgtb&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
      <category term="CCF试题库" scheme="http://blog.gongjintao.com/categories/CCF%E8%AF%95%E9%A2%98%E5%BA%93/"/>
    
    
      <category term="C/C++" scheme="http://blog.gongjintao.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>CCF认证题库201703-3————Markdown</title>
    <link href="http://blog.gongjintao.com/2018/09/05/CCF%E8%AE%A4%E8%AF%81%E9%A2%98%E5%BA%93201703-3%E2%80%94%E2%80%94%E2%80%94%E2%80%94Markdown/"/>
    <id>http://blog.gongjintao.com/2018/09/05/CCF认证题库201703-3————Markdown/</id>
    <published>2018-09-05T07:51:51.000Z</published>
    <updated>2019-06-30T02:54:03.518Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><blockquote><p>Markdown 是一种很流行的轻量级标记语言（lightweight markup language），广泛用于撰写带格式的文档。例如以下这段文本就是用 Markdown 的语法写成的：<br><img src="http://118.190.20.162/RequireFile.do?fid=Yy7nr9Yt" alt="01"><br><a id="more"></a>这些用 Markdown 写成的文本，尽管本身是纯文本格式，然而读者可以很容易地看出它的文档结构。同时，还有很多工具可以自动把 Markdown 文本转换成 HTML 甚至 Word、PDF 等格式，取得更好的排版效果。例如上面这段文本通过转化得到的 HTML 代码如下所示：<br><img src="http://118.190.20.162/RequireFile.do?fid=247472gj" alt="02"><br>本题要求由你来编写一个 Markdown 的转换工具，完成 Markdown 文本到 HTML 代码的转换工作。简化起见，本题定义的 Markdown 语法规则和转换规则描述如下：<br>　　●区块：区块是文档的顶级结构。本题的 Markdown 语法有 3 种区块格式。在输入中，相邻两个区块之间用一个或多个空行分隔。输出时删除所有分隔区块的空行。<br>　　○段落：一般情况下，连续多行输入构成一个段落。段落的转换规则是在段落的第一行行首插入 <code>&lt;p&gt;</code>，在最后一行行末插入 <code>&lt;/p&gt;</code>。<br>　　○标题：每个标题区块只有一行，由若干个 <code>#</code> 开头，接着一个或多个空格，然后是标题内容，直到行末。<code>#</code> 的个数决定了标题的等级。转换时，<code># Heading</code> 转换为 <code>&lt;h1&gt;Heading&lt;/h1&gt;</code>，<code>## Heading</code> 转换为 <code>&lt;h2&gt;Heading&lt;/h2&gt;</code>，以此类推。标题等级最深为 6。<br>　　○无序列表：无序列表由若干行组成，每行由 <code>*</code> 开头，接着一个或多个空格，然后是列表项目的文字，直到行末。转换时，在最开始插入一行 <code>&lt;ul&gt;</code>，最后插入一行 <code>&lt;/ul&gt;</code>；对于每行，<code>* Item</code> 转换为 <code>&lt;li&gt;Item&lt;/li&gt;</code>。本题中的无序列表只有一层，不会出现缩进的情况。<br>　　●行内：对于区块中的内容，有以下两种行内结构。<br>　　○强调：<code>_Text_</code> 转换为 <code>&lt;em&gt;Text&lt;/em&gt;</code>。强调不会出现嵌套，每行中 <code>_</code> 的个数一定是偶数，且不会连续相邻。注意 <code>_Text_</code> 的前后不一定是空格字符。<br>　　○超级链接：<code>[Text](Link)</code> 转换为 <code>&lt;a href=&quot;Link&quot;&gt;Text&lt;/a&gt;</code>。超级链接和强调可以相互嵌套，但每种格式不会超过一层。</p></blockquote><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><blockquote><p>　　输入由若干行组成，表示一个用本题规定的 Markdown 语法撰写的文档。</p></blockquote><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><blockquote><p>　　输出由若干行组成，表示输入的 Markdown 文档转换成产生的 HTML 代码。</p></blockquote><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p># Hello</p><p>Hello, world!</p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p><code>&lt;h1&gt;Hello&lt;/h1&gt;</code><br><code>&lt;p&gt;Hello, world!&lt;/p&gt;</code></p></blockquote><h3 id="评测用例规模与约定"><a href="#评测用例规模与约定" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h3><blockquote><p>　　本题的测试点满足以下条件：<br>　　●本题每个测试点的输入数据所包含的行数都不超过100，每行字符的个数（包括行末换行符）都不超过100。<br>　　●除了换行符之外，所有字符都是 ASCII 码 32 至 126 的可打印字符。<br>　　●每行行首和行末都不会出现空格字符。<br>　　●输入数据除了 Markdown 语法所需，内容中不会出现 <code>#</code>、<code>*</code>、<code>_</code>、<code>[</code>、<code>]</code>、<code>(</code>、<code>)</code>、<code>&lt;</code>、<code>&gt;</code>、<code>&amp;</code> 这些字符。<br>　　●所有测试点均符合题目所规定的 Markdown 语法，你的程序不需要考虑语法错误的情况。</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote><p>分两个部分进行处理，即区块和行列元素；然后建立vector容器html，存入处理后的每一行字符串。<br>1.首先处理行列元素，即处理强调符号和超级链接，分别构建deal1()和deal2()两个处理函数。注意的是这两个可以相互嵌套，所以需要将两个函数嵌套处理，所以需要提前申明。<br>2.区块分为三种，即段落，标题和无序列表。关键是段落和无序列表处理；当区块结束和文件末尾时，如果该区块是段落，则要在上一行末尾添加”&lt;/p&gt;”;如果该区块是无序列表，则要添加一个”&lt;/ul&gt;”。</p></blockquote><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">deal1</span><span class="params">(<span class="built_in">string</span> line)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">deal2</span><span class="params">(<span class="built_in">string</span> line)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//强调处理 </span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">deal1</span><span class="params">(<span class="built_in">string</span> line)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pos;</span><br><span class="line"><span class="keyword">while</span>((pos = line.find(<span class="string">"_"</span>))!=<span class="built_in">string</span>::npos)</span><br><span class="line">&#123;</span><br><span class="line">line.replace(pos,<span class="number">1</span>,<span class="string">"&lt;em&gt;"</span>);</span><br><span class="line">line.replace(line.find(<span class="string">"_"</span>,pos),<span class="number">1</span>,<span class="string">"&lt;/em&gt;"</span>);</span><br><span class="line">line = deal2(line);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> line;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//超链接处理 </span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">deal2</span><span class="params">(<span class="built_in">string</span> line)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pos;</span><br><span class="line"><span class="keyword">while</span>((pos = line.find(<span class="string">"["</span>))!=<span class="built_in">string</span>::npos)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> posR = line.find(<span class="string">"]"</span>,pos);</span><br><span class="line"><span class="keyword">int</span> posL1 = line.find(<span class="string">"("</span>,posR);</span><br><span class="line"><span class="keyword">int</span> posR1 = line.find(<span class="string">")"</span>,posL1);</span><br><span class="line"><span class="built_in">string</span> text = line.substr(pos+<span class="number">1</span>,posR-pos<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">string</span> link = line.substr(posL1+<span class="number">1</span>,posR1-posL1<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">string</span> a = <span class="string">"&lt;a href=\""</span>+link+<span class="string">"\"&gt;"</span>+text+<span class="string">"&lt;/a&gt;"</span>;</span><br><span class="line">line.replace(pos,posR1-pos+<span class="number">1</span>,a);</span><br><span class="line">line = deal1(line);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> line; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">string</span> line;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;  html;</span><br><span class="line"><span class="keyword">int</span> pSum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> paraFlag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> uSum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> listFlag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span>(getline(<span class="built_in">cin</span>,line))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(line.size()!=<span class="number">0</span>)<span class="comment">//如果字符串长度不为0 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> pos, sumH = <span class="number">0</span>; </span><br><span class="line"><span class="comment">//判断是否是段落 </span></span><br><span class="line"><span class="keyword">if</span>(*(line.begin())!=<span class="string">'#'</span> &amp;&amp; *(line.begin())!=<span class="string">'*'</span>)</span><br><span class="line">&#123;</span><br><span class="line">pSum++;</span><br><span class="line">paraFlag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(paraFlag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(pSum==<span class="number">1</span>) line = <span class="string">"&lt;p&gt;"</span>+line;<span class="comment">//是否是段落开头  </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否是标题 </span></span><br><span class="line"><span class="keyword">while</span>((pos = line.find(<span class="string">"#"</span>))!=<span class="built_in">string</span>::npos)</span><br><span class="line">&#123;</span><br><span class="line">sumH++;<span class="comment">//标题级别</span></span><br><span class="line">line.erase(pos,<span class="number">1</span>);</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"> <span class="comment">//判断是否是无序列表 </span></span><br><span class="line"><span class="keyword">while</span>((pos=line.find(<span class="string">"*"</span>))!=<span class="built_in">string</span>::npos) </span><br><span class="line">&#123;</span><br><span class="line">uSum++; </span><br><span class="line">listFlag = <span class="literal">true</span>;</span><br><span class="line">line.erase(pos,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将"#”和"*"去掉后，再去掉开头的多余空格 </span></span><br><span class="line"><span class="keyword">while</span>(*line.begin()==<span class="string">' '</span>)</span><br><span class="line">&#123;</span><br><span class="line">line.erase(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(listFlag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(uSum==<span class="number">1</span>) html.push_back(<span class="string">"&lt;ul&gt;"</span>); </span><br><span class="line">line = <span class="string">"&lt;li&gt;"</span> + line + <span class="string">"&lt;/li&gt;"</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理强调和超链接 </span></span><br><span class="line">line = deal1(line);</span><br><span class="line">line = deal2(line);</span><br><span class="line"><span class="keyword">if</span>(sumH)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> tmp[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(tmp,<span class="string">"%d"</span>,sumH);</span><br><span class="line"><span class="built_in">string</span> s= tmp;</span><br><span class="line">line = <span class="string">"&lt;h"</span>+s+<span class="string">"&gt;"</span>+line+<span class="string">"&lt;/h"</span>+s+<span class="string">"&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line">html.push_back(line);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//如果录入的是空行，说明是区块结束 </span></span><br><span class="line"><span class="keyword">if</span>(uSum &gt;= <span class="number">1</span>)<span class="comment">//如果区块结束，无序标签数目大于等于1，则在后面添加&lt;/ul&gt;,同时标志和计数器重置 </span></span><br><span class="line">&#123;</span><br><span class="line">html.push_back(<span class="string">"&lt;/ul&gt;"</span>); </span><br><span class="line">uSum = <span class="number">0</span>;</span><br><span class="line">listFlag =<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果区块结束，段落数目大于等于1，则在前一行后面添加&lt;/p&gt;,同时标志和计数器重置</span></span><br><span class="line"><span class="keyword">if</span>(pSum&gt;=<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::iterator it = html.end()<span class="number">-1</span>;</span><br><span class="line">*it =*it+<span class="string">"&lt;/p&gt;"</span>; </span><br><span class="line">pSum =  <span class="number">0</span>;</span><br><span class="line">paraFlag = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">line.clear();<span class="comment">//清空容器 </span></span><br><span class="line"> &#125; </span><br><span class="line"><span class="comment">//文件尾 也要判断 </span></span><br><span class="line"><span class="keyword">if</span>(uSum &gt;= <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">html.push_back(<span class="string">"&lt;/ul&gt;"</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(pSum&gt;=<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::iterator it = html.end()<span class="number">-1</span>;</span><br><span class="line"><span class="built_in">string</span> tmp = *it+<span class="string">"&lt;/p&gt;"</span>;</span><br><span class="line">*it = tmp; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;html.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;html[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解题总结"><a href="#解题总结" class="headerlink" title="解题总结"></a>解题总结</h3><blockquote><p>要熟悉string的各个内置函数的常见用法：<br>line.find(str,pos):表示从字符串line的pos位置往后面查找字串str，如果有则返回首次出现的位置，若不存在则返回<code>string::npos</code>;<br>line.substr(pos,len):表示从line的pos位置截取长度为len的字串，包括pos位置的值；<br>line.replace(pos,len,str):表示用字符串str替换line的pos位置往后的len长度的字串；<br>line.erase(pos_0,pos_n)：表示移除line中从位置pos_0到pos_n中间的字符串，包括pos_0,不包括pos_n，即[pos_0,pos_n);</p></blockquote><h2 id="声明：菜鸟拙见，大神勿喷"><a href="#声明：菜鸟拙见，大神勿喷" class="headerlink" title="(声明：菜鸟拙见，大神勿喷)"></a><font color="red" size="4" face="宋体">(声明：菜鸟拙见，大神勿喷)</font></h2><p><strong>本文作者</strong>：Gong Jintao<br><strong>本文地址</strong>： <a href="http://blog.gongjintao.com/2018/09/05/CCF认证题库201703-3————Markdown/">http://blog.gongjintao.com/2018/09/05/CCF认证题库201703-3————Markdown/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Markdown 是一种很流行的轻量级标记语言（lightweight markup language），广泛用于撰写带格式的文档。例如以下这段文本就是用 Markdown 的语法写成的：&lt;br&gt;&lt;img src=&quot;http://118.190.20.162/RequireFile.do?fid=Yy7nr9Yt&quot; alt=&quot;01&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="CCF试题库" scheme="http://blog.gongjintao.com/categories/CCF%E8%AF%95%E9%A2%98%E5%BA%93/"/>
    
    
      <category term="C/C++" scheme="http://blog.gongjintao.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>CCF认证题库201612-3————权限查询</title>
    <link href="http://blog.gongjintao.com/2018/09/03/CCF%E8%AE%A4%E8%AF%81%E9%A2%98%E5%BA%93201612-3%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E6%9D%83%E9%99%90%E6%9F%A5%E8%AF%A2/"/>
    <id>http://blog.gongjintao.com/2018/09/03/CCF认证题库201612-3————权限查询/</id>
    <published>2018-09-03T13:23:39.000Z</published>
    <updated>2019-06-30T02:53:35.441Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><blockquote><p>　　授权 (authorization) 是各类业务系统不可缺少的组成部分，系统用户通过授权机制获得系统中各个模块的操作权限。<br>　　本题中的授权机制是这样设计的：每位用户具有若干角色，每种角色具有若干权限。例如，用户 david 具有 manager 角色，manager 角色有 crm:2 权限，则用户 david 具有 crm:2 权限，也就是 crm 类权限的第 2 等级的权限。<a id="more"></a><br>　　具体地，用户名和角色名称都是由小写字母组成的字符串，长度不超过 32。权限分为分等级权限和不分等级权限两大类。分等级权限由权限类名和权限等级构成，中间用冒号“:”分隔。其中权限类名也是由小写字母组成的字符串，长度不超过 32。权限等级是一位数字，从 0 到 9，数字越大表示权限等级越高。系统规定如果用户具有某类某一等级的权限，那么他也将自动具有该类更低等级的权限。例如在上面的例子中，除 crm:2 外，用户 david 也具有 crm:1 和 crm:0 权限。不分等级权限在描述权限时只有权限类名，没有权限等级（也没有用于分隔的冒号）。<br>　　给出系统中用户、角色和权限的描述信息，你的程序需要回答多个关于用户和权限的查询。查询可分为以下几类：</p><ul><li>不分等级权限的查询：如果权限本身是不分等级的，则查询时不指定等级，返回是否具有该权限；</li><li>分等级权限的带等级查询：如果权限本身分等级，查询也带等级，则返回是否具有该类的该等级权限；</li><li>分等级权限的不带等级查询：如果权限本身分等级，查询不带等级，则返回具有该类权限的等级；如果不具有该类的任何等级权限，则返回“否”。</li></ul></blockquote><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><blockquote><p>　　输入第一行是一个正整数 p，表示不同的权限类别的数量。紧接着的 p 行被称为 P 段，每行一个字符串，描述各个权限。对于分等级权限，格式为 <category>:<level>，其中 <category> 是权限类名，<level> 是该类权限的最高等级。对于不分等级权限，字符串只包含权限类名。<br>　　接下来一行是一个正整数 r，表示不同的角色数量。紧接着的 r 行被称为 R 段，每行描述一种角色，格式为<br>　　<code>&lt;role&gt; &lt;s&gt; &lt;privilege 1&gt; &lt;privilege 2&gt; ... &lt;privilege s&gt;</code><br>　　其中<code>&lt;role&gt;</code> 是角色名称，<code>&lt;s&gt;</code> 表示该角色具有多少种权限。后面 <code>&lt;s&gt;</code> 个字符串描述该角色具有的权限，格式同 P 段。<br>　　接下来一行是一个正整数 u，表示用户数量。紧接着的 u 行被称为 U 段，每行描述一个用户，格式为<br>　　<code>&lt;user&gt; &lt;t&gt; &lt;role 1&gt; &lt;role 2&gt; ... &lt;role t&gt;</code><br>　　其中 <code>&lt;user&gt;</code> 是用户名，<code>&lt;t&gt;</code>表示该用户具有多少种角色。后面 <code>&lt;t&gt;</code> 个字符串描述该用户具有的角色。<br>　　接下来一行是一个正整数 q，表示权限查询的数量。紧接着的 q 行被称为 Q 段，每行描述一个授权查询，格式为 <code>&lt;user&gt; &lt;privilege&gt;</code>，表示查询用户 <code>&lt;user&gt;</code> 是否具有 <code>&lt;privilege&gt;</code> 权限。如果查询的权限是分等级权限，则查询中的 <privilege> 可指定等级，表示查询该用户是否具有该等级的权限；也可以不指定等级，表示查询该用户具有该权限的等级。对于不分等级权限，只能查询该用户是否具有该权限，查询中不能指定等级。<br>输出格式<br>　　输出共 q 行，每行为 false、true，或者一个数字。false 表示相应的用户不具有相应的权限，true 表示相应的用户具有相应的权限。对于分等级权限的不带等级查询，如果具有权限，则结果是一个数字，表示该用户具有该权限的（最高）等级。如果用户不存在，或者查询的权限没有定义，则应该返回 false。</privilege></level></category></level></category></p></blockquote><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>3<br>crm:2<br>git:3<br>game<br>4<br>hr 1 crm:2<br>it 3 crm:1 git:1 game<br>dev 2 git:3 game<br>qa 1 git:2<br>3<br>alice 1 hr<br>bob 2 it qa<br>charlie 1 dev<br>9<br>alice game<br>alice crm:2<br>alice git:0<br>bob git<br>bob poweroff<br>charlie game<br>charlie crm<br>charlie git:3<br>malice game</p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>false<br>true<br>false<br>2<br>false<br>true<br>false<br>true<br>false</p></blockquote><h3 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h3><blockquote><p>　　样例输入描述的场景中，各个用户实际的权限如下：<br>　　* 用户 alice 具有 crm:2 权限<br>　　* 用户 bob 具有 crm:1、git:2 和 game 权限<br>　　* 用户 charlie 具有 git:3 和 game 权限<br>　　* 用户 malice 未描述，因此不具有任何权限        </p></blockquote><h3 id="评测用例规模与约定"><a href="#评测用例规模与约定" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h3><blockquote><p>　　评测用例规模：<br>　　* 1 ≤ p, r, u ≤ 100<br>　　* 1 ≤ q ≤ 10 000<br>　　* 每个用户具有的角色数不超过 10，每种角色具有的权限种类不超过 10<br>　　约定：<br>　　* 输入保证合法性，包括：<br>　　1) 角色对应的权限列表（R 段）中的权限都是之前（P 段）出现过的，权限可以重复出现，如果带等级的权限重复出现，以等级最高的为准<br>　　2) 用户对应的角色列表（U 段）中的角色都是之前（R 段）出现过的，如果多个角色都具有某一分等级权限，以等级最高的为准<br>　　3) 查询（Q 段）中的用户名和权限类名不保证在之前（U 段和 P 段）出现过<br>　　* 前 20% 的评测用例只有一种角色<br>　　* 前 50% 的评测用例权限都是不分等级的，查询也都不带等级        </p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote><p><strong>首先</strong>构建权限的处理函数，即对权限字符串处理，返回<code>pair&lt;string,int&gt;</code> 的数据，第一个字段为权限名，第二个字段为等级，不分等级的权限则等级为-1；<br><strong>然后</strong>建立各项权限表：<br>1.用map先建立关于权限的权限表Prom；键值为权限名，对应的值为权限的等级；<br>2.用二维map建立关于角色与权限的角色权限表roleProm；键值为角色名，对应的值为该角色用的权限表。注意的是权限名可能重复出现，所以要判断在对应的权限表中是否已经存在该权限，且等级是否高于存在的权限的等级；<br>3.用二维map建立用户与权限的用户权限表，先录入的是该用户所对应的角色，然后将该角色的权限表的每一项录入用户的权限表中。注意权限名会重复出现，所以要录入该权限的最高等级。<br><strong>接下来</strong>进行查询：<br>1.判断是否在用户表和权限表中都存在，存在则继续，否则返回false；<br>2.查询对应的用户权限表中是否存在该权限，存在则继续，否则返回false；<br>3.查询对应的用户权限表中该权限是否是分等级的，是则继续，否则返回true;<br>4.若查询的权限是分等级的但没有给出等级号，则返回用户权限表中该权限的等级；若查询的等级号高于用户权限表中该权限的等级则返回false，否则返回true。</p></blockquote><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; prom;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; Prom; <span class="comment">//权限表 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt; <span class="built_in">string</span>, <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; &gt; roleProm; <span class="comment">//角色所拥有的权限</span></span><br><span class="line"><span class="comment">//string roles[maxn]; //角色名</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt; <span class="built_in">string</span>, <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; &gt; userProm; <span class="comment">//用户所拥有的权限</span></span><br><span class="line"><span class="comment">//string users[maxn]; //用户名 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//处理字符串，返回权限名和权限等级，不分等级，则等级为-1 </span></span><br><span class="line"><span class="function">prom <span class="title">dealProm</span><span class="params">(<span class="built_in">string</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> auth=<span class="string">""</span>;</span><br><span class="line"><span class="keyword">int</span> deg = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span>(p[i]!=<span class="string">':'</span> &amp;&amp; i&lt;p.size())&#123;</span><br><span class="line">auth += p[i];</span><br><span class="line">i++;</span><br><span class="line">&#125; </span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">while</span>(i&lt;p.size())&#123;</span><br><span class="line">deg = deg*<span class="number">10</span>+(p[i]-<span class="string">'0'</span>);</span><br><span class="line">i++;</span><br><span class="line">flag =<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!flag) deg = <span class="number">-1</span>;<span class="comment">//表明是不分等级的 </span></span><br><span class="line"><span class="function">prom <span class="title">tmp</span><span class="params">(auth,deg)</span></span>;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p,r,u,q;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;p;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;p;i++)&#123;</span><br><span class="line"><span class="built_in">string</span> authr;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;authr;</span><br><span class="line">prom tmp = dealProm(authr);</span><br><span class="line">Prom[tmp.first] = tmp.second; <span class="comment">//建立权限表 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;r;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;r;i++)&#123;</span><br><span class="line"><span class="built_in">string</span> role;</span><br><span class="line"><span class="keyword">int</span> s;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;role&gt;&gt;s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;s;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span> tmpor;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;tmpor;</span><br><span class="line">prom tmp = dealProm(tmpor);</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;::iterator it = roleProm[role].find(tmp.first);</span><br><span class="line"><span class="keyword">if</span>(it != roleProm[role].end())&#123;<span class="comment">//是否在角色权限表中存在 </span></span><br><span class="line"><span class="keyword">if</span>(it-&gt;second &lt; tmp.second)&#123;<span class="comment">//是否已存在的等级低于录入的权限的等级 </span></span><br><span class="line">it-&gt;second = tmp.second;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">roleProm[role][tmp.first] = tmp.second;  <span class="comment">//没有则直接 录入</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;u;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;u;i++)&#123;</span><br><span class="line"><span class="built_in">string</span> uName;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;uName&gt;&gt;t;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span> tName;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;tName;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;::iterator it = roleProm[tName].begin();</span><br><span class="line"><span class="keyword">for</span>(;it!=roleProm[tName].end();it++)<span class="comment">//将角色的权限写入用户的权限表中 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;::iterator it2 = userProm[uName].find(it-&gt;first);</span><br><span class="line"><span class="keyword">if</span>(it2!=userProm[uName].end())&#123;<span class="comment">//如果已经存在该权限 </span></span><br><span class="line"><span class="keyword">if</span>(it2-&gt;second &lt; it-&gt;second)&#123;<span class="comment">//判断等级是否高于存在的权限的的等级 </span></span><br><span class="line">it2-&gt;second = it-&gt;second;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">userProm[uName][it-&gt;first] = it-&gt;second;<span class="comment">//不存在则写入该权限项 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;q;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;q;i++)&#123;</span><br><span class="line"><span class="built_in">string</span> userName,selProm; </span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;userName&gt;&gt;selProm;</span><br><span class="line">prom tmp = dealProm(selProm);</span><br><span class="line"><span class="built_in">string</span> cate= tmp.first;</span><br><span class="line"><span class="keyword">int</span> degree = tmp.second;</span><br><span class="line"><span class="keyword">if</span>(Prom.find(cate)==Prom.end() || userProm.find(userName)==userProm.end() )&#123; <span class="comment">//如果权限表中没有该权限或着用户表中没有该用户 </span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"false"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(userProm[userName].find(cate)==userProm[userName].end())&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"false"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(userProm[userName][cate] != <span class="number">-1</span> )&#123;</span><br><span class="line"><span class="keyword">if</span>(degree == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;userProm[userName][cate]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">userProm[userName][cate] &lt; degree?<span class="built_in">cout</span>&lt;&lt;<span class="string">"false"</span>&lt;&lt;<span class="built_in">endl</span>:<span class="built_in">cout</span>&lt;&lt;<span class="string">"true"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"true"</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声明：菜鸟拙见，大神勿喷"><a href="#声明：菜鸟拙见，大神勿喷" class="headerlink" title="(声明：菜鸟拙见，大神勿喷)"></a><font color="red" size="4" face="宋体">(声明：菜鸟拙见，大神勿喷)</font></h2><p><strong>本文作者</strong>：Gong Jintao<br><strong>本文地址</strong>： <a href="http://blog.gongjintao.com/2018/09/03/CCF认证题库201612-3————权限查询/">http://blog.gongjintao.com/2018/09/03/CCF认证题库201612-3————权限查询/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;　　授权 (authorization) 是各类业务系统不可缺少的组成部分，系统用户通过授权机制获得系统中各个模块的操作权限。&lt;br&gt;　　本题中的授权机制是这样设计的：每位用户具有若干角色，每种角色具有若干权限。例如，用户 david 具有 manager 角色，manager 角色有 crm:2 权限，则用户 david 具有 crm:2 权限，也就是 crm 类权限的第 2 等级的权限。
    
    </summary>
    
      <category term="CCF试题库" scheme="http://blog.gongjintao.com/categories/CCF%E8%AF%95%E9%A2%98%E5%BA%93/"/>
    
    
      <category term="C/C++" scheme="http://blog.gongjintao.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>CCF试题库201312-2————ISBN号码</title>
    <link href="http://blog.gongjintao.com/2018/08/12/CCF%E8%AF%95%E9%A2%98%E5%BA%93201312-2%E2%80%94%E2%80%94%E2%80%94%E2%80%94ISBN%E5%8F%B7%E7%A0%81/"/>
    <id>http://blog.gongjintao.com/2018/08/12/CCF试题库201312-2————ISBN号码/</id>
    <published>2018-08-12T11:24:33.000Z</published>
    <updated>2019-06-30T02:54:35.355Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><blockquote><p>　每一本正式出版的图书都有一个 ISBN 号码与之对应，ISBN 码包括 9 位数字、1 位识别码和 3 位分隔符，其规定格式如 “x-xxx-xxxxx-x”，其中符号“-” 是分隔符（键盘上的减号），最后一位是识别码，例如 0-670-82162-4 就是一个标准的 ISBN 码。ISBN 码的首位数字表示书籍的出版语言，例如 0 代表英语；第一个分隔符 “-” 之后的三位数字代表出版社，例如 670 代表维京出版社；第二个分隔之后的五位数字代表该书在出版社的编号；最后一位为识别码。<br>识别码的计算方法如下：<a id="more"></a><br>首位数字乘以 1 加上次位数字乘以 2…… 以此类推，用所得的结果 mod 11，所得的余数即为识别码，如果余数为 10，则识别码为大写字母 X。例如 ISBN 号码 0-670-82162-4 中的识别码 4 是这样得到的：对 067082162 这 9 个数字，从左至右，分别乘以 1，2，…，9，再求和，即 0×1+6×2+……+2×9=158，然后取 158 mod 11 的结果 4 作为识别码。<br>编写程序判断输入的 ISBN 号码中识别码是否正确，如果正确，则仅输出 “Right”；如果错误，则输出是正确的 ISBN 号码。</p></blockquote><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><blockquote><p>输入只有一行，是一个字符序列，表示一本书的 ISBN 号码（保证输入符合 ISBN 号码的格式要求）。</p></blockquote><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><blockquote><p>输出一行，假如输入的 ISBN 号码的识别码正确，那么输出 “Right”，否则，按照规定的格式，输出正确的 ISBN 号码（包括分隔符 “-”）。       </p></blockquote><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>0-670-82162-4</p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>Right</p></blockquote><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>0-670-82162-0</p></blockquote><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>0-670-82162-4</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote><p>因为位数规定好了，所以算数比较简单，然后再进行判断即可。</p></blockquote><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 13</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> i,sum;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,&amp;s);</span><br><span class="line">sum=(s[<span class="number">0</span>]-<span class="string">'0'</span>)*<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=<span class="number">4</span>;i++)&#123;</span><br><span class="line">sum+=(s[i]-<span class="string">'0'</span>)*i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">6</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">sum+=(s[i]-<span class="string">'0'</span>)*(i<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>((sum%<span class="number">11</span>==<span class="number">10</span> &amp;&amp; s[N<span class="number">-1</span>] == <span class="string">'X'</span>)|| sum%<span class="number">11</span> == (s[N<span class="number">-1</span>]-<span class="string">'0'</span>))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Right"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N<span class="number">-1</span>;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>,s[i]);</span><br><span class="line">&#125;</span><br><span class="line">sum%<span class="number">11</span>==<span class="number">10</span>?<span class="built_in">printf</span>(<span class="string">"X"</span>):<span class="built_in">printf</span>(<span class="string">"%d"</span>,sum%<span class="number">11</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声明：菜鸟拙见，大神勿喷"><a href="#声明：菜鸟拙见，大神勿喷" class="headerlink" title="(声明：菜鸟拙见，大神勿喷)"></a><font color="red" size="4" face="宋体">(声明：菜鸟拙见，大神勿喷)</font></h2><p><strong>本文作者</strong>：Gong Jintao<br><strong>本文地址</strong>： <a href="http://blog.gongjintao.com/2018/08/12/CCF试题库201312-2————ISBN号码/">http://blog.gongjintao.com/2018/08/12/CCF试题库201312-2————ISBN号码/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;　每一本正式出版的图书都有一个 ISBN 号码与之对应，ISBN 码包括 9 位数字、1 位识别码和 3 位分隔符，其规定格式如 “x-xxx-xxxxx-x”，其中符号“-” 是分隔符（键盘上的减号），最后一位是识别码，例如 0-670-82162-4 就是一个标准的 ISBN 码。ISBN 码的首位数字表示书籍的出版语言，例如 0 代表英语；第一个分隔符 “-” 之后的三位数字代表出版社，例如 670 代表维京出版社；第二个分隔之后的五位数字代表该书在出版社的编号；最后一位为识别码。&lt;br&gt;识别码的计算方法如下：
    
    </summary>
    
      <category term="CCF试题库" scheme="http://blog.gongjintao.com/categories/CCF%E8%AF%95%E9%A2%98%E5%BA%93/"/>
    
    
      <category term="C/C++" scheme="http://blog.gongjintao.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>CCF试题库201312-1————出现次数最多的数</title>
    <link href="http://blog.gongjintao.com/2018/08/11/CCF%E8%AF%95%E9%A2%98%E5%BA%93201312-1%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E6%95%B0/"/>
    <id>http://blog.gongjintao.com/2018/08/11/CCF试题库201312-1————出现次数最多的数/</id>
    <published>2018-08-11T11:24:33.000Z</published>
    <updated>2019-06-30T02:59:52.812Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><blockquote><p>　给定 n 个正整数，找出它们中出现次数最多的数。如果这样的数有多个，请输出其中最小的一个。</p></blockquote><a id="more"></a><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><blockquote><p>　　输入的第一行只有一个正整数 n(1 ≤ n ≤ 1000)，表示数字的个数。<br>输入的第二行有 n 个整数 s1, s2, …, sn (1 ≤ si ≤ 10000, 1 ≤ i ≤ n)。相邻的数用空格分隔。</p></blockquote><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><blockquote><p>输出这 n 个次数中出现次数最多的数。如果这样的数有多个，输出其中最小的一个。</p></blockquote><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>6<br>10 1 10 20 30 20</p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>10</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote><p>此处规模不大，用hash表比较方便。</p></blockquote><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,i,s=<span class="number">0</span>,min,data;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">int</span> sum[<span class="number">10001</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;data);</span><br><span class="line">sum[data]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">10000</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(sum[i]&gt;s)&#123;</span><br><span class="line">s=sum[i];</span><br><span class="line">min=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,min);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声明：菜鸟拙见，大神勿喷"><a href="#声明：菜鸟拙见，大神勿喷" class="headerlink" title="(声明：菜鸟拙见，大神勿喷)"></a><font color="red" size="4" face="宋体">(声明：菜鸟拙见，大神勿喷)</font></h2><p><strong>本文作者</strong>：Gong Jintao<br><strong>本文地址</strong>： <a href="http://blog.gongjintao.com/2018/08/11/CCF试题库201312-1————出现次数最多的数/">http://blog.gongjintao.com/2018/08/11/CCF试题库201312-1————出现次数最多的数/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;　给定 n 个正整数，找出它们中出现次数最多的数。如果这样的数有多个，请输出其中最小的一个。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="CCF试题库" scheme="http://blog.gongjintao.com/categories/CCF%E8%AF%95%E9%A2%98%E5%BA%93/"/>
    
    
      <category term="C/C++" scheme="http://blog.gongjintao.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>CCF试题库201403-2————窗口</title>
    <link href="http://blog.gongjintao.com/2018/08/10/CCF%E8%AF%95%E9%A2%98%E5%BA%93201403-2%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E7%AA%97%E5%8F%A3/"/>
    <id>http://blog.gongjintao.com/2018/08/10/CCF试题库201403-2————窗口/</id>
    <published>2018-08-10T11:24:33.000Z</published>
    <updated>2019-06-30T04:28:59.398Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><blockquote><p>在某图形操作系统中, 有 N 个窗口, 每个窗口都是一个两边与坐标轴分别平行的矩形区域。窗口的边界上的点也属于该窗口。窗口之间有层次的区别, 在多于一个窗口重叠的区域里, 只会显示位于顶层的窗口里的内容。<br>　　当你点击屏幕上一个点的时候, 你就选择了处于被点击位置的最顶层窗口, 并且这个窗口就会被移到所有窗口的最顶层, 而剩余的窗口的层次顺序不变。如果你点击的位置不属于任何窗口, 则系统会忽略你这次点击。<br>　　现在我们希望你写一个程序模拟点击窗口的过程。</p></blockquote><a id="more"></a><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><blockquote><p>输入的第一行有两个正整数, 即 N 和 M。(1 ≤ N ≤ 10,1 ≤ M ≤ 10)<br>接下来 N 行按照从最下层到最顶层的顺序给出 N 个窗口的位置。 每行包含四个非负整数 x1, y1, x2, y2, 表示该窗口的一对顶点坐标分别为 (x1, y1) 和 (x2, y2)。保证 x1 &lt; x2,y1 2。<br>接下来 M 行每行包含两个非负整数 x, y, 表示一次鼠标点击的坐标。<br>题目中涉及到的所有点和矩形的顶点的 x, y 坐标分别不超过 2559 和 1439</p></blockquote><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><blockquote><p>输出包括 M 行, 每一行表示一次鼠标点击的结果。如果该次鼠标点击选择了一个窗口, 则输出这个窗口的编号 (窗口按照输入中的顺序从 1 编号到 N); 如果没有, 则输出 “IGNORED”(不含双引号)。</p></blockquote><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>3 4<br>0 0 4 4<br>1 1 5 5<br>2 2 6 6<br>1 1<br>0 0<br>4 4<br>0 5</p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>2<br>1<br>1<br>IGNORED</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote><p>思路较为简单：首先定义窗口结构体，包括窗口个定点的坐标以及其序号，然后输入数组中。输入坐标时，则反向循环数组（因为窗口输入时从底层到顶层；而点击需要先判断顶层）；若坐标在窗口内，则输出窗口序号，然后将该窗口移到最后一个，其余的窗口依次挪动位置。</p></blockquote><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">window</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x1,x2,y1,y2,index;</span><br><span class="line">&#125;Win;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,i,j,a,b;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    Win* wins;</span><br><span class="line">    wins = (Win*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Win)*n);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;wins[i].x1&gt;&gt;wins[i].y1&gt;&gt;wins[i].x2&gt;&gt;wins[i].y2;</span><br><span class="line">        wins[i].index=i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            Win temp;</span><br><span class="line">            <span class="keyword">if</span>((a&gt;=wins[i].x1 &amp;&amp; a&lt;=wins[i].x2) &amp;&amp; (b&gt;=wins[i].y1 &amp;&amp; b&lt;=wins[i].y2))&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;wins[i].index&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                temp = wins[i];</span><br><span class="line">                <span class="keyword">for</span>(j=i;j&lt;n<span class="number">-1</span>;j++)&#123;</span><br><span class="line">                    wins[j] = wins[j+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                wins[n<span class="number">-1</span>]=temp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"IGNORED"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声明：菜鸟拙见，大神勿喷"><a href="#声明：菜鸟拙见，大神勿喷" class="headerlink" title="(声明：菜鸟拙见，大神勿喷)"></a><font color="red" size="4" face="宋体">(声明：菜鸟拙见，大神勿喷)</font></h2><p><strong>本文作者</strong>：Gong Jintao<br><strong>本文地址</strong>： <a href="http://blog.gongjintao.com/2018/08/10/CCF试题库201403-2————窗口/">http://blog.gongjintao.com/2018/08/10/CCF试题库201403-2————窗口/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在某图形操作系统中, 有 N 个窗口, 每个窗口都是一个两边与坐标轴分别平行的矩形区域。窗口的边界上的点也属于该窗口。窗口之间有层次的区别, 在多于一个窗口重叠的区域里, 只会显示位于顶层的窗口里的内容。&lt;br&gt;　　当你点击屏幕上一个点的时候, 你就选择了处于被点击位置的最顶层窗口, 并且这个窗口就会被移到所有窗口的最顶层, 而剩余的窗口的层次顺序不变。如果你点击的位置不属于任何窗口, 则系统会忽略你这次点击。&lt;br&gt;　　现在我们希望你写一个程序模拟点击窗口的过程。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="CCF试题库" scheme="http://blog.gongjintao.com/categories/CCF%E8%AF%95%E9%A2%98%E5%BA%93/"/>
    
    
      <category term="C/C++" scheme="http://blog.gongjintao.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>CCF试题库201403-1————相反数</title>
    <link href="http://blog.gongjintao.com/2018/08/09/CCF%E8%AF%95%E9%A2%98%E5%BA%93201403-1%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E7%9B%B8%E5%8F%8D%E6%95%B0/"/>
    <id>http://blog.gongjintao.com/2018/08/09/CCF试题库201403-1————相反数/</id>
    <published>2018-08-09T11:24:33.000Z</published>
    <updated>2019-06-30T03:00:09.307Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><blockquote><p>有 N 个非零且各不相同的整数。请你编一个程序求出它们中有多少对相反数 (a 和 -a 为一对相反数)。</p></blockquote><a id="more"></a><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><blockquote><p>　第一行包含一个正整数 N。(1 ≤ N ≤ 500)。<br>第二行为 N 个用单个空格隔开的非零整数, 每个数的绝对值不超过 1000, 保证这些整数各不相同。</p></blockquote><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><blockquote><p>只输出一个整数, 即这 N 个数中包含多少对相反数。</p></blockquote><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>5<br>1 2 3 -1 -2</p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>2</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote><p>思路较为简单，嵌套两层循环即可。</p></blockquote><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,i,j,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> *a;</span><br><span class="line">    a = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((a[i]+a[j])==<span class="number">0</span>)&#123;</span><br><span class="line">                sum++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;sum;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声明：菜鸟拙见，大神勿喷"><a href="#声明：菜鸟拙见，大神勿喷" class="headerlink" title="(声明：菜鸟拙见，大神勿喷)"></a><font color="red" size="4" face="宋体">(声明：菜鸟拙见，大神勿喷)</font></h2><p><strong>本文作者</strong>：Gong Jintao<br><strong>本文地址</strong>： <a href="http://blog.gongjintao.com/2018/08/09/CCF试题库201403-1————相反数/">http://blog.gongjintao.com/2018/08/09/CCF试题库201403-1————相反数/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;有 N 个非零且各不相同的整数。请你编一个程序求出它们中有多少对相反数 (a 和 -a 为一对相反数)。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="CCF试题库" scheme="http://blog.gongjintao.com/categories/CCF%E8%AF%95%E9%A2%98%E5%BA%93/"/>
    
    
      <category term="C/C++" scheme="http://blog.gongjintao.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>CCF认证题库201409-2————画图</title>
    <link href="http://blog.gongjintao.com/2018/07/29/CCF%E8%AE%A4%E8%AF%81%E9%A2%98%E5%BA%93201409-2%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E7%94%BB%E5%9B%BE/"/>
    <id>http://blog.gongjintao.com/2018/07/29/CCF认证题库201409-2————画图/</id>
    <published>2018-07-29T11:47:25.000Z</published>
    <updated>2019-06-30T02:54:40.471Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><blockquote><p>　在一个定义了直角坐标系的纸上，画一个(x1,y1)到(x2,y2)的矩形指将横坐标范围从x1到x2，纵坐标范围从y1到y2之间的区域涂上颜色。<br>　　下图给出了一个画了两个矩形的例子。第一个矩形是(1,1) 到(4, 4)，用绿色和紫色表示。第二个矩形是(2, 3)到(6, 5)，用蓝色和紫色表示。图中，一共有15个单位的面积被涂上颜色，其中紫色部分被涂了两次，但在计算面积时只计算一次。在实际的涂色过程中，所有的矩形都涂成统一的颜色，图中显示不同颜色仅为说明方便。<a id="more"></a><br>      <img src="http://118.190.20.162/RequireFile.do?fid=qMtgAT3j" alt><br>　　给出所有要画的矩形，请问总共有多少个单位的面积被涂上颜色。</p></blockquote><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><blockquote><p>　　输入的第一行包含一个整数n，表示要画的矩形的个数。<br>　　接下来n行，每行4个非负整数，分别表示要画的矩形的左下角的横坐标与纵坐标，以及右上角的横坐标与纵坐标。</p></blockquote><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><blockquote><p>　　输出一个整数，表示有多少个单位的面积被涂上颜色。</p></blockquote><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>2<br>1 1 4 4<br>2 3 6 5</p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>15</p></blockquote><h3 id="评测用例规模与约定"><a href="#评测用例规模与约定" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h3><blockquote><p>　　1&lt;=n&lt;=100，0&lt;=横坐标、纵坐标&lt;=100。</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote><p>总结此类题目的通法，即对原矩阵的变化无法直接对原矩阵进行操作，但可以设置标志矩阵进行模拟操作。如<a href="http://blog.gongjintao.com/2018/07/26/CCF%E8%AE%A4%E8%AF%81%E9%A2%98%E5%BA%93201512-2%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E6%B6%88%E9%99%A4%E7%B1%BB%E6%B8%B8%E6%88%8F/">201512-2消除类游戏</a><br>本题可设置一个100x100的二维数组map[100][100],然后对输入的进行画图矩阵在map[100][100]中进行涂抹，图上颜色则置为1，最后统计map[100][100]中1的个数即总的面积。</p></blockquote><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,i,j,s=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">100</span>][<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=a[<span class="number">0</span>];i&lt;a[<span class="number">2</span>];i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(j=a[<span class="number">1</span>];j&lt;a[<span class="number">3</span>];j++)&#123;</span><br><span class="line"><span class="built_in">map</span>[i][j]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">100</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">s++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声明：菜鸟拙见，大神勿喷"><a href="#声明：菜鸟拙见，大神勿喷" class="headerlink" title="(声明：菜鸟拙见，大神勿喷)"></a><font color="red" size="4" face="宋体">(声明：菜鸟拙见，大神勿喷)</font></h2><p><strong>本文作者</strong>：Gong Jintao<br><strong>本文地址</strong>： <a href="http://blog.gongjintao.com/2018/07/29/CCF认证题库201409-2————画图/">http://blog.gongjintao.com/2018/07/29/CCF认证题库201409-2————画图/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;　在一个定义了直角坐标系的纸上，画一个(x1,y1)到(x2,y2)的矩形指将横坐标范围从x1到x2，纵坐标范围从y1到y2之间的区域涂上颜色。&lt;br&gt;　　下图给出了一个画了两个矩形的例子。第一个矩形是(1,1) 到(4, 4)，用绿色和紫色表示。第二个矩形是(2, 3)到(6, 5)，用蓝色和紫色表示。图中，一共有15个单位的面积被涂上颜色，其中紫色部分被涂了两次，但在计算面积时只计算一次。在实际的涂色过程中，所有的矩形都涂成统一的颜色，图中显示不同颜色仅为说明方便。
    
    </summary>
    
      <category term="CCF试题库" scheme="http://blog.gongjintao.com/categories/CCF%E8%AF%95%E9%A2%98%E5%BA%93/"/>
    
    
      <category term="C/C++" scheme="http://blog.gongjintao.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>CCF认证题库201409-1————相邻对数</title>
    <link href="http://blog.gongjintao.com/2018/07/29/CCF%E8%AE%A4%E8%AF%81%E9%A2%98%E5%BA%93201409-1%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E7%9B%B8%E9%82%BB%E5%AF%B9%E6%95%B0/"/>
    <id>http://blog.gongjintao.com/2018/07/29/CCF认证题库201409-1————相邻对数/</id>
    <published>2018-07-29T11:30:48.000Z</published>
    <updated>2019-06-30T03:00:22.396Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><blockquote><p>给定n个不同的整数，问这些数中有多少对整数，它们的值正好相差1。</p></blockquote><a id="more"></a><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><blockquote><p>输入的第一行包含一个整数n，表示给定整数的个数。<br>第二行包含所给定的n个整数。</p></blockquote><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><blockquote><p>输出一个整数，表示值正好相差1的数对的个数。</p></blockquote><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>6<br>10 2 6 3 7 8</p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>3</p></blockquote><h3 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h3><blockquote><p>值正好相差1的数对包括(2, 3), (6, 7), (7, 8)。</p></blockquote><h3 id="评测用例规模与约定"><a href="#评测用例规模与约定" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h3><blockquote><p>1&lt;=n&lt;=1000，给定的整数为不超过10000的非负整数。</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote><p>循环判断后面的数与当前数只差的绝对值是否等于1，然后累计即可。</p></blockquote><h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,i,j,sum=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">int</span> *a=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">abs</span>(a[j]-a[i])==<span class="number">1</span>)&#123;</span><br><span class="line">sum++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声明：菜鸟拙见，大神勿喷"><a href="#声明：菜鸟拙见，大神勿喷" class="headerlink" title="(声明：菜鸟拙见，大神勿喷)"></a><font color="red" size="4" face="宋体">(声明：菜鸟拙见，大神勿喷)</font></h2><p><strong>本文作者</strong>：Gong Jintao<br><strong>本文地址</strong>： <a href="http://blog.gongjintao.com/2018/07/29/CCF认证题库201409-1————相邻对数/">http://blog.gongjintao.com/2018/07/29/CCF认证题库201409-1————相邻对数/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定n个不同的整数，问这些数中有多少对整数，它们的值正好相差1。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="CCF试题库" scheme="http://blog.gongjintao.com/categories/CCF%E8%AF%95%E9%A2%98%E5%BA%93/"/>
    
    
      <category term="C/C++" scheme="http://blog.gongjintao.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>CCF认证题库201412-2————Z字形扫描</title>
    <link href="http://blog.gongjintao.com/2018/07/28/CCF%E8%AE%A4%E8%AF%81%E9%A2%98%E5%BA%93201412-2%E2%80%94%E2%80%94%E2%80%94%E2%80%94Z%E5%AD%97%E5%BD%A2%E6%89%AB%E6%8F%8F/"/>
    <id>http://blog.gongjintao.com/2018/07/28/CCF认证题库201412-2————Z字形扫描/</id>
    <published>2018-07-28T14:26:34.000Z</published>
    <updated>2019-06-30T02:54:46.010Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><blockquote><p>　　在图像编码的算法中，需要将一个给定的方形矩阵进行Z字形扫描(Zigzag Scan)。给定一个n×n的矩阵，Z字形扫描的过程如下图所示：<br><img src="http://118.190.20.162/RequireFile.do?fid=Nad2EgMG" alt></p><p>　　<a id="more"></a>对于下面的4×4的矩阵，<br>　　1 5 3 9<br>　　3 7 5 6<br>　　9 4 6 4<br>　　7 3 1 3<br>　　对其进行Z字形扫描后得到长度为16的序列：<br>　　1 5 3 9 7 3 9 5 4 7 3 6 6 4 1 3<br>　　请实现一个Z字形扫描的程序，给定一个n×n的矩阵，输出对这个矩阵进行Z字形扫描的结果。</p></blockquote><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><blockquote><p>　　输入的第一行包含一个整数n，表示矩阵的大小。<br>　　输入的第二行到第n+1行每行包含n个正整数，由空格分隔，表示给定的矩阵。</p></blockquote><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><blockquote><p>　　输出一行，包含n×n个整数，由空格分隔，表示输入的矩阵经过Z字形扫描后的结果。</p></blockquote><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>4<br>1 5 3 9<br>3 7 5 6<br>9 4 6 4<br>7 3 1 3</p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>1 5 3 9 7 3 9 5 4 7 3 6 6 4 1 3</p></blockquote><h3 id="评测用例规模与约定"><a href="#评测用例规模与约定" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h3><blockquote><p>　　1≤n≤500，矩阵元素为不超过1000的正整数。</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote><p>注意不要被示例的图片局限了范围。要考虑全面。<br>依图可知，可以将运动方向分为4个方向：向右、左下、向下、右上。<br>当向右时，列号加1。然后判断若该数行号为1，则将向左下运动；若行号是n，则将向右上运动。<br>当向左下时，行号加1，列号减1。然后判断该数若列号为1，则将向下运动；若行号是n，则将向右运动。<br>当向下运动时，则行号加1。然后判断该数若列号为1，则将向右上运动，其他则是向左下运动。<br>当向右上运动时，则行号减1，列号加1。然后判断该数若行号为1且不是最右边那个，则将向右运动，若是最右边那个，则将向下运动。</p></blockquote><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,i,j;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">int</span> num[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;num[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> d=<span class="number">1</span>;<span class="comment">//1 向右，2 左下，3 向下，4 右上</span></span><br><span class="line">i=j=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i+j&lt;<span class="number">2</span>*n)&#123;</span><br><span class="line"><span class="keyword">switch</span>(d)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;num[i][j++]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">1</span>)&#123;</span><br><span class="line">d = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i == n)&#123;</span><br><span class="line">d = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;num[i++][j--]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"><span class="keyword">if</span>(j == <span class="number">1</span>)&#123;</span><br><span class="line">d = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i == n)&#123;</span><br><span class="line">d = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;num[i++][j]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"><span class="keyword">if</span>(j == <span class="number">1</span>)&#123;</span><br><span class="line">d = <span class="number">4</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">d = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;num[i--][j++]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">1</span> &amp;&amp; j != n)&#123;</span><br><span class="line">d = <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(j == n)&#123;</span><br><span class="line">d = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;num[i][j];</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声明：菜鸟拙见，大神勿喷"><a href="#声明：菜鸟拙见，大神勿喷" class="headerlink" title="(声明：菜鸟拙见，大神勿喷)"></a><font color="red" size="4" face="宋体">(声明：菜鸟拙见，大神勿喷)</font></h2><p><strong>本文作者</strong>：Gong Jintao<br><strong>本文地址</strong>： <a href="http://blog.gongjintao.com/2018/07/28/CCF认证题库201412-2————Z字形扫描/">http://blog.gongjintao.com/2018/07/28/CCF认证题库201412-2————Z字形扫描/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;　　在图像编码的算法中，需要将一个给定的方形矩阵进行Z字形扫描(Zigzag Scan)。给定一个n×n的矩阵，Z字形扫描的过程如下图所示：&lt;br&gt;&lt;img src=&quot;http://118.190.20.162/RequireFile.do?fid=Nad2EgMG&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="CCF试题库" scheme="http://blog.gongjintao.com/categories/CCF%E8%AF%95%E9%A2%98%E5%BA%93/"/>
    
    
      <category term="C/C++" scheme="http://blog.gongjintao.com/tags/C-C/"/>
    
  </entry>
  
</feed>
