<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GongJintao&#39; Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.gongjintao.com/"/>
  <updated>2019-07-05T04:09:43.902Z</updated>
  <id>http://blog.gongjintao.com/</id>
  
  <author>
    <name>Gong Jintao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《统计学习方法》——朴素贝叶斯法</title>
    <link href="http://blog.gongjintao.com/2019/07/05/%E3%80%8A%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E3%80%8B%E2%80%94%E2%80%94%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%B3%95/"/>
    <id>http://blog.gongjintao.com/2019/07/05/《统计学习方法》——朴素贝叶斯法/</id>
    <published>2019-07-05T01:34:08.000Z</published>
    <updated>2019-07-05T04:09:43.902Z</updated>
    
    <content type="html"><![CDATA[<h1 id="4-1-朴素贝叶斯法的学习与分类"><a href="#4-1-朴素贝叶斯法的学习与分类" class="headerlink" title="4.1 朴素贝叶斯法的学习与分类"></a>4.1 朴素贝叶斯法的学习与分类</h1><h2 id="4-1-1-基本方法"><a href="#4-1-1-基本方法" class="headerlink" title="4.1.1 基本方法"></a>4.1.1 基本方法</h2><p>​        设输入空间$x⊆\mathrm{R}_n$为n维向量的集合，输出空间为类标记集合$\mathcal{Y}＝\{c_1,c_2,\ldots,c_K\}$。输入为特征向量$x∊\mathcal{X}$，输出为<strong>类标记（class label)</strong>$y\in \mathcal{Y}$。$X$是定义在输入空间$\mathcal{X}$上的随机向量，$Y$是定义在输出空间$\mathcal{Y}$上的随机变量。$P(X,Y)$是$X$和$Y$的联合概率分布。训练数据集</p><script type="math/tex; mode=display">T=\left\{\left(x_{1}, y_{1}\right),\left(x_{2}, y_{2}\right), \cdots,\left(x_{N}, y_{N}\right)\right\}</script><p>由$P(X,Y)$独立同分布产生。</p><p>​        朴素贝叶斯法通过训练数据集学习联合概率分布$P(X,Y)$。具体地，学习以下先验概率分布及条件概率分布。先验概率分布</p><script type="math/tex; mode=display">P\left(Y=c_{k}\right), \quad k=1,2, \cdots, K</script><p>条件概率分布</p><script type="math/tex; mode=display">P\left(X=x | Y=c_{k}\right)=P\left(X^{(1)}=x^{(1)}, \cdots,\left.X^{(n)}\right|^{(n)} | Y=c_{k}\right), \quad k=1,2, \cdots, K</script><p>于是学习到联合概率分布$P(X,Y)$。</p><p>​        朴素贝叶斯法对条件概率分布作了条件独立性的假设，具体如下：</p><script type="math/tex; mode=display">\begin{aligned} P\left(X=x | Y=c_{k}\right) &=P\left(X^{(1)}=x^{(1)}, \cdots, X^{(n)}=x^{(n)} | Y=c_{k}\right) \\ &=\prod_{j=1}^{n} P\left(X^{(j)}=x^{(j)} | Y=c_{k}\right) \end{aligned}</script><p>​        朴素贝叶斯法分类时，对给定的输入$x$，通过学习到的模型计算后验概率分布$ P(Y＝c_k|X＝x)$，将<strong>后验概率最大的类</strong>作为$x$的类输出。后验概率计算根据贝叶斯定理进行：</p><script type="math/tex; mode=display">P\left(Y=c_{k} | X=x\right)=\frac{P\left(X=x | Y=c_{k}\right) P\left(Y=c_{k}\right)}{\sum_{k} P\left(X=x | Y=c_{k}\right) P\left(Y=c_{k}\right)}</script><p>将条件独立性假设代入上式，则朴素贝叶斯分类器可表示为</p><script type="math/tex; mode=display">y=f(x)=\arg \max _{c_{k}} \frac{P\left(Y=c_{k}\right) \prod_{j} P\left(X^{(j)}=x^{(j)} | Y=c_{k}\right)}{\sum_{k} P\left(Y=c_{k}\right) \prod_{j} P\left(X^{(j)}=x^{(j)} | Y=c_{k}\right)}</script><p>因为对于所有的$c_k$上式的分母都是一样的，所以</p><script type="math/tex; mode=display">y=\arg \max _{c_{k}} P\left(Y=c_{k}\right) \prod_{j} P\left(X^{(j)}=x^{(j)} | Y=c_{k}\right)</script><h2 id="4-1-2-后验概率最大化的含义"><a href="#4-1-2-后验概率最大化的含义" class="headerlink" title="4.1.2 后验概率最大化的含义"></a>4.1.2 后验概率最大化的含义</h2><p>​        朴素贝叶斯法将实例分到后验概率最大的类中。这等价于期望风险最小化。</p><p><strong>证明：</strong> 假设选择<strong>0-1损失函数</strong>，即：</p><script type="math/tex; mode=display">L(Y, f(X))=\left\{\begin{array}{ll}{1,} & {Y \neq f(X)} \\ {0,} & {Y=f(X)}\end{array}\right.</script><p>这时期望风险函数为：</p><script type="math/tex; mode=display">R_{\mathrm{exp}}(f)=E[L(Y, f(X))]</script><p>期望是对联合分布$P(X,Y)$取的。由此取条件期望</p><script type="math/tex; mode=display">R_{\mathrm{exp}}(f)=E_{X} \sum_{k=1}^{K}\left[L\left(c_{k}, f(X)\right)\right] P\left(c_{k} | X\right)</script><p>为了使期望风险最小化，只需对$X=x$逐个极小化，由此得到：</p><script type="math/tex; mode=display">\begin{aligned} f(x) &=\arg \min _{y \in \mathcal{Y}} \sum_{k=1}^{K} L\left(c_{k}, y\right) P\left(c_{k} | X=x\right) \\ &=\arg \min _{y \in \mathcal{Y}} \sum_{k=1}^{K} P\left(y \neq c_{k} | X=x\right) \\ &=\arg \min _{y \in \mathcal{Y}}\left(1-P\left(y=c_{k} | X=x\right)\right) \\ &=\arg \max _{y \in \mathcal{Y}} P\left(y=c_{k} | X=x\right) \end{aligned}</script><p>即根据期望风险最小化准则就得到了后验概率最大化准则：</p><script type="math/tex; mode=display">f(x)=\arg \max _{c_{k}} P\left(c_{k} | X=x\right)</script><h1 id="4-2-朴素贝叶斯法的参数估计"><a href="#4-2-朴素贝叶斯法的参数估计" class="headerlink" title="4.2 朴素贝叶斯法的参数估计"></a>4.2 朴素贝叶斯法的参数估计</h1><h2 id="4-2-1-极大似然估计"><a href="#4-2-1-极大似然估计" class="headerlink" title="4.2.1 极大似然估计"></a>4.2.1 极大似然估计</h2><p>​        朴素贝叶斯法中，学习意味着估计先验概率$P(Y＝c_k)$和条件概率$P(X^{(j)}＝x^{(j)}|Y＝c_k)$</p><p>先验概率的极大似然估计是</p><script type="math/tex; mode=display">P\left(Y=c_{k}\right)=\frac{\sum_{i=1}^{N} I\left(y_{i}=c_{k}\right)}{N}, \quad k=1,2, \cdots, K</script><p>设第$j$个特征$x^{(j)}$可能取值的集合为$\{a_j1,a_j2,\ldots,a_{jSj} \}$，条件概率$P(x^{(j)}＝a_{jl}|Y＝c_k)$的极大似然估计是:</p><script type="math/tex; mode=display">\begin{array}{l}{\qquad P\left(X^{(j)}=a_{j l} | Y=c_{k}\right)=\frac{\sum_{i=1}^{N} I\left(x_{i}^{(j)}=a_{j l}, y_{i}=c_{k}\right)}{\sum_{i=1}^{N} I\left(y_{i}=c_{k}\right)}} \\ {j=1,2, \cdots, n ; \quad l=1,2, \cdots, S_{i} ; \quad k=1,2, \cdots, K}\end{array}</script><p>式中，$x_i^{j}$是第$i$个样本的第$j$个特征；$a_{jl}$是第$j$个特征可能取的第$l$个值；$I$为指示函数。</p><h2 id="4-2-2-学习与分类算法"><a href="#4-2-2-学习与分类算法" class="headerlink" title="4.2.2 学习与分类算法"></a>4.2.2 学习与分类算法</h2><p>​        朴素贝叶斯算法：</p><blockquote><p><em>输入：1. </em>训练数据$T=\left\{\left(x_{1}, y_{1}\right),\left(x_{2}, y_{2}\right), \ldots,\left(x_{N}, y_{N}\right)\right\}$，其中$x_{i}=\left(x_{i}^{(1)}, x_{i}^{(2)}, \cdots, x_{i}^{(n)}\right)^{\mathrm{T}}$，具体含义如上述。$y_i \in \{c_1,c_2,\ldots,c_K\}$; 2. 实例$x$</p><p><em>输出：</em> 实例$x$的分类</p><p><em>算法步骤：</em></p><ol><li><p>计算先验概率和条件概率：</p><script type="math/tex; mode=display">P\left(Y=c_{k}\right)=\frac{\sum_{i=1}^{N} I\left(y_{i}=c_{k}\right)}{N}, \quad k=1,2, \cdots, K \\P\left(X^{(j)}=a_{j l} | Y=c_{k}\right)=\frac{\sum_{i=1}^{N} I\left(x_{i}^{(i)}=a_{jl}, y_{i}=c_{k}\right)}{\sum_{i=1}^{N} I\left(y_{i}=c_{k}\right)} \\j=1,2, \cdots, n ; \quad l=1,2, \cdots, S_{i} ; \quad k=1,2, \cdots, K</script></li><li><p>对于给定的实例$x=\left(x^{(1)}, x^{(2)}, \ldots, x^{n)}\right)^{\mathrm{T}}$，计算</p><script type="math/tex; mode=display">P\left(Y=c_{k}\right) \prod_{j=1}^{n} P\left(X^{(j)}=x^{(j)} | Y=c_{k}\right), \quad k=1,2, \cdots, K</script></li><li><p>确定实例$x$的类</p><script type="math/tex; mode=display">y=\arg \max _{c_{k}} P\left(Y=c_{k}\right) \prod_{j=1}^{n} P\left(X^{(j)}=x^{(j)} | Y=c_{k}\right)</script></li></ol></blockquote><p><strong>本文作者</strong>：Gong Jintao<br><strong>本文地址</strong>： <a href="http://blog.gongjintao.com/2019/07/05/《统计学习方法》——朴素贝叶斯法/">http://blog.gongjintao.com/2019/07/05/《统计学习方法》——朴素贝叶斯法/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;4-1-朴素贝叶斯法的学习与分类&quot;&gt;&lt;a href=&quot;#4-1-朴素贝叶斯法的学习与分类&quot; class=&quot;headerlink&quot; title=&quot;4.1 朴素贝叶斯法的学习与分类&quot;&gt;&lt;/a&gt;4.1 朴素贝叶斯法的学习与分类&lt;/h1&gt;&lt;h2 id=&quot;4-1-1-基本方
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://blog.gongjintao.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="《统计学习方法》" scheme="http://blog.gongjintao.com/tags/%E3%80%8A%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>机器学习算法源码之k近邻算法</title>
    <link href="http://blog.gongjintao.com/2019/07/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E6%BA%90%E7%A0%81%E4%B9%8Bk%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/"/>
    <id>http://blog.gongjintao.com/2019/07/03/机器学习算法源码之k近邻算法/</id>
    <published>2019-07-03T07:44:29.000Z</published>
    <updated>2019-07-04T13:13:15.623Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-KD树实现KNN算法"><a href="#1-KD树实现KNN算法" class="headerlink" title="1. KD树实现KNN算法"></a>1. KD树实现KNN算法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建结点类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.lchild = <span class="literal">None</span></span><br><span class="line">        self.rchild = <span class="literal">None</span></span><br><span class="line">        self.feature = <span class="literal">None</span> <span class="comment"># 结点的特征向量</span></span><br><span class="line">        self.axes = <span class="literal">None</span> <span class="comment"># 结点的划分平面所在的维度</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_str</span><span class="params">(self)</span>:</span> <span class="comment"># 返回结点的信息</span></span><br><span class="line">        <span class="keyword">return</span> [self.lchild,self.rchild,self.feature,self.axes]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KDTree</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,input_x,input_y)</span>:</span></span><br><span class="line">        self._input_x = input_x</span><br><span class="line">        self._input_y = input_y</span><br><span class="line">        self._nearest = [] <span class="comment"># 用于存储离目标点最近的点,包括特征向量，距离，和标签</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构建KD树</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build_tree</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._build_tree(self._input_x,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_build_tree</span><span class="params">(self, data, r)</span>:</span></span><br><span class="line">        root = Node()</span><br><span class="line"></span><br><span class="line">        [n, m] = np.shape(data)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对data的第r维坐标进行排序</span></span><br><span class="line">        sorted_data = data[data[:, r].argsort()]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 取中间的元素</span></span><br><span class="line">        mid = n//<span class="number">2</span></span><br><span class="line">        root.feature = sorted_data[mid]</span><br><span class="line">        root.axes = r</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 更新r</span></span><br><span class="line">        r = (r + <span class="number">1</span>) % m</span><br><span class="line">        root.lchild = self._build_tree(sorted_data[:mid], r)</span><br><span class="line">        root.rchild = self._build_tree(sorted_data[mid + <span class="number">1</span>:], r)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get_distance</span><span class="params">(self,a,b)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> np.sqrt(sum((a-b)**<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 求离目标点最近的k个点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_check_nearest</span><span class="params">(self,current,target,k)</span>:</span></span><br><span class="line">        d = self._get_distance(current,target)</span><br><span class="line">        l = len(self._nearest)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> l &lt; k:</span><br><span class="line">            self._nearest.append([current,d])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            farthest_d = self._get_farthest()[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> farthest_d &gt; d:</span><br><span class="line">                <span class="comment"># 将最远点移除</span></span><br><span class="line">                new_nearest = [item <span class="keyword">for</span> item <span class="keyword">in</span> self._nearest <span class="keyword">if</span> item[<span class="number">1</span>] &lt; farthest_d]</span><br><span class="line">                new_nearest.append([current,d])</span><br><span class="line">                self._nearest = new_nearest</span><br><span class="line"></span><br><span class="line"> <span class="comment"># 找出_nearest中距离目标点最远的点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get_farthest</span><span class="params">(self)</span>:</span></span><br><span class="line">        farthest = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> self._nearest:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> farthest:</span><br><span class="line">                farthest = item</span><br><span class="line">            <span class="keyword">elif</span> farthest[<span class="number">1</span>] &lt; item[<span class="number">1</span>]:</span><br><span class="line">                farthest = item</span><br><span class="line">        <span class="keyword">return</span> farthest</span><br><span class="line">                </span><br><span class="line">    <span class="comment"># 在以tree为根结点的树中寻找叶结点，并将查找路径保存在stack中</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_search_leaf</span><span class="params">(self,tree,target,stack)</span>:</span></span><br><span class="line">        travel_tree = tree</span><br><span class="line">        <span class="keyword">while</span> travel_tree:</span><br><span class="line">            [lchild,rchild,feature,axes] = travel_tree.get_str()</span><br><span class="line">            <span class="keyword">if</span> target[axes] &gt;= feature[axes]:</span><br><span class="line">                next_node = rchild</span><br><span class="line">                next_direction = <span class="string">'right'</span> <span class="comment"># 记录哪个方向被访问过了</span></span><br><span class="line">            <span class="keyword">elif</span> target[axes] &lt; feature[axes]:</span><br><span class="line">                next_node = lchild</span><br><span class="line">                next_direction = <span class="string">'left'</span></span><br><span class="line">            stack.append([travel_tree,next_direction])</span><br><span class="line">            travel_tree = next_node   </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 搜索kd树</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search_kd_tree</span><span class="params">(self,tree,target,k=<span class="number">1</span>)</span>:</span></span><br><span class="line">        stack = []</span><br><span class="line">        self._search_leaf(tree,target,stack) <span class="comment"># 一直搜索到叶结点，并将路径入栈</span></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            [node,next_direction] = stack.pop() <span class="comment">#出栈</span></span><br><span class="line">            <span class="comment"># 当前结点的信息</span></span><br><span class="line">            [lchild,rchild,feature,axes] = node.get_str()</span><br><span class="line">            self._check_nearest(feature,target,k) <span class="comment"># 检查当前结点的距离</span></span><br><span class="line">            <span class="keyword">if</span> node.lchild <span class="keyword">and</span> node.rchild <span class="keyword">is</span> <span class="literal">None</span>: <span class="comment">#如果当前结点是叶子结点，继续下一个循环</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            [farthest,distance] = self._get_farthest()</span><br><span class="line">            <span class="keyword">if</span> abs(feature[axes] - farthest[axes]) &lt; distance: <span class="comment"># 如果当前结点的轴经过了圆</span></span><br><span class="line">                <span class="keyword">if</span> next_direction == <span class="string">'right'</span>:</span><br><span class="line">                    try_node = lchild</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    try_node = rchild</span><br><span class="line">                self._search_leaf(try_node,target,stack)</span><br><span class="line">        <span class="keyword">return</span> self._nearest</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 分类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">classify</span><span class="params">(self)</span>:</span></span><br><span class="line">        types = dict()</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> self._nearest:</span><br><span class="line">            <span class="keyword">if</span> item[<span class="number">-1</span>] <span class="keyword">in</span> types:</span><br><span class="line">                types[item[<span class="number">-1</span>]] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                types[item[<span class="number">-1</span>]] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> max(types,key=types.get)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    data = np.array([[<span class="number">6.27</span>, <span class="number">5.50</span>],</span><br><span class="line">                      [<span class="number">1.24</span>, <span class="number">-2.86</span>],</span><br><span class="line">                      [<span class="number">17.05</span>, <span class="number">-12.79</span>],</span><br><span class="line">                      [<span class="number">-6.88</span>, <span class="number">-5.40</span>],</span><br><span class="line">                      [<span class="number">-2.96</span>, <span class="number">-0.50</span>],</span><br><span class="line">                      [<span class="number">7.75</span>, <span class="number">-22.68</span>],</span><br><span class="line">                      [<span class="number">10.80</span>, <span class="number">-5.03</span>],</span><br><span class="line">                      [<span class="number">-4.60</span>, <span class="number">-10.55</span>],</span><br><span class="line">                      [<span class="number">-4.96</span>, <span class="number">12.61</span>],</span><br><span class="line">                      [<span class="number">1.75</span>, <span class="number">12.26</span>],</span><br><span class="line">                      [<span class="number">15.31</span>, <span class="number">-13.16</span>],</span><br><span class="line">                      [<span class="number">7.83</span>, <span class="number">15.70</span>],</span><br><span class="line">                      [<span class="number">14.63</span>, <span class="number">-0.35</span>]])</span><br><span class="line"></span><br><span class="line">    labels = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>])</span><br><span class="line">    kd = KDTree(data,labels)</span><br><span class="line">    tree = kd.build_tree()</span><br><span class="line">    target = [<span class="number">-1</span>,<span class="number">-5</span>]</span><br><span class="line">    <span class="comment"># 求离点(-1,-5)最近的三个点</span></span><br><span class="line">    nearest = kd.search_kd_tree(tree,target,<span class="number">3</span>)</span><br><span class="line">    print(nearest)</span><br><span class="line"></span><br><span class="line">    plt.figure(dpi=<span class="number">100</span>)  <span class="comment"># 指定像素</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(labels)):</span><br><span class="line">        <span class="keyword">if</span> labels[i] ==<span class="number">1</span>:</span><br><span class="line">            color = <span class="string">'c'</span></span><br><span class="line">        <span class="keyword">elif</span> labels[i] == <span class="number">2</span>:</span><br><span class="line">            color = <span class="string">'b'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            color = <span class="string">'g'</span></span><br><span class="line">        plt.scatter(data[i][<span class="number">0</span>],data[i][<span class="number">1</span>],c=color,s=<span class="number">30</span>,alpha=<span class="number">0.8</span>)</span><br><span class="line"></span><br><span class="line">    plt.scatter(target[<span class="number">0</span>],target[<span class="number">1</span>],c=<span class="string">'r'</span>,s=<span class="number">30</span>,alpha=<span class="number">0.8</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> nearest:</span><br><span class="line">        plt.plot([target[<span class="number">0</span>],item[<span class="number">0</span>][<span class="number">0</span>]],[target[<span class="number">1</span>],item[<span class="number">0</span>][<span class="number">1</span>]],<span class="string">'r--'</span>)</span><br><span class="line"></span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[array([ 1.24, -2.86]), 3.0979347959568164], [array([-6.88, -5.4 ]), 5.89358973801197], [array([-2.96, -0.5 ]), 4.908319468005317]]</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/005XIOOuly1g4o43zf6azj30en09p3yh.jpg" alt></p><p>参考自<a href="https://www.cntofu.com/book/48/kjin-lin-fa/kdshu-python-shi-xian.md" target="_blank" rel="noopener">此处</a></p><h2 id="2-用scikit-learn-实现KNN分类"><a href="#2-用scikit-learn-实现KNN分类" class="headerlink" title="2. 用scikit-learn 实现KNN分类"></a>2. 用scikit-learn 实现KNN分类</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> neighbors</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机生成6组200个的正态分布</span></span><br><span class="line">x1 = np.random.normal(<span class="number">50</span>,<span class="number">6</span>,<span class="number">200</span>)</span><br><span class="line">y1 = np.random.normal(<span class="number">5</span>,<span class="number">0.5</span>,<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">x2 = np.random.normal(<span class="number">30</span>,<span class="number">6</span>,<span class="number">200</span>)</span><br><span class="line">y2 = np.random.normal(<span class="number">4</span>,<span class="number">0.5</span>,<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">x3 = np.random.normal(<span class="number">45</span>,<span class="number">6</span>,<span class="number">200</span>)</span><br><span class="line">y3 = np.random.normal(<span class="number">2.5</span>,<span class="number">0.5</span>,<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line">plt.figure(dpi=<span class="number">100</span>) <span class="comment">#指定像素</span></span><br><span class="line"></span><br><span class="line">plt.scatter(x1,y1,c=<span class="string">'b'</span>,marker=<span class="string">'s'</span>,s=<span class="number">50</span>,alpha=<span class="number">0.8</span>)</span><br><span class="line">plt.scatter(x2,y2,c=<span class="string">'r'</span>, marker=<span class="string">'^'</span>, s=<span class="number">50</span>, alpha=<span class="number">0.8</span>)</span><br><span class="line">plt.scatter(x3,y3, c=<span class="string">'g'</span>, s=<span class="number">50</span>, alpha=<span class="number">0.8</span>)</span><br><span class="line"></span><br><span class="line">plt.axis((<span class="number">10</span>, <span class="number">70</span>,<span class="number">1</span>,<span class="number">7</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/005XIOOuly1g4mp58i4mej30e809rmy9.jpg" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将各组数据组成输入数据集</span></span><br><span class="line">x_val = np.concatenate((x1,x2,x3))</span><br><span class="line">y_val = np.concatenate((y1,y2,y3))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据归一化</span></span><br><span class="line">x_diff = max(x_val) - min(x_val)</span><br><span class="line">y_diff = max(y_val) - min(y_val)</span><br><span class="line"></span><br><span class="line">x_normalized = x_val/ x_diff</span><br><span class="line">y_normalized = y_val/ y_diff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为python3中zip返回的是一个对象，所以要用list进行展开</span></span><br><span class="line">xy_normalized = list(zip(x_normalized,y_normalized))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成分类标签，第一组为第一类，第二组为第二类，第三组为第三类</span></span><br><span class="line">labels = [<span class="number">1</span>]*<span class="number">200</span> + [<span class="number">2</span>]*<span class="number">200</span> + [<span class="number">3</span>]*<span class="number">200</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成KNN分类器,k为30，其它参数默认</span></span><br><span class="line">clf = neighbors.KNeighborsClassifier(<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># # 训练数据</span></span><br><span class="line">clf.fit(xy_normalized,labels)</span><br></pre></td></tr></table></figure><p><strong>k最近邻</strong><br>求出(50,5)(30,3)两个点附近最近的5个样本点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 记得归一化</span></span><br><span class="line">nearest = clf.kneighbors([(<span class="number">50</span>/x_diff,<span class="number">5</span>/y_diff),(<span class="number">30</span>/x_diff,<span class="number">3</span>/y_diff)],<span class="number">5</span>,<span class="literal">False</span>)</span><br><span class="line">print(nearest)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[107 136  97  36 148]</span><br><span class="line"> [261 230 365 294 293]]</span><br></pre></td></tr></table></figure><p><strong>分类预测</strong><br>判断两点的类别分别是哪一类：1，2，3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prediction = clf.predict([(<span class="number">50</span>/x_diff,<span class="number">5</span>/y_diff),(<span class="number">30</span>/x_diff,<span class="number">3</span>/y_diff)])</span><br><span class="line">print(prediction)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1 2]</span><br></pre></td></tr></table></figure><p><strong>概率预测</strong><br>给出判断两点的类别的概率分别是多少</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prediction_proba = clf.predict_proba([(<span class="number">50</span>/x_diff,<span class="number">5</span>/y_diff),(<span class="number">30</span>/x_diff,<span class="number">3</span>/y_diff)])</span><br><span class="line">print(prediction_proba)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[1.  0.  0. ]</span><br><span class="line"> [0.  0.6 0.4]]</span><br></pre></td></tr></table></figure><p><strong>准确率打分</strong><br>即给出模型预测的准确性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#用同样的方法生成测试数据</span></span><br><span class="line">x1_test = np.random.normal(<span class="number">50</span>,<span class="number">6</span>,<span class="number">100</span>)</span><br><span class="line">y1_test = np.random.normal(<span class="number">5</span>,<span class="number">0.5</span>,<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">x2_test = np.random.normal(<span class="number">30</span>,<span class="number">6</span>,<span class="number">100</span>)</span><br><span class="line">y2_test = np.random.normal(<span class="number">4</span>,<span class="number">0.5</span>,<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">x3_test = np.random.normal(<span class="number">45</span>,<span class="number">6</span>,<span class="number">100</span>)</span><br><span class="line">y3_test = np.random.normal(<span class="number">2.5</span>,<span class="number">0.5</span>,<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">x_test_val = np.concatenate((x1_test,x2_test,x3_test))</span><br><span class="line">y_test_val = np.concatenate((y1_test,y2_test,y3_test))</span><br><span class="line"></span><br><span class="line">x_test_diff = max(x_test_val) - min(x_test_val)</span><br><span class="line">y_test_diff = max(y_test_val) - min(y_test_val)</span><br><span class="line"></span><br><span class="line">x_test_normalized = x_test_val / x_test_diff</span><br><span class="line">y_test_normalized = y_test_val / y_test_diff</span><br><span class="line"></span><br><span class="line">xy_test_normalized = list(zip(x_test_normalized,y_test_normalized))</span><br><span class="line"></span><br><span class="line">labels_test = [<span class="number">1</span>]*<span class="number">100</span>+[<span class="number">2</span>]*<span class="number">100</span>+[<span class="number">3</span>]*<span class="number">100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">score = clf.score(xy_test_normalized,labels_test)</span><br><span class="line">print(score)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.95</span><br></pre></td></tr></table></figure><p> 参考自<a href="https://www.joinquant.com/view/community/detail/bb850ee76d1cae16cc587f29c4439ebd" target="_blank" rel="noopener">【量化课堂】scikit-learn 之 kNN 分类</a></p><p><strong>本文作者</strong>：Gong Jintao<br><strong>本文地址</strong>： <a href="http://blog.gongjintao.com/2019/07/03/机器学习算法源码之k近邻算法/">http://blog.gongjintao.com/2019/07/03/机器学习算法源码之k近邻算法/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-KD树实现KNN算法&quot;&gt;&lt;a href=&quot;#1-KD树实现KNN算法&quot; class=&quot;headerlink&quot; title=&quot;1. KD树实现KNN算法&quot;&gt;&lt;/a&gt;1. KD树实现KNN算法&lt;/h2&gt;&lt;figure class=&quot;highlight python
      
    
    </summary>
    
      <category term="机器学习" scheme="http://blog.gongjintao.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://blog.gongjintao.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>《统计学习方法》——k近邻算法</title>
    <link href="http://blog.gongjintao.com/2019/07/02/%E3%80%8A%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E3%80%8B%E2%80%94%E2%80%94k%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/"/>
    <id>http://blog.gongjintao.com/2019/07/02/《统计学习方法》——k近邻算法/</id>
    <published>2019-07-02T14:00:19.000Z</published>
    <updated>2019-07-05T03:57:04.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3-1-k近邻算法"><a href="#3-1-k近邻算法" class="headerlink" title="3.1 k近邻算法"></a>3.1 k近邻算法</h1><p>​        <strong>k近邻法（k-nearest neighbor，k-NN）</strong>是一种基本分类与回归方法。k近邻法的<strong>输入</strong>为实例的特征向量，对应于特征空间的点；<strong>输出</strong>为实例的类别，可以取多类。k近邻法假设给定一个训练数据集，其中的实例类别已定。分类时，对新的实例，根据其<strong>k个最近邻的</strong>训练实例的类别，通过<strong>多数表决等方式</strong>进行预测。</p><p>​        算法如下：</p><blockquote><p><em>输入：</em></p><ol><li><p>训练数据集 $T=\left\{\left(x_{1}, y_{1}\right),\left(x_{2}, y_{2}\right), \cdots,\left(x_{N}, y_{N}\right)\right\}$，其中，$x_i \in \mathcal{X} \subseteq \mathrm{R}^{n}$为实例的特证向量，$y_i \in \mathcal{Y} = \{c_1,c_2,\ldots,c_K\}$为实例的类别，$i = 1,2,\ldots,N$; </p></li><li><p>实例特征向量$x$</p></li></ol><p><em>输出：</em> 实例$x$所属的类$y$。</p><p><em>算法步骤：</em></p><ol><li>根据<strong>给定的距离度量</strong>，在训练集 $T$ 中找出与 $x$ 最邻近的 $k$ 个点，涵盖这 $k$ 个点的$x$的邻域记作$N_k(x)$；</li><li>在$N_k(x)$ 中根据分类决策规则 (如多数表决) 决定 $x$ 的类别 $y$：</li></ol><script type="math/tex; mode=display">y=\arg \max _{c_{j}} \sum_{x_{i} \in N_{k}(x)} I\left(y_{i}=c_{j}\right), \quad i=1,2, \cdots, N ; \quad j=1,2, \cdots, K</script><p>$I$为指示函数，即当 $y_i＝c_j$ 时 $I$ 为1，否则 $I$ 为0。</p></blockquote><h1 id="3-2-k近邻模型"><a href="#3-2-k近邻模型" class="headerlink" title="3.2 k近邻模型"></a>3.2 k近邻模型</h1><p>​        k近邻法使用的模型实际上对应于对特征空间的划分。模型由三个基本要素——<strong>距离度量</strong>、<strong>k值的选择</strong>和<strong>分类决策规则</strong>决定。</p><h2 id="3-2-1-模型"><a href="#3-2-1-模型" class="headerlink" title="3.2.1 模型"></a>3.2.1 模型</h2><p>​        特征空间中，对每个训练实例点 $x_i$，距离该点比其他点更近的所有点组成一个区域，叫作<strong>单元（cell）</strong>。每个训练实例点拥有一个单元，所有训练实例点的单元构成对特征空间的一个<strong>划分</strong>。最近邻法将实例 $x_i$的类 $y_i$作为其单元中所有点的$类标记（class label）$。这样，每个单元的实例点的类别是确定的。</p><p><img src="http://ww1.sinaimg.cn/large/005XIOOuly1g4laqg854vj30bo09uabd.jpg" alt="图3.1"></p><h2 id="3-2-2-距离度量"><a href="#3-2-2-距离度量" class="headerlink" title="3.2.2 距离度量"></a>3.2.2 距离度量</h2><p>​        特征空间中两个实例点的距离是两个实例点<strong>相似程度</strong>的反映。k近邻模型的特征空间一般是$n$ 维实数向量空间$\mathrm{R}^n$。使用的距离是<strong>欧氏距离</strong>，但也可以是其他距离，如更一般的<strong>Lp距离（Lp distance）或Minkowski距离（Minkowski distance）</strong>。</p><blockquote><p>$x_{i}=\left(x_{i}^{(1)}, x_{i}^{(2)}, \cdots, x_{i}^{(n)}\right)^{\mathrm{T}} ,x_{j}=\left(x_{j}^{(1)}, x_{j}^{(2)}, \cdots, x_{j}^{(n)}\right)^{\mathrm{T}}$</p><p>$L_p距离定义为$ ：$L_{p}\left(x_{i}, x_{j}\right)=\left(\sum_{l=1}^{n}\left|x_{i}^{(l)}-x_{j}^{(l)}\right|^{p}\right)^{\frac{1}{p}}$</p><p>当 $p=2$ ,则为欧氏距离； </p><p>当 $p = 1$ ，则为曼哈顿距离</p><p>当 $p = \infty$，则是各个坐标距离的最大值，或称切比雪夫距离。</p></blockquote><h2 id="3-2-3-k值的选择"><a href="#3-2-3-k值的选择" class="headerlink" title="3.2.3 k值的选择"></a>3.2.3 k值的选择</h2><p>​        k值的减小就意味着整体模型变得复杂，容易发生过拟合。k值的增大就意味着整体的模型变得简单。在应用中，k值一般取一个比较小的数值。通常采用交叉验证法来选取最优的k值。</p><h2 id="3-2-4-分类决策规则"><a href="#3-2-4-分类决策规则" class="headerlink" title="3.2.4 分类决策规则"></a>3.2.4 分类决策规则</h2><p>​        <strong>多数表决规则（majority voting rule）</strong>有如下解释：如果分类的损失函数为0-1损失函数，分类函数为</p><script type="math/tex; mode=display">f: \mathrm{R}^{n} \rightarrow \{ c_1,c_2,\ldots,c_K\}</script><p>那么误分类的概率是</p><script type="math/tex; mode=display">P(Y \neq f(X)) = 1 - P(Y = f(X))</script><p>对给定的实例$x\in \mathcal{X}$，其最近邻的 k 个训练实例点构成集合$N_k(x)$。如果涵盖$N_k(x)$的区域的类别是$c_j$，那么误分类率是</p><script type="math/tex; mode=display">\frac{1}{k} \sum_{x_{i} \in N_{k}(x)} I\left(y_{i} \neq c_{j}\right)=1-\frac{1}{k} \sum_{x_{i} \in N_{k}(x)} I\left(y_{i}=c_{j}\right)</script><p>要使误分类率最小即经验风险最小，就要使$\sum_{x_{i} \in N_{k}(x)} I\left(y_{i}=c_{j}\right)$最大。</p><h1 id="3-3-k近邻法的实现：kd树"><a href="#3-3-k近邻法的实现：kd树" class="headerlink" title="3.3 k近邻法的实现：kd树"></a>3.3 k近邻法的实现：kd树</h1><p>​        实现k近邻法时，主要考虑的问题是如何对训练数据进行快速k近邻搜索。</p><h2 id="3-3-1-构造kd树"><a href="#3-3-1-构造kd树" class="headerlink" title="3.3.1 构造kd树"></a>3.3.1 构造kd树</h2><p>​        kd树是一种对k维空间中的实例点进行存储以便对其进行快速检索的树形数据结构。kd树是<strong>二叉树</strong>，表示对<strong>k维空间</strong>的一个划分（partition）。构造kd树相当于不断地用垂直于坐标轴的超平面将k维空间切分，构成一系列的k维超矩形区域。kd树的每个结点对应于一个k维超矩形区域。<strong>构造kd树的算法如下：</strong></p><blockquote><p><em>输入：</em>k维空间数据集$T＝\{x_1，x_2,\ldots,x_N\}$,其中 $x_i =\left(x_{i}^{(1)}, x_{i}^{(2)}, \cdots, x_{i}^{(k)}\right)^{\mathrm{T}}, i = 1,2,\ldots,N$;</p><p><em>输出：</em>kd树</p><p><em>算法步骤：</em></p><ol><li><p>选择 $x^{(1)}$ 为坐标轴，以$T$ 中所有实例的 $x^{(1)}$ 坐标的中位数 为切分点，将根结点对应的超矩形区域切分为两个子区域。切分由通过切分点并与坐标轴$x^{(1)}$垂直的超平面实现。由根结点生成深度为 1 的左、右子结点：左子结点对应坐标$x^{(1)}$ 小于切分点的子区域，右子结点对应坐标$x^{(1)}$ 大于切分点的子区域。将落在切分超平面上的实例点保存在根结点。</p></li><li><p>重复：对深度为 j 的结点，按 1 的方法进行切分，只不过是将上标 1 换成 $l, l = j(\mathrm{mod} k) + 1$   </p></li><li>直到两个子区域没有实例存在时停止。从而形成kd树的区域划分。</li></ol></blockquote><h2 id="3-3-2-搜索kd树"><a href="#3-3-2-搜索kd树" class="headerlink" title="3.3.2 搜索kd树"></a>3.3.2 搜索kd树</h2><p>​        用kd树的最近邻搜索算法如下：</p><blockquote><p><em>输入：</em> 1. 已构造的 kd 树；2. 目标点 x；</p><p><em>输出：</em> x 的最近邻。</p><p><em>算法步骤：</em></p><ol><li>在 kd 树中找到包含目标点 x 的叶结点：</li></ol><p>从根结点出发，递归地向下访问kd树。若目标点 x <strong>当前维</strong>的坐标小于切分点的坐标，则移动到左子结点，否则移动到右子结点。直到子结点为叶结点为止。</p><ol><li><p>以此叶结点为“当前最近点”</p></li><li><p>递归地向上回退，在每个结点进行一下操作：</p><ul><li>如果该结点保存的实例点比当前最近点距离目标点更近，则以该实例点为“当前最近点”</li><li>当前最近点一定存在于该结点一个子结点对应的区域。检查该子结点的父结点的另一子结点对应的区域是否有更近的点。如果有则移动到该点，如果没有，向上回退。</li></ul></li><li><p>当回退到根结点时，搜索结束。最后的“当前最近点”即为 x 的最近邻点。</p></li></ol></blockquote><p>​        此处的 $KD$树 仅是找出距离目标点的最近的点，对应k近邻算法中的k=1；如果 k ≥ 2，则可以设置一个 k 维数组用于存储距离目标点最近的 k 个实例。然后用下面这一步代替上面算法步骤中 3 的第一小步。</p><p>当递归到$KD$树的某一结点时，</p><ul><li><p>如果数组长度小于 k，则将该结点添加到数组；</p></li><li><p>如果数组长度等于 k，则比较该节点到目标点的距离与数组中的最大距离，若大于数组中的最大距离，则继续下一步，否则用该结点替换数组中最大距离的那个实例</p><p>具体算法步骤可以参考知乎上这篇文章——<a href="https://zhuanlan.zhihu.com/p/23966698" target="_blank" rel="noopener">kd 树算法之详细篇</a>。</p></li></ul><h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h1><p>​        <strong>3.1</strong> 参照图3.1，在二维空间中给出实例点，画出k为1和2时的k近邻法构成的空间划分，并对其进行比较，体会k值选择与模型复杂度及预测准确率的关系。</p><p>​        <font color="blue">Todo</font></p><p>​        <strong>3.2</strong> 利用例题3.2构造的kd树求点$x＝(3, 4.5)^\mathrm{T}$的最近邻点。</p><p><img src="http://ww1.sinaimg.cn/large/005XIOOuly1g4lrcydze0j30c607ugml.jpg" alt></p><p>​    <strong>解：</strong> </p><ol><li><p>从根结点$(7,2)$出发，向下访问 kd树 ，依次比较$x^{(1)}, x^{(2)},,x^{(1) } $找到包含目标结点$(3,4.5)$ 的叶结点$(4,7)$。以$(4,7)$为“当前最近点”，距离约为 2.69。</p></li><li><p>递归向上回退到$(5,4)$，距$(3,4.5)$约2.06，所以更新“当前最近点”为$(5,4)$</p></li><li><p>以$(3,4.5)$为圆心，到“当前最近点”$(5,4)$距离为半径的圆和以$(5,4)$为父结点的另一个子结点$(2,3)$所在的区域相交，于是移动到$(2,3)$</p></li><li><p>移动到$(2,3)$，发现距离$(3,4.5)$约1.80，于是更新“当前最近点”为(2,3);由于$(2,3)$是叶结点，所以 直接回退</p></li><li><p>回退到根结点$(7,2)$，$(3,4.5)$与根结点距离约为4.72，大于到“当前最近点”的距离；同时以$(3,4.5)$为圆心，以与到“当前最近点”的距离为半径的圆和 根结点的另一个子结点$(9,6)$所在的区域不相交。所以搜索结束，得到最近点$(2,3)$</p></li></ol><p>   <strong>3.3</strong>　参照算法3.3，写出输出为x的k近邻的算法。</p><p><strong>本文作者</strong>：Gong Jintao<br><strong>本文地址</strong>： <a href="http://blog.gongjintao.com/2019/07/02/《统计学习方法》——k近邻算法/">http://blog.gongjintao.com/2019/07/02/《统计学习方法》——k近邻算法/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;3-1-k近邻算法&quot;&gt;&lt;a href=&quot;#3-1-k近邻算法&quot; class=&quot;headerlink&quot; title=&quot;3.1 k近邻算法&quot;&gt;&lt;/a&gt;3.1 k近邻算法&lt;/h1&gt;&lt;p&gt;​        &lt;strong&gt;k近邻法（k-nearest neighbor，k
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://blog.gongjintao.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="《统计学习方法》" scheme="http://blog.gongjintao.com/tags/%E3%80%8A%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>机器学习算法源码之感知机</title>
    <link href="http://blog.gongjintao.com/2019/07/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E6%BA%90%E7%A0%81%E4%B9%8B%E6%84%9F%E7%9F%A5%E6%9C%BA/"/>
    <id>http://blog.gongjintao.com/2019/07/01/机器学习算法源码之感知机/</id>
    <published>2019-07-01T15:09:19.000Z</published>
    <updated>2019-07-02T03:40:10.101Z</updated>
    
    <content type="html"><![CDATA[<h2 id="感知机算法的原始形式："><a href="#感知机算法的原始形式：" class="headerlink" title="感知机算法的原始形式："></a>感知机算法的原始形式：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成数据集</span></span><br><span class="line">data = np.asarray([[<span class="number">3</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">1</span>]])</span><br><span class="line">label = np.asarray([<span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化参数</span></span><br><span class="line">w = np.asarray([<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">b = <span class="number">0</span></span><br><span class="line">learning_rate = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 误分类个数为数据集的长度</span></span><br><span class="line">N = len(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> N &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(data)):</span><br><span class="line">        <span class="comment"># 选取数据</span></span><br><span class="line">        sample = data[i]</span><br><span class="line">        <span class="comment"># 计算损失函数</span></span><br><span class="line">        loss = label[i] * (w.dot(sample.transpose()) + b)</span><br><span class="line">        <span class="keyword">if</span> loss &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 更新参数</span></span><br><span class="line">            w = w + learning_rate * label[i] * sample</span><br><span class="line">            b = b + learning_rate * label[i]</span><br><span class="line">            N = N <span class="keyword">if</span> N==len(data) <span class="keyword">else</span> N+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 误分类个数减1</span></span><br><span class="line">            N -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    print(w,b)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line">plt.scatter(data[:<span class="number">2</span>, <span class="number">0</span>],data[:<span class="number">2</span>, <span class="number">1</span>], marker=<span class="string">'+'</span>)</span><br><span class="line">plt.scatter(data[<span class="number">-1</span>, <span class="number">0</span>],data[<span class="number">-1</span>, <span class="number">1</span>])</span><br><span class="line">line_x = np.arange(<span class="number">0</span>,<span class="number">5</span>,<span class="number">0.01</span>)</span><br><span class="line">line_y = -(w[<span class="number">0</span>] * line_x + b) / w[<span class="number">1</span>]</span><br><span class="line">plt.plot(line_x, line_y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[2 2] 0</span><br><span class="line">[1 1] -1</span><br><span class="line">[0 0] -2</span><br><span class="line">[2 2] -2</span><br><span class="line">[1 1] -3</span><br><span class="line">[1 1] -3</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/005XIOOuly1g4l9cxzs6vj30ae070dfs.jpg" alt></p><h2 id="感知机算法的对偶形式"><a href="#感知机算法的对偶形式" class="headerlink" title="感知机算法的对偶形式"></a>感知机算法的对偶形式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span>  np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入数据集</span></span><br><span class="line">data = np.asarray([[<span class="number">3</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">1</span>]])</span><br><span class="line">label = np.asarray([<span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化参数</span></span><br><span class="line">alpha = np.zeros(<span class="number">3</span>)</span><br><span class="line">b = <span class="number">0</span></span><br><span class="line">learning_rate = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算Gram矩阵</span></span><br><span class="line">G = np.asarray([[x.dot(y) <span class="keyword">for</span> x <span class="keyword">in</span> data  ] <span class="keyword">for</span> y <span class="keyword">in</span> data])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 误分类个数为数据集的长度</span></span><br><span class="line">N = len(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> N &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">for</span> i  <span class="keyword">in</span> range(len(data)):</span><br><span class="line">        sample = data[i]</span><br><span class="line">        loss = label[i]*(np.dot(alpha*label,G[:,i]) + b)</span><br><span class="line">        <span class="keyword">if</span> loss &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 更新参数</span></span><br><span class="line">            alpha[i] = alpha[i] + learning_rate</span><br><span class="line">            b = b + learning_rate * label[i]</span><br><span class="line">            N = N <span class="keyword">if</span> N==len(data) <span class="keyword">else</span> N+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 误分类个数减1</span></span><br><span class="line">            N -= <span class="number">1</span></span><br><span class="line">    print(alpha,b)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 求出 w</span></span><br><span class="line">w = np.dot(data.T,alpha*label)</span><br><span class="line">print(w)</span><br><span class="line">    </span><br><span class="line">%matplotlib inline</span><br><span class="line">plt.scatter(data[:<span class="number">2</span>, <span class="number">0</span>],data[:<span class="number">2</span>, <span class="number">1</span>], marker=<span class="string">'+'</span>)</span><br><span class="line">plt.scatter(data[<span class="number">-1</span>, <span class="number">0</span>],data[<span class="number">-1</span>, <span class="number">1</span>])</span><br><span class="line">line_x = np.arange(<span class="number">0</span>,<span class="number">5</span>,<span class="number">0.01</span>)</span><br><span class="line">line_y = -(w[<span class="number">0</span>] * line_x + b) / w[<span class="number">1</span>]</span><br><span class="line">plt.plot(line_x, line_y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[1. 0. 1.] 0</span><br><span class="line">[1. 0. 2.] -1</span><br><span class="line">[1. 0. 3.] -2</span><br><span class="line">[2. 0. 4.] -2</span><br><span class="line">[2. 0. 5.] -3</span><br><span class="line">[2. 0. 5.] -3</span><br><span class="line">[1. 1.]</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/005XIOOuly1g4l9cy51tjj30ae070dfs.jpg" alt></p><p><strong>本文作者</strong>：Gong Jintao<br><strong>本文地址</strong>： <a href="http://blog.gongjintao.com/2019/07/01/机器学习算法源码之感知机/">http://blog.gongjintao.com/2019/07/01/机器学习算法源码之感知机/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;感知机算法的原始形式：&quot;&gt;&lt;a href=&quot;#感知机算法的原始形式：&quot; class=&quot;headerlink&quot; title=&quot;感知机算法的原始形式：&quot;&gt;&lt;/a&gt;感知机算法的原始形式：&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;tab
      
    
    </summary>
    
      <category term="机器学习" scheme="http://blog.gongjintao.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://blog.gongjintao.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>《统计学习方法》——感知机</title>
    <link href="http://blog.gongjintao.com/2019/07/01/%E3%80%8A%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E3%80%8B%E2%80%94%E2%80%94%E6%84%9F%E7%9F%A5%E6%9C%BA/"/>
    <id>http://blog.gongjintao.com/2019/07/01/《统计学习方法》——感知机/</id>
    <published>2019-07-01T08:59:32.000Z</published>
    <updated>2019-07-05T03:57:25.264Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2-1-感知机模型"><a href="#2-1-感知机模型" class="headerlink" title="2.1 感知机模型"></a>2.1 感知机模型</h1><p><strong>定义</strong>     假设输入空间 （特征空间）是$\mathcal{X}\subseteq R^n$，输出空间是$\mathcal{Y} = \{+1,-1\}$。输入$x \in \mathcal{X}$表示实例的特征向量，对应于输入空间（特征空间）的点；输出$y \in \mathcal{Y}$ 表示实例的类别。由输入空间到输出空间的如下函数</p><script type="math/tex; mode=display">f(x)=\operatorname{sign}(w \cdot x+b)</script><p>称为<strong>感知机</strong>。其中，$w$和$b$为感知机模型参数，$w \in R^n$叫作<strong>权值（weight）或权值向量（weight vector）</strong>，$b\in R$叫作<strong>偏置（bias）</strong>，$w·x$表示$w$和$x$的内积。sign是符号函数。<br>        感知机是一种线性分类模型，属于判别模型。感知机模型的假设空间是定义在特征空间中的所有<strong>线性分类模型（linear classification model）或线性分类器(linear classifier)</strong>，即函数集合$\{f | f(x)=w\cdot x+b\}$。对应于特征空间$R^n$中的一个超平面 $S$，其中$w$是超平面的<strong>法向量</strong>，$b$是超平面的<strong>截距</strong>。这个超平面将特征空间划分为两个部分。位于两部分的点（特征向量）分别被分为正、负两类。</p><p><img src="https://i.loli.net/2019/06/30/5d18a8730c6a837897.png" alt="这里写图片描述"></p><h1 id="2-2-感知机学习策略"><a href="#2-2-感知机学习策略" class="headerlink" title="2.2 感知机学习策略"></a>2.2 感知机学习策略</h1><h2 id="2-2-1-数据集的线性可分性"><a href="#2-2-1-数据集的线性可分性" class="headerlink" title="2.2.1 数据集的线性可分性"></a>2.2.1 数据集的线性可分性</h2><p><strong>定义</strong>   给定一个数据集 $T=\left\{\left(x_{1}, y_{1}\right),\left(x_{2}, y_{2}\right), \cdots,\left(x_{N}, y_{N}\right)\right\}$，其中,$x_i \in \mathcal{X}=R^n, y_i  \in \mathcal{Y}=\{+1,-1\}, \quad i=1,2, \ldots, N$，如果存在某个超平面 $S$</p><script type="math/tex; mode=display">w \cdot x + b=0</script><p>能够将数据集的正实例点和负实例点<strong>完全正确</strong>地划分到超平面的两侧，即对所有 $y_i = +1$ 的实例$i$，有$w·xi+b&gt;0$，对所有 $y_i＝-1$ 的实例 $i$，有 $w·xi+b&lt;0$，则称数据集 $T$ 为<strong>线性可分数据集（linearly separable data set）</strong>；否则，称数据集 $T$ 线性不可分。</p><h2 id="2-2-2-感知机学习策略"><a href="#2-2-2-感知机学习策略" class="headerlink" title="2.2.2 感知机学习策略"></a>2.2.2 感知机学习策略</h2><p>​        感知机确定了一个学习策略，即定义（经验）损失函数并将损失函数极小化，该损失函数即<strong>误分类点到超平面 $S$ 的总距离</strong>。给定训练数据集</p><script type="math/tex; mode=display">T=\left\{\left(x_{1}, y_{1}\right),\left(x_{2}, y_{2}\right), \cdots,\left(x_{N}, y_{N}\right)\right\}</script><p>其中，$x_i \in \mathcal{X}=R^n, y_i  \in \mathcal{Y}=\{+1,-1\}, \quad i=1,2, \ldots, N$。感知机$\operatorname{sign}(w \cdot x+b)$学习的<strong>损失函数</strong>定义为</p><script type="math/tex; mode=display">L(w, b)=-\sum_{x_{i} \in M} y_{i}\left(w \cdot x_{i}+b\right)</script><p>其中$M$为误分类点的集合。这个损失函数就是感知机学习的经验风险函数。感知机学习的策略是在假设空间中选取使损失函数式（4）最小的模型参数$ w,b $，即<strong>感知机模型</strong>。</p><h1 id="2-3-感知机学习算法"><a href="#2-3-感知机学习算法" class="headerlink" title="2.3 感知机学习算法"></a>2.3 感知机学习算法</h1><h2 id="2-3-1-感知机学习算法的原始形式"><a href="#2-3-1-感知机学习算法的原始形式" class="headerlink" title="2.3.1 感知机学习算法的原始形式"></a>2.3.1 感知机学习算法的原始形式</h2><p>感知机学习算法是对以下最优化问题的算法:</p><script type="math/tex; mode=display">\min _{w, b} L(w, b)=-\sum_{x_{i} \in M} y_{i}\left(w \cdot x_{i}+b\right)</script><p>我们采用<strong>随机梯度下降法(stochastic gradient descent)</strong>。算法如下：</p><blockquote><p><em>输入：</em> </p><ol><li>$T=\left\{\left(x_{1}, y_{1}\right),\left(x_{2}, y_{2}\right), \cdots,\left(x_{N}, y_{N}\right)\right\}$，</li></ol><p>其中$x_i \in \mathcal{X}=R^n, y_i  \in \mathcal{Y}=\{+1,-1\}, \quad i=1,2, \ldots, N$</p><ol><li>学习率 $\eta(0&lt;\eta \leqslant1)$</li></ol><p><em>输出：</em> $ w,b;感知机模型 f(x) = \operatorname{sign}(w \cdot x+b) $ 。</p><p><em>算法步骤：</em></p><ol><li>选取初值$w_0,b_0$</li><li>在训练集中选取数据$(x_i,y_i)$</li><li>如果$y_i(w \cdot x_i + b) \leqslant 0$</li></ol><script type="math/tex; mode=display">w \leftarrow w + \eta y_ix_i\\b \leftarrow b + \eta y_i</script><ol><li>转至 2 ，直至训练集中没有误分类点。</li></ol></blockquote><h2 id="2-3-2-算法的收敛性"><a href="#2-3-2-算法的收敛性" class="headerlink" title="2.3.2 算法的收敛性"></a>2.3.2 算法的收敛性</h2><p>​        对于线性可分数据集感知机学习算法原始形式收敛，即经过<strong>有限次</strong>迭代可以得到一个将训练数据集完全正确划分的分离超平面及感知机模型。所以只需证明迭代次数$k$有上界即可。</p><h2 id="2-3-3-感知机学习算法的对偶形式"><a href="#2-3-3-感知机学习算法的对偶形式" class="headerlink" title="2.3.3 感知机学习算法的对偶形式"></a>2.3.3 感知机学习算法的对偶形式</h2><p>​        对偶形式的基本想法是，将$w$和$b$表示为实例$x_i$和标记$y_i$的线性组合的形式，通过求解其系数而求得$w$和$b$。设初始值$w_0=0,b_0=0$，误分类点$(x_i,y_i)$在更新过程中被使用的<strong>次数为$ n_i $，</strong>则最后学习到的$w和b$可以分别表示为</p><script type="math/tex; mode=display">w = \sum_{i=1}^{N}\alpha_i y_i x_i\\b = \sum_{i=1}^{N} \alpha_i y_i</script><p>其中，$\alpha_i = n_i \eta i= 1,2,\ldots,N$。<strong>实例点更新次数越多，意味着它距离分离超平面越近</strong>，也就越难正确分类。感知机学习算法的对偶形式具体如下：</p><blockquote><p><em>输入：</em> </p><ol><li>$T=\left\{\left(x_{1}, y_{1}\right),\left(x_{2}, y_{2}\right), \cdots,\left(x_{N}, y_{N}\right)\right\}$，</li></ol><p>其中$x_i \in \mathcal{X}=R^n, y_i  \in \mathcal{Y}=\{+1,-1\}, \quad i=1,2, \ldots, N$</p><ol><li>学习率 $\eta(0&lt;\eta \leqslant1)$</li></ol><p><em>输出：</em> $ \alpha ,b; 感知机模型 f(x) =\operatorname{sign}\left(\sum_{j=1}^{N} \alpha_{j} y_{j} x_{j} \cdot x+b\right), 其中a = (a_1,a_2,\ldots,a_N)^{\mathrm{T}}$</p><p><em>算法步骤：</em></p><ol><li><p>$a \leftarrow 0, b \leftarrow 0 $</p></li><li><p>在训练集中选取数据$(x_i,y_i)$</p></li><li><p>如果$y_{i}\left(\sum_{j=1}^{N} \alpha_{j} y_{j} x_{j} \cdot x_{i}+b\right) \leqslant 0$</p><script type="math/tex; mode=display">\begin{array}{c}{\alpha_{i} \leftarrow \alpha_{i}+\eta} \\ {b \leftarrow b+\eta y_{i}}\end{array}</script></li><li><p>转至2直到没有误分类数据。</p></li></ol></blockquote><p>​        对偶形式中可知训练实例仅以内积的形式出现。可以预先将训练集中实例间的内积计算出来并以矩阵的形式存储，这个矩阵就是所谓的<strong>Gram矩阵（Gram matrix）</strong>。</p><script type="math/tex; mode=display">G=\left[x_{i} \cdot x_{j}\right]_{N \times N}</script><h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h1><p>​        <strong>2.1</strong>　Minsky与Papert指出：感知机因为是线性模型，所以不能表示复杂的函数，如异或（XOR）。验证感知机为什么不能表示异或。</p><p>​        <strong>解：</strong>异或函数(XOR)表示如下：            </p><div class="table-container"><table><thead><tr><th style="text-align:center">$x_{1}$</th><th style="text-align:center">$x_{2}$</th><th style="text-align:center">$x_{1} \oplus x_{2}$</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr></tbody></table></div><p>​            在图中展示如下：</p><p>​            <img src="http://ww1.sinaimg.cn/large/005XIOOuly1g4kfyxt43tj30jg0elmx0.jpg" alt="异或图示"></p><p>​            显然异或的数据集是线性不可分的，我们无法用一条直线将两类样本划分，所以感知机不能表示异或。</p><p>​        <strong>2.2</strong>　模仿例题2.1，构建从训练数据集求解感知机模型的例子。</p><p>​            <a href="[https://blog.gongjintao.com/2019/07/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E6%BA%90%E7%A0%81%E4%B9%8B%E6%84%9F%E7%9F%A5%E6%9C%BA/](https://blog.gongjintao.com/2019/07/01/机器学习算法源码之感知机/">参考此文</a>)</p><p>​        <strong>2.3</strong>　证明以下定理：样本集线性可分的充分必要条件是正实例点集所构成的凸壳与负实例点集所构成的凸壳互不相交。</p><p>​        <font color="blue">Todo</font></p><p><strong>本文作者</strong>：Gong Jintao<br><strong>本文地址</strong>： <a href="http://blog.gongjintao.com/2019/07/01/《统计学习方法》——感知机/">http://blog.gongjintao.com/2019/07/01/《统计学习方法》——感知机/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2-1-感知机模型&quot;&gt;&lt;a href=&quot;#2-1-感知机模型&quot; class=&quot;headerlink&quot; title=&quot;2.1 感知机模型&quot;&gt;&lt;/a&gt;2.1 感知机模型&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;     假设输入空间 （特征空间）是$\ma
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://blog.gongjintao.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="《统计学习方法》" scheme="http://blog.gongjintao.com/tags/%E3%80%8A%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《统计学习方法》——概论</title>
    <link href="http://blog.gongjintao.com/2019/06/30/%E3%80%8A%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E3%80%8B%E2%80%94%E2%80%94%E6%A6%82%E8%AE%BA/"/>
    <id>http://blog.gongjintao.com/2019/06/30/《统计学习方法》——概论/</id>
    <published>2019-06-30T09:23:10.000Z</published>
    <updated>2019-07-05T03:57:32.411Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-1-统计学习"><a href="#1-1-统计学习" class="headerlink" title="1.1 统计学习"></a>1.1 统计学习</h1><blockquote><p><strong>定义</strong>：统计学习（statistical learning）是关于计算机基于数据构建概率统计模型并运用模型对数据进行预测与分析的一门学科。统计学习也称为统计机器学习（statistical machine learning）。</p></blockquote><a id="more"></a><h2 id="1-1-1-特点"><a href="#1-1-1-特点" class="headerlink" title="1.1.1 特点"></a>1.1.1 特点</h2><blockquote><ol><li>建立在计算机及网络之上的</li><li>以数据为研究对象</li><li>目的是对数据进行预测与分析</li><li>以方法为中心</li><li>包含了概率论、统计学、信息论、计算理论、最优化理论及计算机科学等多个领域，并且在发展中逐步形成独自的理论体系与方法论。</li></ol></blockquote><h2 id="1-1-2-对象"><a href="#1-1-2-对象" class="headerlink" title="1.1.2  对象"></a>1.1.2  对象</h2><blockquote><p>​        统计学习的对象是数据（data）。它从数据出发，提取数据的特征，抽象出数据的模型，发现数据中的知识，又回到对数据的分析与预测中去。</p><p>​        统计学习关于数据的基本假设是同类数据具有一定的统计规律性，这是统计学习的前提。由于它们具有统计规律性，所以可以用概率统计方法来加以处理。比如，可以用随机变量描述数据中的特征，用概率分布描述数据的统计规律。</p><p>​        在统计学习过程中，以变量或变量组表示数据。数据分为由连续变量和离散变量表示的类型。</p></blockquote><h2 id="1-1-3-目的"><a href="#1-1-3-目的" class="headerlink" title="1.1.3 目的"></a>1.1.3 目的</h2><blockquote><p>​        统计学习总的目标就是考虑学习什么样的模型和如何学习模型，以使模型能对数据进行准确的预测与分析，同时也要考虑尽可能地提高学习效率。</p></blockquote><h2 id="1-1-4-方法"><a href="#1-1-4-方法" class="headerlink" title="1.1.4 方法"></a>1.1.4 方法</h2><blockquote><p><em>统计学习包括：</em></p><ol><li>监督学习(supervised learning)</li><li>非监督学习(unsupervised learning)</li><li>半监督学习(semi-supervised learning)</li><li>强化学习(reinforcement learning)</li></ol><p>监督学习的方法可以概括成：从给定的、有限的、用于学习的<strong>训练数据(training data)集合</strong>出发，假设数据是<strong>独立同分布</strong>产生的；并且假设要学习的模型属于某个函数的集合，称为<strong>假设空间(hypothesis space)</strong>；应用某个<strong>评价准则(evaluation criterion)</strong>，从假设空间中选取一个<strong>最优的模型</strong>，使它对已知训练数据及<strong>未知测试数据(test data)</strong>在给定的评价准则下有最优的预测；最优模型的选取由<strong>算法</strong>实现。所以统计学习方法的三要素，分别为<strong>模型（model）、策略（strategy）和算法（algorithm）</strong>。</p><p><em>实现统计学习方法的步骤如下：</em></p><ol><li>得到一个有限的<strong>训练数据集合</strong>；</li><li>确定包含所有可能的模型的<strong>假设空间</strong>，即学习模型的集合；</li><li>确定模型选择的准则，即学习的<strong>策略</strong>；</li><li>实现求解最优模型的算法，即学习的<strong>算法</strong>；</li><li>通过学习方法选择最优模型；</li><li>利用学习的最优模型对新数据进行<strong>预测或分析</strong>。</li></ol><p><em>监督学习的主要应用问题：</em></p><ul><li>分类问题</li><li>标注问题</li><li>回归问题</li></ul></blockquote><h2 id="1-1-5-研究"><a href="#1-1-5-研究" class="headerlink" title="1.1.5 研究"></a>1.1.5 研究</h2><blockquote><p>统计学习研究一般包括<strong>统计学习方法（statistical learning method）、统计学习理论（statistical learning theory）及统计学习应用（application of statistical learning）</strong>三个方面。</p><ul><li>统计学习方法：开发新的学习方法</li><li>统计学习理论：探求统计学习方法的有效性与效率，以及统计学习的基本理论问题</li><li>统计学习应用：考虑将统计学习方法应用到实际问题中去，解决实际问题</li></ul></blockquote><h2 id="1-1-6-重要性"><a href="#1-1-6-重要性" class="headerlink" title="1.1.6 重要性"></a>1.1.6 重要性</h2><blockquote><ol><li>统计学习是处理海量数据的有效方法。</li><li>统计学习是计算机智能化的有效手段。</li><li>统计学习是计算机科学发展的一个重要组成部分。</li></ol></blockquote><h1 id="1-2-监督学习"><a href="#1-2-监督学习" class="headerlink" title="1.2 监督学习"></a>1.2 监督学习</h1><h2 id="1-2-1-基本概念"><a href="#1-2-1-基本概念" class="headerlink" title="1.2.1 基本概念"></a>1.2.1 基本概念</h2><blockquote><ol><li><strong>输入空间（input space）</strong>: 输入的所有可能取值的集合。</li><li><strong>输出空间（output space）</strong>: 输出的所有可能 取值的集合。</li><li><strong>特征空间（feature space）</strong>：每个具体的输入是一个<strong>实例（instance）</strong>，通常由<strong>特征向量（feature vector）</strong>表示。这时，所有特征向量存在的空间称为<strong>特征空间（feature space）</strong>。<font color="blue">模型实际上都是定义在特征空间上的</font>。</li></ol><p><em>根据输入、输出变量的不同类型，对预测任务给予不同的名称：</em></p><ul><li>均为连续变量：回归问题</li><li>输出变量为有限个离散变量：分类问题</li><li>均为变量序列：标注问题</li></ul><ol><li><strong>联合概率分布</strong>: 监督学习假设输入与输出的随机变量 X 和 Y 遵循联合概率分布P(X,Y)。P(X,Y)表示分布函数，或分布密度函数。</li><li><strong>假设空间（hypothesis space）</strong>: 监督学习的目的在于学习一个由输入到输出的映射，这一映射由模型来表示。模型属于由输入空间到输出空间的映射的集合，这个集合就是假设空间。</li></ol><p>监督学习的模型可以是概率模型或非概率模型，由条件概率分布P(Y|X)或决策函数（decision function）Y=f(X)表示，随具体学习方法而定。对具体的输入进行相应的输出预测时，写作P(y|x)或Y=f(x)。</p></blockquote><h2 id="1-2-2-问题的形式化"><a href="#1-2-2-问题的形式化" class="headerlink" title="1.2.2 问题的形式化"></a>1.2.2 问题的形式化</h2><p><img src="https://i.loli.net/2019/06/28/5d158c3b1400839934.png" alt="监督学习问题"></p><h1 id="1-3-统计学习三要素"><a href="#1-3-统计学习三要素" class="headerlink" title="1.3 统计学习三要素"></a>1.3 统计学习三要素</h1><blockquote><p>方法 = 模型＋策略 + 算法</p></blockquote><h2 id="1-3-1-模型"><a href="#1-3-1-模型" class="headerlink" title="1.3.1 模型"></a>1.3.1 模型</h2><blockquote><p>在监督学习过程中，模型就是所要学习的条件概率分布或决策函数。模型的假设空间（hypothesis space）包含所有可能的条件概率分布或决策函数。由集合表示如下：</p><script type="math/tex; mode=display">\mathcal{F}=\left\{f | Y=f_{\theta}(X), \theta \in \mathbf{R}^{n}\right\}\\</script><p>或者</p><script type="math/tex; mode=display">\mathcal{F}=\left\{P\left|P_{\theta}(Y | X), \theta \in \mathbf{R}^{n}\right\}\right.</script><p>公式(1)表示定义在决策函数上的集合，公式(2)表示定义在条件概率上的集合。其中$ \theta $ 表示为<strong>参数向量（parameter space）</strong> 。</p></blockquote><h2 id="1-3-2-策略"><a href="#1-3-2-策略" class="headerlink" title="1.3.2 策略"></a>1.3.2 策略</h2><blockquote><p>首先引入损失函数与风险函数的概念。</p><ul><li><p><strong>损失函数(loss function)</strong>度量模型一次预测的好坏，和<strong>代价函数(cost function)</strong>表示的意义相同</p><blockquote><p><strong>常用的损失函数有以下几种：</strong></p><ol><li>0-1损失函数（0-1 loss function）</li></ol><script type="math/tex; mode=display">L(Y, f(X))=\left\{\begin{array}{ll}{1,} & {Y \neq f(X)} \\ {0,} & {Y=f(X)}\end{array}\right.</script><ol><li>平方损失函数（quadratic loss function）</li></ol><script type="math/tex; mode=display">L(Y, f(X))=(Y-f(X))^{2}</script><ol><li>绝对损失函数（absolute loss function）</li></ol><script type="math/tex; mode=display">L(Y, f(X))=|Y-f(X)|</script><ol><li>对数损失函数（logarithmic loss function）或对数似然损失函数</li></ol><script type="math/tex; mode=display">L(Y, P(Y | X))=-\log P(Y | X)</script></blockquote></li><li><p><strong>风险函数(risk function)</strong>度量平均意义下模型预测的好坏，也称为<strong>期望损失（expected loss）</strong>，定义如下：</p><blockquote><script type="math/tex; mode=display">R_{\mathrm{exp}}(f)=E_{P}[L(Y, f(X))]=\int_{\mathcal{X} \times \mathcal{Y}} L(y, f(x)) P(x, y) \mathrm{d} x \mathrm{d} y</script></blockquote></li></ul><p>​        </p><p>​        学习的目标就是选择期望风险最小的模型。但是由于联合分布$P(X,Y)$是未知的，$R_{exp}(f)$不能直接计算。于是引入<strong>经验风险</strong>。</p><ul><li><p><strong>经验风险（empirical risk）</strong>：模型f(X)关于训练数据集的平均损失，也称<strong>经验损失（empirical loss）</strong>；记作$R_{emp}$:</p><blockquote><script type="math/tex; mode=display">R_{\mathrm{emp}}(f)=\frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right)</script></blockquote></li></ul><p>​        </p><p>​        根据大数定律，当样本容量N趋于无穷时，经验风险$R_{emp}f$趋于期望风险$R_{exp}f$。但是，由于现实中训练样本数目有限，甚至很小，所以用经验风险估计期望风险常常并不理想，要对经验风险进行一定的<strong>矫正</strong>。这就关系到监督学习的两个基本策略：<strong>经验风险最小化和结构风险最小化。</strong></p><ul><li><p><strong>经验风险最小化（empirical risk minimization，ERM）</strong>：按照经验风险最小化求最优模型就是求解最优化问题；</p><blockquote><script type="math/tex; mode=display">\min _{f \in \mathcal{F}} \frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right)</script><p>其中，$\mathcal{F}$ 是假设空间。</p></blockquote></li><li><p><strong>结构风险最小化（structural risk minimization，SRM）</strong>：是为了防止过拟合而提出来的策略。结构风险最小化等价于<strong>正则化（regularization）</strong>。结构风险在经验风险上加上表示模型复杂度的<strong>正则化项（regularizer）或罚项（penalty term）</strong>。</p><blockquote><script type="math/tex; mode=display">R_{\mathrm{srm}}(f)=\frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right)+\lambda J(f)</script><p>其中$J(f)$为模型的复杂度，是定义在假设空间 $\mathcal{F}$上的泛函。模型 $f$ 越复杂，复杂度$J(f)$就越大；反之，模型 $f$ 越简单，复杂度$J(f)$就越小。$\lambda \ge 0$是系数，用以权衡经验风险和模型复杂度。所以求最优模型，就是求解最优化问题：</p><script type="math/tex; mode=display">\min _{f \in \mathcal{F}} \frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right)+\lambda J(f)</script></blockquote></li></ul><p>这样，监督学习问题就变成了经验风险或结构风险函数的最优化问题。这时经验或结构风险函数是最优化的<strong>目标函数</strong>。</p></blockquote><h2 id="1-3-3-算法"><a href="#1-3-3-算法" class="headerlink" title="1.3.3 算法"></a>1.3.3 算法</h2><blockquote><p>​        算法是指学习模型的具体计算方法。统计学习基于训练数据集，根据学习策略，从假设空间中选择最优模型，最后需要考虑用什么样的计算方法求解最优模型。这时，统计学习问题归结为最优化问题，统计学习的算法成为求解最优化问题的算法。    </p></blockquote><h1 id="1-4-模型评估与模型选择"><a href="#1-4-模型评估与模型选择" class="headerlink" title="1.4 模型评估与模型选择"></a>1.4 模型评估与模型选择</h1><h2 id="1-4-1-训练误差与测试误差"><a href="#1-4-1-训练误差与测试误差" class="headerlink" title="1.4.1 训练误差与测试误差"></a>1.4.1 训练误差与测试误差</h2><blockquote><p>​        当损失函数给定时，基于损失函数的模型的<strong>训练误差（training error）</strong>和模型的<strong>测试误差（test error）</strong>就自然成为学习方法评估的标准。训练误差的大小，对判断给定的问题是不是一个容易学习的问题是有意义的，但本质上不重要。测试误差反映了学习方法对未知的测试数据集的预测能力，是学习中的重要概念。通常将学习方法对未知数据的预测能力称为<strong>泛化能力（generalization ability）</strong>。</p></blockquote><h2 id="1-4-2-过拟合与模型选择"><a href="#1-4-2-过拟合与模型选择" class="headerlink" title="1.4.2 过拟合与模型选择"></a>1.4.2 过拟合与模型选择</h2><blockquote><p>​        如果一味追求提高对训练数据的预测能力，所选模型的复杂度则往往会比真模型更高。这种现象称为<strong>过拟合（over-fitting）</strong>。过拟合是指学习时选择的模型所包含的参数过多，以致于出现这一模型对已知数据预测得很好，但对未知数据预测得很差的现象。</p></blockquote><h1 id="1-5-正则化与交叉验证"><a href="#1-5-正则化与交叉验证" class="headerlink" title="1.5 正则化与交叉验证"></a>1.5 正则化与交叉验证</h1><h2 id="1-5-1-正则化"><a href="#1-5-1-正则化" class="headerlink" title="1.5.1 正则化"></a>1.5.1 正则化</h2><blockquote><p>​        模型选择的典型方法是<strong>正则化（regularization）</strong>。正则化是结构风险最小化策略的实现，是在经验风险上加一个<strong>正则化项（regularizer）或罚项(penalty term)</strong>。正则化项一般是<strong>模型复杂度的单调递增函数</strong>，模型越复杂，正则化值就越大。比如，正则化项可以是模型参数向量的范数。</p><p>​        正则化一般具有如下形式：</p><script type="math/tex; mode=display">\min _{f \in \mathcal{F}} \frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right)+\lambda J(f)</script><p>其中，第1项是经验风险，第2项是正则化项，$\lambda \ge 0$为调整两者之间关系的系数。</p></blockquote><h2 id="1-5-2-交叉验证"><a href="#1-5-2-交叉验证" class="headerlink" title="1.5.2 交叉验证"></a>1.5.2 交叉验证</h2><blockquote><p>​        如果给定的样本数据<strong>充足</strong>，进行模型选择的一种简单方法是<strong>随机地</strong>将数据集切分成三部分，分别为<strong>训练集（training set）、验证集（validation set）和测试集（test set）</strong>。训练集用来训练模型，验证集用于模型的选择，而测试集用于最终对学习方法的评估。在学习到的不同复杂度的模型中，选择对验证集有最小预测误差的模型。</p><p>​        但是，在许多实际应用中数据是不充足的。为了选择好的模型，可以采用交叉验证方法。<strong>交叉验证的基本想法</strong>是重复地使用数据；把给定的数据进行切分，将切分的数据集组合为训练集与测试集，在此基础上反复地进行训练、测试以及模型选择。</p><p>​        有以下几种常用的交叉验证方法：</p><ol><li><strong>简单交叉验证</strong>：首先随机地将已给数据分为两部分，一部分作为训练集，另一部分作为测试集；然后用训练集在各种条件下训练模型，从而得到不同的模型；在测试集上评价各个模型的测试误差，选出测试误差最小的模型。</li><li><strong>S折交叉验证</strong>：首先随机地将已给数据切分为S个互不相交的大小相同的子集；然后利用S-1个子集的数据训练模型，利用余下的子集测试模型；将这一过程对可能的S种选择重复进行；最后选出S次评测中平均测试误差最小的模型。</li><li><strong>留一交叉验证</strong>：S折交叉验证的特殊情形是S＝N，称为留一交叉验证（leave-one-out cross validation）。往往在数据缺乏的情况下使用。</li></ol></blockquote><h1 id="1-6-泛化能力"><a href="#1-6-泛化能力" class="headerlink" title="1.6 泛化能力"></a>1.6 泛化能力</h1><h2 id="1-6-1-泛化误差"><a href="#1-6-1-泛化误差" class="headerlink" title="1.6.1 泛化误差"></a>1.6.1 泛化误差</h2><blockquote><p>​        现实中采用最多的办法是通过测试误差来评价学习方法的泛化能力。但这种评价是依赖于测试数据集的。因为测试数据集是有限的，很有可能由此得到的评价结果是不可靠的。统计学习理论试图从理论上对学习方法的泛化能力进行分析。</p><p>​        首先给出泛化误差的定义。如果学到的模型是$\hat{f}$，那么用这个模型对未知数据预测的误差即为<strong>泛化误差（generalization error）</strong></p><script type="math/tex; mode=display">R_{\mathrm{exp}}(\hat{f})=E_{P}[L(Y, \hat{f}(X))]=\int_{\mathcal{X} \times \mathcal{Y}} L(y, \hat{f}(x)) P(x, y) \mathrm{d} x \mathrm{d} y</script><p>事实上，泛化误差就是所学习到的模型的期望风险。</p></blockquote><h2 id="1-6-2-泛化误差上界"><a href="#1-6-2-泛化误差上界" class="headerlink" title="1.6.2 泛化误差上界"></a>1.6.2 泛化误差上界</h2><blockquote><p>​        学习方法的泛化能力分析往往是通过研究泛化误差的概率上界进行的，简称为<strong>泛化误差上界（generalization error bound）。</strong>泛化误差上界通常具有以下性质：</p><ul><li>它是样本容量的函数，当样本容量增加时，泛化上界趋于0；</li><li>它是假设空间容量（capacity）的函数，假设空间容量越大，模型就越难学，泛化误差上界就越大。</li></ul><p><strong><font color="red">关于对二类分类问题，泛化误差上界不等式的证明，即证明：</font></strong></p><p>​        当假设空间是有限个函数的集合$\mathcal{F}＝{f_1，f_2,…,f_d}$时，对任意一个函数 $f \in \mathcal{F}$，至少以概率$1-\delta$，以下不等式成立：</p><script type="math/tex; mode=display">R(f) \leqslant \hat{R}(f)+\varepsilon(d, N, \delta)</script><p>其中，</p><script type="math/tex; mode=display">\varepsilon(d, N, \delta)=\sqrt{\frac{1}{2 N}\left(\log d+\log \frac{1}{\delta}\right)}</script><p>需要用到Hoeffding不等式：</p><p>​        设是$S_n = \sum_{i-1}^{n}X_i$是独立随机变量$X_1,X_2,…,X_n$之和，$X_i \in [a_i，b_i ]$，则对任意$t &gt; 0$，以下不等式成立：</p><script type="math/tex; mode=display">\begin{array}{l}{P\left(S_{n}-E S_{n} \geqslant t\right) \leqslant \exp \left(\frac{-2 t^{2}}{\sum_{i=1}^{n}\left(b_{i}-a_{i}\right)^{2}}\right)} \\ {P\left(E S_{n}-S_{n} \geqslant t\right) \leqslant \exp \left(\frac{-2 t^{2}}{\sum_{i=1}^{n}\left(b_{i}-a_{i}\right)^{2}}\right)}\end{array}</script><p><strong>证明：</strong></p><p>​        ∵ 对于任意函数$f \in \mathcal{F}$，$\hat{R}(f)$是 N 个独立的随机变量 $L(Y,f(X))$的样本均值，$R(f)$是随机变量$L(Y,f(X))$的期望值。如果损失函数取值于区间$[0,1]$，即对所有$i$，$[a_i，b_i ]＝[0,1]$，那么由Hoeffding不等式可得：</p><script type="math/tex; mode=display">\begin{aligned} P(R(f)-\hat{R}(f) \geqslant \varepsilon) &= P(E[\sum_{i=1}^{N}L\left(y_i,f(x_i) \right)]- \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right) \geqslant N \cdot\varepsilon) \\& \leqslant \exp \left(\frac{-2 (N \cdot \varepsilon)^{2}}{\sum_{i=1}^{n}\left(b_{i}-a_{i}\right)^{2}}\right)\\ & = \exp \left(\frac{-2 (N \cdot \varepsilon)^{2}}{N}\right)\\& = exp \left( -2N\varepsilon^2\right)\end{aligned}</script><p>由于$\mathcal{F}=\{ f_1,f_2,…,f_d \}$是一个有限集合，故</p><script type="math/tex; mode=display">\begin{aligned}P(\exists f \in \mathcal{F}:R(f)-\hat{R}(f) \geqslant \varepsilon) &=P\left(\bigcup_{f \in \mathcal{F}}\{R(f)-\hat{R}(f) \geqslant \varepsilon\}\right) \\& \leqslant \sum_{f \in \mathcal{F}}P(R(f)-\hat{R}(f) \geqslant \varepsilon) \\& \leqslant d  \exp(-2N\varepsilon^2)\end{aligned}</script><p>或者等价的，对任意$f \in \mathcal{F}$，有</p><script type="math/tex; mode=display">P(R(f)-\hat{R}(f)<\varepsilon) \geqslant 1-d \exp \left(-2 N \varepsilon^{2}\right)</script><p>令</p><script type="math/tex; mode=display">\delta=d \exp \left(-2 N \varepsilon^{2}\right)</script><p>则</p><script type="math/tex; mode=display">P(R(f)<\hat{R}(f)+\varepsilon) \geqslant 1-\delta</script><p>即至少以概率$1-\delta$有$\mathrm{R}(\mathrm{f})&lt;\hat{R}(\mathrm{f})+\mathcal{E}，$其中$\mathcal{E}$由式(18)得到，即为式(15)</p></blockquote><h1 id="1-7-生成模型与判别模型"><a href="#1-7-生成模型与判别模型" class="headerlink" title="1.7 生成模型与判别模型"></a>1.7 生成模型与判别模型</h1><blockquote><p>​        监督学习方法又可以分为<strong>生成方法（generative approach）</strong>和<strong>判别方法（discriminative approach）</strong>。所学到的模型分别称为<strong>生成模型（generative model）</strong>和<strong>判别模型（discriminative model）。</strong></p><p>​        生成方法由数据学习联合概率分布P(X,Y)，然后求出条件概率分布P(Y|X)作为预测的模型，即生成模型。之所以称为生成方法，是因为模型表示了给定输入X产生输出Y的生成关系。典型的生成模型有：朴素贝叶斯法和隐马尔可夫模型。</p><p>​        判别方法由数据直接学习决策函数f(X)或者条件概率分布P(Y|X)作为预测的模型，即判别模型。典型的判别模型包括：k近邻法、感知机、决策树、逻辑斯谛回归模型、最大熵模型、支持向量机、提升方法和条件随机场等</p></blockquote><h1 id="1-8-分类问题"><a href="#1-8-分类问题" class="headerlink" title="1.8 分类问题"></a>1.8 分类问题</h1><blockquote><p>​        分类是监督学习的一个核心问题。在监督学习中，当<strong>输出变量Y取有限个离散值时</strong>，预测问题便成为分类问题。这时，输入变量X可以是离散的，也可以是连续的。监督学习从数据中学习一个分类模型或分类决策函数，称为<strong>分类器</strong>（classifier）。</p><p>​        评价分类器性能的指标一般是<strong>分类准确率（accuracy）</strong>，其定义是：对于给定的测试数据集，分类器正确分类的样本数与总样本数之比。</p><p>​        对于二分类问题常用的评价指标是<strong>精确率（precision）与召回率（recall）</strong>。通常以关注的类为<strong>正类</strong>，其他类为<strong>负类</strong>，分类器在测试数据集上的预测或正确或不正确，4种情况出现的总数分别记作：</p><ul><li>TP——将正类预测为正类数；</li><li>FN——将正类预测为负类数；</li><li>FP——将负类预测为正类数；</li><li>TN——将负类预测为负类数；</li></ul><p>则<strong>精确率</strong>定义为</p><script type="math/tex; mode=display">P = \frac{TP}{TP+FP}</script><p><strong>召回率</strong>定义为</p><script type="math/tex; mode=display">R=\frac{TP}{TP+FN}</script><p>此外，还有$F_1$值，是精确率和召回率的调和均值，即</p><script type="math/tex; mode=display">\frac{1}{F_1} = \frac{1}{2}(\frac{1}{P} + \frac{1}{R}) \\F_{1}=\frac{2 T P}{2 T P+F P+F N}</script><p>精确率和召回率都高时，$F_1$值也会高。</p></blockquote><h1 id="1-9-标注问题"><a href="#1-9-标注问题" class="headerlink" title="1.9 标注问题"></a>1.9 标注问题</h1><blockquote><p>​        标注问题的输入是一个<strong>观测序列</strong>，输出是一个<strong>标记序列或状态序列</strong>。标注问题的目标在于学习一个模型，使它能够对观测序列给出标记序列作为预测。</p><p>​        评价标注模型的指标与评价分类模型的指标一样，常用的有标注准确率、精确率和召回率。其定义与分类模型相同。</p><p>​        标注常用的统计学习方法有：隐马尔可夫模型、条件随机场。</p></blockquote><h1 id="1-10-回归问题"><a href="#1-10-回归问题" class="headerlink" title="1.10 回归问题"></a>1.10 回归问题</h1><blockquote><p>​        回归用于预测输入变量（自变量）和输出变量（因变量）之间的<strong>关系</strong>，特别是当输入变量的值发生变化时，输出变量的值随之发生的变化。回归问题的学习等价于函数拟合：选择一条函数曲线使其很好地拟合已知数据且很好地预测未知数据。</p><p>​        回归问题按照输入变量的个数，分为<strong>一元回归和多元回归</strong>；按照输入变量和输出变量之间关系的类型即模型的类型，分为<strong>线性回归和非线性回归</strong>。</p><p>​        回归学习最常用的损失函数是<strong>平方损失函数</strong>，在此情况下，回归问题可以由著名的<strong>最小二乘法（least squares）</strong>求解。</p></blockquote><h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h1><p>​        <strong>1.1</strong>     说明伯努利模型的极大似然估计以及贝叶斯估计中的统计学习方法三要素。伯努利模型是定义在取值为0与1的随机变量上的概率分布。假设观测到伯努利模型n次独立的数据生成结果，其中k次的结果为1，这时可以用极大似然估计或贝叶斯估计来估计结果为1的概率。</p><p>​        <strong>解：</strong> </p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">极大似然估计</th><th style="text-align:center">贝叶斯估计</th></tr></thead><tbody><tr><td style="text-align:center">模型</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">策略</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">算法</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr></tbody></table></div><p>​                定义随机变量$A$为一次伯努利实验的结果，可知$A$的取值为$\{0,1\}$；</p><p>​                设$P\{A = 1\} = \theta$，则$P\{A = 0\} = 1- \theta$</p><p>​                <strong>极大似然估计</strong></p><p>​                首先得到似然函数：</p><script type="math/tex; mode=display">L(\theta) = \prod_{i=1}^{n}P(A_i)= C_{n}^{k}\theta^k(1-\theta)^{n-k} \\</script><p>​                然后取对数得到对数似然函数：</p><script type="math/tex; mode=display">\ln(L(\theta)) = \ln C_{n}^{k} + k \cdot \ln\theta + (n-k) \cdot \ln(1-\theta)</script><p>​                然后在上式两边对 $\theta$ 求导可得</p><script type="math/tex; mode=display">\frac{\partial \ln(L(\theta))}{\partial \theta} = \frac{k}{\theta} - \frac{n-k}{1-\theta}</script><p>​                令上式等于 0 ， 可得</p><script type="math/tex; mode=display">\theta = \frac{k}{n}</script><p>​                <strong>贝叶斯估计</strong></p><p>​                todo</p><p>​        <strong>1.2 </strong>    通过经验风险最小化推导极大似然估计。证明模型是条件概率分布，当损失函数是对数损失函数时，经验风险最小化等价于极大似然估计。</p><p>​        <strong>证明：</strong> 当模型是条件概率分布，即$\mathcal{F}=\left\{P\left|P_{\theta}(Y | X), \theta \in \mathbf{R}^{n}\right\}\right.$；</p><p>​                    损失函数是对数损失函数时，即$L(Y, P(Y | X))=-\log P(Y | X)$;</p><p>​                    则<strong>经验风险</strong>如下：</p><script type="math/tex; mode=display">\begin{aligned}R_{\mathrm{emp}}(f)=\frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right) & = \frac{1}{N}\sum_{i=1}^{N}L(y_i,P(y_i|x_i))\\&= \frac{1}{N}\sum_{i=1}^{N}-\log P_\theta(y_i|x_i)\\\end{aligned}</script><p>​                    则经验风险最小化为：</p><script type="math/tex; mode=display">\hat{\theta} = arg\min _{P \in \mathcal{F}}\frac{1}{N}\sum_{i=1}^{N}-\log P_\theta(y_i|x_i)\\</script><p>​                    <strong>极大似然法：</strong></p><p>​                    先求似然函数，如下：</p><script type="math/tex; mode=display">L(\theta) = \prod_{i=1}^{N} P_{\theta}\left(y_{i} | x_{i}\right)</script><p>​                    所以极大似然估计为：</p><script type="math/tex; mode=display">\hat{\theta}=arg \max_{P\in \mathcal{F}}  \sum_{i=1}^{N}\log P_{\theta}\left(y_{i} | x_{i}\right)</script><p>等价于：</p><script type="math/tex; mode=display">\hat{\theta}=arg \min_{P\in \mathcal{F}}  \sum_{i=1}^{N}-\log P_{\theta}\left(y_{i} | x_{i}\right)</script><p>​                因此证得模型是条件概率分布，当损失函数是对数损失函数时，经验风险最小化等价于极大似然估计。</p><p><strong>本文作者</strong>：Gong Jintao<br><strong>本文地址</strong>： <a href="http://blog.gongjintao.com/2019/06/30/《统计学习方法》——概论/">http://blog.gongjintao.com/2019/06/30/《统计学习方法》——概论/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-1-统计学习&quot;&gt;&lt;a href=&quot;#1-1-统计学习&quot; class=&quot;headerlink&quot; title=&quot;1.1 统计学习&quot;&gt;&lt;/a&gt;1.1 统计学习&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;：统计学习（statistical learning）是关于计算机基于数据构建概率统计模型并运用模型对数据进行预测与分析的一门学科。统计学习也称为统计机器学习（statistical machine learning）。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://blog.gongjintao.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="《统计学习方法》" scheme="http://blog.gongjintao.com/tags/%E3%80%8A%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的数组迭代方法总结 </title>
    <link href="http://blog.gongjintao.com/2019/06/30/javascript%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E8%BF%AD%E4%BB%A3%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.gongjintao.com/2019/06/30/javascript中的数组迭代方法总结/</id>
    <published>2019-06-30T01:28:11.368Z</published>
    <updated>2019-06-30T02:57:49.502Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ECMAScript-5中的数组迭代方法总结"><a href="#ECMAScript-5中的数组迭代方法总结" class="headerlink" title="ECMAScript 5中的数组迭代方法总结"></a><em>ECMAScript 5</em>中的数组迭代方法总结</h1><p>在 <strong><em>ECMAscript 5</em></strong> 中为数组定义了5个迭代方法，每个方法都接收两个参数：<a id="more"></a></p><blockquote><ol><li>要在每一项上运行的函数,该函数可接受三个参数(<em>通常只需要第一个参数值，后面两个可以忽略</em>)：<ul><li>数组项的值: <em>item</em></li><li>该项在数组中的位置: <em>index</em></li><li>数组对象本身: <em>array</em></li></ul></li><li>运行调用函数(第一个参数)的作用域对象，为可选参数。如果有第二个参数，则调用的函数被看做是第二个参数的方法。也就是说，在调用函数时传递进去的第二个参数作为它的this关键字的值来使用。</li></ol></blockquote><p>下面依次介绍这5个方法的作用和用法：</p><h2 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h2><blockquote><p>对数组中的每一项运行给定函数，如果该函数对每一项都返回<strong>true</strong>，则返回<strong>true</strong>；否则返回<strong>false</strong>。示例如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> everyResult = arr.every(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert(everyResult); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h2 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h2><blockquote><p>对数组中的每一项运行给定函数，如果该函数对任一项返回<strong>true</strong>，则返回<strong>true</strong>；否则返回<strong>false</strong>。示例如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> someResult = arr.some(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert(someResult); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><font color="red"><em> 注意：</em>every()和some()方法较为相似。要区分它们的判断条件。前者需全部满足才返回true，后者只需一项满足即可。</font><h2 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h2><blockquote><p>对数组中的每一项运行给定函数，返回该函数会返回<strong>true</strong>的项组成的数组。示例如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> filterResult = arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert(filterResult);    <span class="comment">//[3,4,5,4,3]</span></span><br></pre></td></tr></table></figure><h2 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h2><blockquote><p>对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。示例如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mapResult = arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (item*<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert(mapResult);   <span class="comment">//[2,4,6,8,10,8,6,4,2]</span></span><br></pre></td></tr></table></figure><font color="red"> <em>注意：</em> filter()和map()返回的都是新的数组，但不改变原数组的值。</font><h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h2><blockquote><p>对数组中的每一项运行给定函数，这个函数没有返回值,本质上与使用for循环迭代数组一样。示例如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">arr.forEach( <span class="function"><span class="keyword">function</span>(<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 执行某些操作</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'index:'</span>+index+<span class="string">' item:'</span>+item);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><blockquote><p>数组对象是javascript中常用的类型，要熟悉数组的各种方法，需在平常开发中反复练习并理解记忆。</p></blockquote><p><strong>本文作者</strong>：Gong Jintao<br><strong>本文地址</strong>： <a href="http://blog.gongjintao.com/2019/06/30/javascript中的数组迭代方法总结/">http://blog.gongjintao.com/2019/06/30/javascript中的数组迭代方法总结/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ECMAScript-5中的数组迭代方法总结&quot;&gt;&lt;a href=&quot;#ECMAScript-5中的数组迭代方法总结&quot; class=&quot;headerlink&quot; title=&quot;ECMAScript 5中的数组迭代方法总结&quot;&gt;&lt;/a&gt;&lt;em&gt;ECMAScript 5&lt;/em&gt;中的数组迭代方法总结&lt;/h1&gt;&lt;p&gt;在 &lt;strong&gt;&lt;em&gt;ECMAscript 5&lt;/em&gt;&lt;/strong&gt; 中为数组定义了5个迭代方法，每个方法都接收两个参数：
    
    </summary>
    
      <category term="Web前端" scheme="http://blog.gongjintao.com/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://blog.gongjintao.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>CCF认证题库201712-2————游戏</title>
    <link href="http://blog.gongjintao.com/2019/06/30/CCF%E8%AE%A4%E8%AF%81%E9%A2%98%E5%BA%93201712-2%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E6%B8%B8%E6%88%8F/"/>
    <id>http://blog.gongjintao.com/2019/06/30/CCF认证题库201712-2————游戏/</id>
    <published>2019-06-30T01:28:11.244Z</published>
    <updated>2019-06-30T02:52:04.116Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><blockquote><p>　有n个小朋友围成一圈玩游戏，小朋友从1至n编号，2号小朋友坐在1号小朋友的顺时针方向，3号小朋友坐在2号小朋友的顺时针方向，……，1号小朋友坐在n号小朋友的顺时针方向。<br>游戏开始，从1号小朋友开始顺时针报数，接下来每个小朋友的报数是上一个小朋友报的数加1。若一个小朋友报的数为k的倍数或其末位数（即数的个位）为k，则该小朋友被淘汰出局，不再参加以后的报数。当游戏中只剩下一个小朋友时，该小朋友获胜。<a id="more"></a><br>例如，当n=5, k=2时：<br>　　1号小朋友报数1；<br>　　2号小朋友报数2淘汰；<br>　　3号小朋友报数3；<br>　　4号小朋友报数4淘汰；<br>　　5号小朋友报数5；<br>　　1号小朋友报数6淘汰；<br>　　3号小朋友报数7；<br>　　5号小朋友报数8淘汰；<br>　　3号小朋友获胜。<br>　　给定n和k，请问最后获胜的小朋友编号为多少？</p></blockquote><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><blockquote><p>　　输入一行，包括两个整数n和k，意义如题目所述。</p></blockquote><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><blockquote><p>　　输出一行，包含一个整数，表示获胜的小朋友编号。</p></blockquote><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>5 2</p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>3</p></blockquote><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>7 3</p></blockquote><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>4</p></blockquote><h3 id="数据规模和约定"><a href="#数据规模和约定" class="headerlink" title="数据规模和约定"></a>数据规模和约定</h3><blockquote><p>对于所有评测用例，1 ≤ n ≤ 1000，1 ≤ k ≤ 9。</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote><p>可以设置数组初始值为0，淘汰的便设置为1；<br>然后逐步循环；<br>设置判断条件，即数组中0的个数为1，表明只有一个未被淘汰，退出循环汰。</p></blockquote><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>,i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(a[i]==<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        sum++;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum==<span class="number">1</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> n,k,i=<span class="number">0</span>,data=<span class="number">1</span>;</span><br><span class="line">   <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">   <span class="keyword">int</span> arr[n];</span><br><span class="line">   <span class="built_in">memset</span>(arr,<span class="number">0</span>,n);</span><br><span class="line">   <span class="keyword">while</span>(check(arr,n))</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span>(arr[i]==<span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">       data++;</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="keyword">if</span>(data%k==<span class="number">0</span>||data%<span class="number">10</span>==k)</span><br><span class="line">     &#123;</span><br><span class="line">      arr[i]=<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">      i++;</span><br><span class="line">      <span class="keyword">if</span>(i==n)</span><br><span class="line">     &#123;</span><br><span class="line">       i=<span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">     <span class="keyword">if</span>(arr[i]==<span class="number">0</span>)&#123;</span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;i+<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声明：菜鸟拙见，大神勿喷"><a href="#声明：菜鸟拙见，大神勿喷" class="headerlink" title="(声明：菜鸟拙见，大神勿喷)"></a><font color="red" size="4" face="宋体">(声明：菜鸟拙见，大神勿喷)</font></h2><p><strong>本文作者</strong>：Gong Jintao<br><strong>本文地址</strong>： <a href="http://blog.gongjintao.com/2019/06/30/CCF认证题库201712-2————游戏/">http://blog.gongjintao.com/2019/06/30/CCF认证题库201712-2————游戏/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;　有n个小朋友围成一圈玩游戏，小朋友从1至n编号，2号小朋友坐在1号小朋友的顺时针方向，3号小朋友坐在2号小朋友的顺时针方向，……，1号小朋友坐在n号小朋友的顺时针方向。&lt;br&gt;游戏开始，从1号小朋友开始顺时针报数，接下来每个小朋友的报数是上一个小朋友报的数加1。若一个小朋友报的数为k的倍数或其末位数（即数的个位）为k，则该小朋友被淘汰出局，不再参加以后的报数。当游戏中只剩下一个小朋友时，该小朋友获胜。
    
    </summary>
    
      <category term="CCF试题库" scheme="http://blog.gongjintao.com/categories/CCF%E8%AF%95%E9%A2%98%E5%BA%93/"/>
    
    
      <category term="C/C++" scheme="http://blog.gongjintao.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>CCF认证题库201403-4————无线网络</title>
    <link href="http://blog.gongjintao.com/2019/03/03/CCF%E8%AE%A4%E8%AF%81%E9%A2%98%E5%BA%93201403-4%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C/"/>
    <id>http://blog.gongjintao.com/2019/03/03/CCF认证题库201403-4————无线网络/</id>
    <published>2019-03-03T11:27:46.000Z</published>
    <updated>2019-06-30T03:04:33.998Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><blockquote><p>　目前在一个很大的平面房间里有 n 个无线路由器，每个无线路由器都固定在某个点上。任何两个无线路由器只要距离不超过 r 就能互相建立网络连接。<br>　　除此以外，另有 m 个可以摆放无线路由器的位置。你可以在这些位置中选择至多 k 个增设新的路由器。<br>　　你的目标是使得第 1 个路由器和第 2 个路由器之间的网络连接经过尽量少的中转路由器。请问在最优方案下中转路由器的最少个数是多少？</p></blockquote><a id="more"></a><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><blockquote><p>　第一行包含四个正整数 n,m,k,r。(2 ≤ n ≤ 100,1 ≤ k ≤ m ≤ 100, 1 ≤ r ≤ 108)。<br>　　接下来 n 行，每行包含两个整数 xi 和 yi, 表示一个已经放置好的无线 路由器在 (xi, yi) 点处。输入数据保证第 1 和第 2 个路由器在仅有这 n 个路由器的情况下已经可以互相连接 (经过一系列的中转路由器)。<br>　　接下来 m 行，每行包含两个整数 xi 和 yi, 表示 (xi, yi) 点处可以增设 一个路由器。<br>　　输入中所有的坐标的绝对值不超过 108, 保证输入中的坐标各不相同。</p></blockquote><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><blockquote><p>输出只有一个数，即在指定的位置中增设 k 个路由器后，从第 1 个路 由器到第 2 个路由器最少经过的中转路由器的个数。</p></blockquote><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>5 3 1 3<br>0 0<br>5 5<br>0 3<br>0 5<br>3 5<br>3 3<br>4 4<br>3 0</p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>2</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote><p>此题属于求最短路，可以用 BFS (广度优先搜索) 快速方便解出，因为从顶点出发，层序遍历时，最优先到达终点的路径就是最短路径。需要注意的是，增设的路由器只有  k 个，所有对每个点进行遍历时，需要对 k 进行判断。但不是设一个全局的 cnt 来表示增设的路由器，应该是这条路径上的增设的路由器个数，因为如果设全局，即便不在该路径上，但只要遍历到了增设位置， cnt 就会加 1，使得判断失误。所以应该对每个顶点结果体设一个单独的 cnt，用来累计从起点一直到当前点所增设的路由器个数。</p></blockquote><h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">201</span>; <span class="comment">// 最大点数 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dot</span>&#123;</span></span><br><span class="line">ll x, y; <span class="comment">// 点的坐标</span></span><br><span class="line"><span class="keyword">int</span> level; <span class="comment">// 层次，用来计算路径长度</span></span><br><span class="line"><span class="keyword">bool</span> flag; <span class="comment">// 用于判断点是否是新增的点 </span></span><br><span class="line"><span class="keyword">int</span> cnt; <span class="comment">// 用于累计从起点到当前点增设的路由器的个数</span></span><br><span class="line">&#125;Dot[MAXN];</span><br><span class="line"><span class="comment">// 原来路由器个数，另有m个可以摆放路由器的位置，可以增设的路由器个数, 半径 </span></span><br><span class="line"><span class="keyword">int</span> n, m, k, r;</span><br><span class="line"><span class="comment">// 图 </span></span><br><span class="line"><span class="keyword">int</span> G[MAXN][MAXN];</span><br><span class="line"><span class="comment">// 是否被访问 </span></span><br><span class="line"><span class="keyword">bool</span> vis[MAXN] = &#123;<span class="literal">false</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断两点是否可达 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">inRange</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">pow</span>(Dot[u].x-Dot[v].x, <span class="number">2</span>) + <span class="built_in">pow</span>(Dot[u].y-Dot[v].y, <span class="number">2</span>) &lt;= <span class="built_in">pow</span>(r, <span class="number">2</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> st, <span class="keyword">int</span> ed)</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q; </span><br><span class="line">q.push(st);</span><br><span class="line">Dot[st].level = <span class="number">0</span>; <span class="comment">// 初始化顶点层次为 0 </span></span><br><span class="line">Dot[st].cnt = <span class="number">0</span>; <span class="comment">// 初始化访问顶点时，增设点数为 0 </span></span><br><span class="line">vis[st] = <span class="literal">true</span>; <span class="comment">// 设置被访问 </span></span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> u = q.front(); <span class="comment">//取出顶点</span></span><br><span class="line">q.pop(); <span class="comment">// 弹出顶点 </span></span><br><span class="line"><span class="keyword">if</span>(u == ed) <span class="keyword">return</span> Dot[u].level - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 总顶点数为 n + m </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= n + m; v++)&#123;</span><br><span class="line"><span class="comment">// 如果 顶点可达 &amp;&amp; 顶点未被访问 </span></span><br><span class="line"><span class="keyword">if</span>( G[u][v] == <span class="number">1</span> &amp;&amp; vis[v] == <span class="literal">false</span> &amp;&amp; Dot[u].cnt &lt;= k) &#123;</span><br><span class="line">vis[v] = <span class="literal">true</span>; </span><br><span class="line">                <span class="comment">// 对增设的路由进行判断，如果当前是增设的路由，则路径上的增设路由加 1，否则不变</span></span><br><span class="line">Dot[v].cnt = (Dot[v].flag) ? Dot[u].cnt+<span class="number">1</span> : Dot[u].cnt; </span><br><span class="line">q.push(v);</span><br><span class="line">Dot[v].level = Dot[u].level + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;r;</span><br><span class="line">    <span class="comment">// 设图的初值均为 0，表示不可达</span></span><br><span class="line">fill(G[<span class="number">0</span>], G[<span class="number">0</span>] + MAXN*MAXN, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n+m; i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;Dot[i].x&gt;&gt;Dot[i].y;</span><br><span class="line"><span class="keyword">if</span>(i &lt;= n) Dot[i].flag = <span class="literal">false</span>;<span class="comment">// 设置是否是增设位置</span></span><br><span class="line"><span class="keyword">else</span> Dot[i].flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= MAXN; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt;= MAXN; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(inRange(i, j)) G[i][j] = G[j][i] = <span class="number">1</span>;<span class="comment">// 如果在半径内，则设为 1 表示两点可达</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> step = BFS(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;step&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声明：菜鸟拙见，大神勿喷"><a href="#声明：菜鸟拙见，大神勿喷" class="headerlink" title="(声明：菜鸟拙见，大神勿喷)"></a><font color="red" size="4" face="宋体">(声明：菜鸟拙见，大神勿喷)</font></h2><p><strong>本文作者</strong>：Gong Jintao<br><strong>本文地址</strong>： <a href="http://blog.gongjintao.com/2019/03/03/CCF认证题库201403-4————无线网络/">http://blog.gongjintao.com/2019/03/03/CCF认证题库201403-4————无线网络/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;　目前在一个很大的平面房间里有 n 个无线路由器，每个无线路由器都固定在某个点上。任何两个无线路由器只要距离不超过 r 就能互相建立网络连接。&lt;br&gt;　　除此以外，另有 m 个可以摆放无线路由器的位置。你可以在这些位置中选择至多 k 个增设新的路由器。&lt;br&gt;　　你的目标是使得第 1 个路由器和第 2 个路由器之间的网络连接经过尽量少的中转路由器。请问在最优方案下中转路由器的最少个数是多少？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="CCF试题库" scheme="http://blog.gongjintao.com/categories/CCF%E8%AF%95%E9%A2%98%E5%BA%93/"/>
    
    
      <category term="C/C++" scheme="http://blog.gongjintao.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>CCF认证题库201312-4————有趣的数</title>
    <link href="http://blog.gongjintao.com/2019/03/01/CCF%E8%AE%A4%E8%AF%81%E9%A2%98%E5%BA%93201312-4%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E6%9C%89%E8%B6%A3%E7%9A%84%E6%95%B0/"/>
    <id>http://blog.gongjintao.com/2019/03/01/CCF认证题库201312-4————有趣的数/</id>
    <published>2019-03-01T02:27:46.000Z</published>
    <updated>2019-06-30T02:56:30.250Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><blockquote><p>我们把一个数称为有趣的，当且仅当：</p><ol><li><p><strong>它的数字只包含 0, 1, 2, 3</strong>，且这四个数字都出现过至少一次。</p></li><li><p>所有的 0 都出现在所有的 1 之前，而所有的 2 都出现在所有的 3 之前。</p></li><li><p>最高位数字不为 0。<br><a id="more"></a>因此，符合我们定义的最小的有趣的数是 2013。除此以外，4 位的有趣的数还有两个：2031 和 2301。<br>请计算恰好有 n 位的有趣的数的个数。由于答案可能非常大，只需要输出答案除以 1000000007 的余数。</p></li></ol></blockquote><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><blockquote><p>输入只有一行，包括恰好一个正整数 n (4 ≤ n ≤ 1000)。</p></blockquote><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><blockquote><p>输出只有一行，包括恰好 n 位的整数中有趣的数的个数除以 1000000007 的余数。</p></blockquote><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>4</p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>3</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote><p>此题采用动态规划的解法。</p><p>由题可知，1 和 3 分别出现在 0 和 2 之后，所以先考虑 0 或 2 的位置，又由于 0 不能摆在最高位，所以先考虑 2 的摆放。在不考虑所有数字都齐的情况下，则共有如下六种合法的状态：</p><ol><li>只含 2；</li><li>只含 2, 0;</li><li>只含 2, 3;</li><li>只含 2, 0, 1;</li><li>只含 2, 0, 3;</li><li>包含 4 种数字。</li></ol><p>用 <code>dp[i][j],j=1,2,3,4,5</code>，来表示长度为<code>i</code>的整数，满足上面的第<code>j</code>号状态的个数。</p><p>如<code>dp[3][1]=1</code>,即长度为 3， 只包含 2 的整数只有 1 个，即<code>222</code>；</p><p>如<code>dp[3][2]=2</code>，即长度为 3， 只包含 2 和 0 的整数有 2 个，因为所有的 2 必须在 3 前面，则只有三种情况，即<code>223,233</code>；</p><p>如<code>dp[4][3]=3</code>，即长度为4，只包含 2 和 3 的整数有 3 个，因为所有的 2 必须在 3 前面，则只有三种情况，即<code>2223,2233,2333</code>；</p><p>…</p><p>所以我们可以推出状态转移方程如下：</p><ol><li><code>dp[i][1]=1</code>;</li><li><code>dp[i][2]=2*dp[i-1][2]+dp[i-1][1]</code>，即位数为 i 且只含2、0的整数<ul><li>可以由位数为 i-1 且只含2、0的整数在末尾添加 0 或 2 所得；</li><li>可以由位数为 i-1 且只含 2 的整数在末尾添加 0 所得。</li></ul></li><li><code>dp[i][3]=dp[i-1][3]+dp[i-1][1]</code>，即位数为 i 且只含 2、3 的整数<ul><li>可以由位数为 i-1 且只含2、3的整数在末尾添加 3 可得；</li><li>可以由为数为 i-1 且只含 2 的整数在末尾添加 3 可得。</li></ul></li><li><code>dp[i][4]=2*dp[i-1][4]+dp[i-1][2]</code>，即位数为 i 且只含 2、0 和 1 的整数<ul><li>可以由位数为 i-1 且只含2、0 和 1 的整数在末尾添加 1 或 2 可得；</li><li>可以由为数为 i-1 且只含 2 或 0 的整数在末尾添加 1 可得。</li></ul></li><li><code>dp[i][5]=2*dp[i-1][5]+dp[i-1][2]+dp[i-1][3]</code>，即位数为 i 且只含 2、0 和 3 的整数<ul><li>可以由位数为 i-1 且只含2、0 和 3 的整数在末尾添加 2 或 3 可得；</li><li>可以由为数为 i-1 且只含 2 或 0 的整数在末尾添加 3 可得。</li><li>可以由为数为 i-1 且只含 2 或 3 的整数在末尾添加 0 可得。</li></ul></li><li><code>dp[i][6]=2*dp[i-1][6]+dp[i-1][4]+dp[i-1][5]</code>，即位数为 i 且包含 4 种数字的整数<ul><li>可以由位数为 i-1 且包含 4 种数字的整数在末尾添加 1 或 3 可得；</li><li>可以由为数为 i-1 且只含 2 、0 和  1 的整数在末尾添加 3 可得;</li><li>可以由为数为 i-1 且只含 2 、0 和  3 的整数在末尾添加 1 可得</li></ul></li></ol></blockquote><h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1002</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[maxn][<span class="number">6</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">dp[i][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">dp[i][<span class="number">2</span>]=(<span class="number">2</span>*dp[i<span class="number">-1</span>][<span class="number">2</span>] % mod + dp[i<span class="number">-1</span>][<span class="number">1</span>]) % mod;</span><br><span class="line">dp[i][<span class="number">3</span>]=(dp[i<span class="number">-1</span>][<span class="number">3</span>] + dp[i<span class="number">-1</span>][<span class="number">1</span>]) % mod;</span><br><span class="line">dp[i][<span class="number">4</span>]=(<span class="number">2</span>*dp[i<span class="number">-1</span>][<span class="number">4</span>] % mod + dp[i<span class="number">-1</span>][<span class="number">2</span>]) % mod;</span><br><span class="line">dp[i][<span class="number">5</span>]=((<span class="number">2</span>*dp[i<span class="number">-1</span>][<span class="number">5</span>] % mod + dp[i<span class="number">-1</span>][<span class="number">2</span>]) % mod + dp[i<span class="number">-1</span>][<span class="number">3</span>]) % mod;</span><br><span class="line">dp[i][<span class="number">6</span>]=((<span class="number">2</span>*dp[i<span class="number">-1</span>][<span class="number">6</span>] % mod + dp[i<span class="number">-1</span>][<span class="number">4</span>]) % mod + dp[i<span class="number">-1</span>][<span class="number">5</span>]) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[n][<span class="number">6</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声明：菜鸟拙见，大神勿喷"><a href="#声明：菜鸟拙见，大神勿喷" class="headerlink" title="(声明：菜鸟拙见，大神勿喷)"></a><font color="red" size="4" face="宋体">(声明：菜鸟拙见，大神勿喷)</font></h2><p><strong>本文作者</strong>：Gong Jintao<br><strong>本文地址</strong>： <a href="http://blog.gongjintao.com/2019/03/01/CCF认证题库201312-4————有趣的数/">http://blog.gongjintao.com/2019/03/01/CCF认证题库201312-4————有趣的数/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;我们把一个数称为有趣的，当且仅当：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;它的数字只包含 0, 1, 2, 3&lt;/strong&gt;，且这四个数字都出现过至少一次。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;所有的 0 都出现在所有的 1 之前，而所有的 2 都出现在所有的 3 之前。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;最高位数字不为 0。&lt;br&gt;
    
    </summary>
    
      <category term="CCF试题库" scheme="http://blog.gongjintao.com/categories/CCF%E8%AF%95%E9%A2%98%E5%BA%93/"/>
    
    
      <category term="C/C++" scheme="http://blog.gongjintao.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>MVC和MVVM模式特点和区别</title>
    <link href="http://blog.gongjintao.com/2019/01/19/MVC%E5%92%8CMVVM%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://blog.gongjintao.com/2019/01/19/MVC和MVVM的区别/</id>
    <published>2019-01-19T08:07:46.000Z</published>
    <updated>2019-06-30T03:04:15.335Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><blockquote><p>MVC 和 MVVM 都是常见的软件架构设计模式（Architectural Pattern），它通过分离关注点来改进代码的组织方式。它们的不同部分是 C(Controller)、VM(View-Model)，而相同的部分则是 MV(Model-View)。</p></blockquote><a id="more"></a><h1 id="2-MVC"><a href="#2-MVC" class="headerlink" title="2. MVC"></a>2. MVC</h1><blockquote><p><strong>M(Model)</strong>：<strong>数据保存层</strong>，用于存储业务的数据，一旦数据发生变化，Model 将发送到相关的 View，用户得到反馈</p><p><strong>V(View)</strong>：<strong>视图层</strong>，用于向用户展示数据，并传送指令到 Controller</p><p><strong>C(Controller)</strong>: <strong>业务逻辑层</strong>，用于完成用户请求的事件，然后通知 Model 改变数据</p></blockquote><p>图示如下：</p><p><img src="http://gjtblog-images.oss-cn-beijing.aliyuncs.com/MVC.jpg" alt="MVC"></p><blockquote><p>MVC 允许在不改变视图的情况下改变视图对用户输入的响应方式，用户对 View 的操作交给了 Controller 处理，在 Controller 中响应 View 的事件调用 Model 的接口对数据进行操作，一旦 Model 发生变化便通知相关视图进行更新。<font color="red">注意：MVC 中也可以直接通过 Controller 接受指令。</font></p></blockquote><h1 id="3-MVVM"><a href="#3-MVVM" class="headerlink" title="3. MVVM"></a>3. MVVM</h1><blockquote><p><strong>M(Model)</strong>：<strong>数据层</strong>，不同于 MVC 中的 Model , MVVM 中的 Model 层只关注数据本身，不关心任何行为。</p><p><strong>V(View)</strong>：<strong>视图层</strong>，用于向用户渲染展示数据</p><p><strong>VM(View-Model)</strong>: <strong>视图逻辑层</strong>，可以实现数据的双向绑定，当 Model 发生变化，ViewModel 就会自动更新；ViewModel 变化，Model 也会更新。View 的变动，自动反映在 ViewModel，而ViewModel 的更新，也会自动引起 View 的变化。</p></blockquote><p>图示如下：</p><p><img src="https://gjtblog-images.oss-cn-beijing.aliyuncs.com/MVVM.jpg" alt="MVVM"></p><blockquote><p>整体来看，比 MVC/MVP 精简了很多，不仅仅简化了业务与界面的依赖，还解决了数据频繁更新，不用操作DOM。因为在 MVVM 中，View 不知道 Model 的存在，ViewModel 和 Model 也察觉不到 View，这种低耦合模式可以使开发过程更加容易，提高应用的可重用性。</p></blockquote><p><strong>本文作者</strong>：Gong Jintao<br><strong>本文地址</strong>： <a href="http://blog.gongjintao.com/2019/01/19/MVC和MVVM的区别/">http://blog.gongjintao.com/2019/01/19/MVC和MVVM的区别/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.概述&quot;&gt;&lt;/a&gt;1.概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;MVC 和 MVVM 都是常见的软件架构设计模式（Architectural Pattern），它通过分离关注点来改进代码的组织方式。它们的不同部分是 C(Controller)、VM(View-Model)，而相同的部分则是 MV(Model-View)。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Web前端" scheme="http://blog.gongjintao.com/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>ECMAScript6学习笔记</title>
    <link href="http://blog.gongjintao.com/2019/01/06/ECMAScript-6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://blog.gongjintao.com/2019/01/06/ECMAScript-6学习笔记/</id>
    <published>2019-01-06T05:12:15.000Z</published>
    <updated>2019-07-01T04:28:49.937Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-变量"><a href="#1-变量" class="headerlink" title="1.变量"></a>1.变量</h3><blockquote><p><strong><code>var</code>声明变量的问题</strong></p><ol><li>可以重复声明变量</li><li>无法限制修改</li><li>没有块级作用域</li></ol><p><strong>ES6中新增了两个新的声明方法 <code>let</code>和<code>const</code></strong></p><ul><li><code>let</code>     不能重复声明，用于声明变量，有块级作用域</li><li><code>const</code>   不能重复声明，用于声明常量，有块级作用域</li></ul></blockquote><h3 id="2-函数"><a href="#2-函数" class="headerlink" title="2.函数"></a>2.函数<a id="more"></a></h3><h4 id="2-1-箭头函数：-gt"><a href="#2-1-箭头函数：-gt" class="headerlink" title="2.1 箭头函数：()=&gt;{}"></a>2.1 <strong>箭头函数</strong>：<code>()=&gt;{}</code></h4><p>&gt;</p><blockquote><ul><li><p>如果只有一个参数，<code>()</code>则可以省略</p></li><li><p>如果只有一个<code>return</code>,<code>{}</code>可以省略</p></li></ul></blockquote><h4 id="2-2-函数的参数"><a href="#2-2-函数的参数" class="headerlink" title="2.2 函数的参数"></a>2.2 <strong>函数的参数</strong></h4><h5 id="2-2-1-参数扩展-展开"><a href="#2-2-1-参数扩展-展开" class="headerlink" title="2.2.1 参数扩展/展开"></a>2.2.1 参数扩展/展开</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//收集参数</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">a,b,...args</span>)</span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">show(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);  <span class="comment">//...arg会接收剩余的参数(3,4,5)，但必须时最后一个位置</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//展开数组</span></span><br><span class="line"><span class="keyword">let</span> arr =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">...arr; <span class="comment">//相当于将arr展开:1,2,3</span></span><br></pre></td></tr></table></figure><h5 id="2-2-2-默认参数"><a href="#2-2-2-默认参数" class="headerlink" title="2.2.2 默认参数"></a>2.2.2 <strong>默认参数</strong></h5><blockquote><p>即参数一开始就有默认值</p></blockquote><h3 id="3-解构赋值"><a href="#3-解构赋值" class="headerlink" title="3.解构赋值"></a>3.解构赋值</h3><blockquote><ol><li><p>左右两边结构必须一样</p></li><li><p>右边必须是个有值的变量</p></li><li><p>生命和赋值不能分开（必须在一句语句中完成）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]; <span class="comment">//数组</span></span><br><span class="line"><span class="keyword">let</span> &#123;a,b,c&#125; = &#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">2</span>, <span class="attr">c</span>:<span class="number">8</span>&#125;;<span class="comment">//json</span></span><br><span class="line"><span class="keyword">var</span> &#123; bar, foo &#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;;<span class="comment">//对象</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h3 id="4-数组"><a href="#4-数组" class="headerlink" title="4.数组"></a>4.数组</h3><h4 id="1-map-一对一的映射"><a href="#1-map-一对一的映射" class="headerlink" title="1. map(一对一的映射)"></a>1. map(一对一的映射)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">12</span>,<span class="number">5</span>,<span class="number">8</span>];</span><br><span class="line"><span class="comment">/*let result = arr.map(function(item)&#123;</span></span><br><span class="line"><span class="comment">    return item*2;</span></span><br><span class="line"><span class="comment">&#125;)*/</span></span><br><span class="line"><span class="keyword">let</span> result = arr.map(<span class="function"><span class="params">item</span>=&gt;</span>item*<span class="number">2</span>);</span><br><span class="line">alert(result); <span class="comment">//输出24,10,16</span></span><br></pre></td></tr></table></figure><h4 id="2-reduce-一堆对一个"><a href="#2-reduce-一堆对一个" class="headerlink" title="2. reduce(一堆对一个)"></a>2. reduce(一堆对一个)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr =[<span class="number">12</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">33</span>];</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//求平均值</span></span><br><span class="line"> <span class="keyword">let</span> result = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">tmp,item,index</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(index!=arr.length<span class="number">-1</span>)&#123; <span class="comment">//不是最后一次运算</span></span><br><span class="line">         <span class="keyword">return</span> tmp+item;</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;<span class="comment">//最后一次运算</span></span><br><span class="line">        <span class="keyword">return</span> (tmp+item)/arr.length;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;)</span><br><span class="line"> alert(result);<span class="comment">//21</span></span><br></pre></td></tr></table></figure><h4 id="3-filter-过滤器"><a href="#3-filter-过滤器" class="headerlink" title="3. filter(过滤器)"></a>3. filter(过滤器)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">var</span> filterResult = arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (item &gt; <span class="number">2</span>);</span><br><span class="line">   &#125;);</span><br><span class="line">   </span><br><span class="line">   alert(filterResult);    <span class="comment">//[3,4,5,4,3]</span></span><br></pre></td></tr></table></figure><h4 id="4-forEach-迭代"><a href="#4-forEach-迭代" class="headerlink" title="4. forEach(迭代)"></a>4. forEach(迭代)</h4> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line"> arr.forEach( <span class="function"><span class="keyword">function</span>(<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">     <span class="comment">// 执行某些操作</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'index:'</span>+index+<span class="string">' item:'</span>+item);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="5-字符串"><a href="#5-字符串" class="headerlink" title="5.字符串"></a>5.字符串</h3><h4 id="5-1-两个新方法"><a href="#5-1-两个新方法" class="headerlink" title="5.1 两个新方法"></a>5.1 两个新方法</h4><blockquote><p><strong>startsWith(用于判断字符串的开头)</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str =<span class="string">'https://www.baidu.com'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(str.startsWith(<span class="string">'https://'</span>))&#123;</span><br><span class="line">    alert(<span class="string">"加密网址"</span>)；</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    alert(<span class="string">"普通网址"</span>)；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>endsWith(用于判断字符串的结尾)</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str=<span class="string">"name.txt"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(str.endsWith(<span class="string">'.txt'</span>))&#123;</span><br><span class="line">    alert(<span class="string">"文本文件"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(str.endsWith(<span class="string">'.jpg'</span>))&#123;</span><br><span class="line">    alert(<span class="string">"JPG图片"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    alert(<span class="string">"其他"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="5-2-模板字符串-用反单引号-来定义字符串"><a href="#5-2-模板字符串-用反单引号-来定义字符串" class="headerlink" title="5.2. 模板字符串(用反单引号`来定义字符串)"></a>5.2. 模板字符串(用反单引号`来定义字符串)</h4><blockquote><ul><li>可以直接将在字符串中解析变量，将变量写在 ${}中；</li><li>可以定义多行字符串</li></ul></blockquote><h3 id="6-面向对象"><a href="#6-面向对象" class="headerlink" title="6.面向对象"></a>6.面向对象</h3><blockquote><ol><li><p><strong>class关键字、构造器和类分开了</strong></p></li><li><p><strong>class里面可以直接加方法</strong></p></li></ol></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">       <span class="keyword">constructor</span>(id,name)&#123;</span><br><span class="line">           <span class="keyword">this</span>.id = id;</span><br><span class="line">           <span class="keyword">this</span>.name =name;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       showName()&#123;</span><br><span class="line">           alert(<span class="keyword">this</span>.name);</span><br><span class="line">       &#125;</span><br><span class="line">       showId()&#123;</span><br><span class="line">           alert(<span class="keyword">this</span>.id);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> u1 =<span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">'Tom'</span>);</span><br><span class="line">   u1.showName();</span><br><span class="line">   u1.showId();</span><br></pre></td></tr></table></figure><blockquote><p><strong>继承</strong></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VipUser</span> <span class="keyword">extends</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(id,name,level)&#123;</span><br><span class="line">        <span class="keyword">super</span>(id,name);</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    showLevel()&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.level);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v1 = <span class="keyword">new</span> VipUser(<span class="number">2</span>,<span class="string">'Jack'</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">v1.showName();</span><br><span class="line">v1.showId();</span><br><span class="line">v1.showLevel();</span><br></pre></td></tr></table></figure><h3 id="7-Promise"><a href="#7-Promise" class="headerlink" title="7.Promise"></a>7.Promise</h3><blockquote><p>所谓 Promise 对象，就是代表了未来某个将要发生的事件（通常是一个异步操作）。它的好处在于，有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="comment">/*异步操作成功*/</span>)&#123;</span><br><span class="line">       resolve(value);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        reject(error);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//操作成功</span></span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//操作失败</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p><strong>利用ajax请求数据</strong></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">                url: <span class="string">'data/abc.txt'</span>,</span></span><br><span class="line"><span class="javascript">                dataType:<span class="string">'json'</span>,</span></span><br><span class="line">                success(arr)&#123;</span><br><span class="line">                    resolve(arr);</span><br><span class="line">                &#125;,</span><br><span class="line">                error(err)&#123;</span><br><span class="line">                    reject(err);</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">        p.then(<span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">'成功了'</span>+arr); </span></span><br><span class="line"><span class="javascript">        &#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">'失败了'</span>+err);</span></span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>利用ajax请求多个数据</strong></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">createPromise</span>(<span class="params">url</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                $.ajax(&#123;</span></span><br><span class="line">                url,</span><br><span class="line"><span class="javascript">                dataType:<span class="string">'json'</span>,</span></span><br><span class="line">                success(arr)&#123;</span><br><span class="line">                    resolve(arr);</span><br><span class="line">                &#125;,</span><br><span class="line">                error(err)&#123;</span><br><span class="line">                    reject(err);</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;)</span><br><span class="line">         &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="javascript">         <span class="built_in">Promise</span>.all([</span></span><br><span class="line"><span class="javascript">             createPromise(<span class="string">'data/abc.txt'</span>),<span class="comment">//也可直接写一个$.ajax(&#123;&#125;),因为其返回的就是一个Promise对象</span></span></span><br><span class="line"><span class="javascript">             createPromise(<span class="string">'data/json.txt'</span>)</span></span><br><span class="line"><span class="javascript">         ]).then(<span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> [res1,res2] = arr;</span></span><br><span class="line">            alert(res1);</span><br><span class="line">            alert(res2);</span><br><span class="line"><span class="javascript">         &#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">             alert(<span class="string">'至少有一个失败了'</span>);</span></span><br><span class="line"><span class="javascript">             <span class="built_in">console</span>.log(err);</span></span><br><span class="line">         &#125;)</span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="8-Generator"><a href="#8-Generator" class="headerlink" title="8.Generator"></a>8.Generator</h3><blockquote><p>首先，可以把它理解成一个函数的内部状态的遍历器，每调用一次，函数的内部状态发生一次改变（可以理解成发生某些事件）。<br>在形式上，Generator 是一个普通函数，但是有两个特征。一是，function 命令与函数名之间有一个星号；二是，函数体内部使用 yield 语句，定义遍历器的每个成员，即不同的内部状态。</p><p><strong>通过yield传参</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">show</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="string">'a'</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> a = <span class="keyword">yield</span>; <span class="comment">//yield可以传参</span></span><br><span class="line">    </span><br><span class="line">            alert(<span class="string">'b'</span>);</span><br><span class="line">            alert(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> gen = show();</span><br><span class="line">        gen.next(<span class="number">12</span>); <span class="comment">//第一个next()传参并没有用，所以这里弹出'a'</span></span><br><span class="line">        gen.next(<span class="number">5</span>);  <span class="comment">//next()传参会传给yield，所以弹出'b'之后，弹出的是5</span></span><br></pre></td></tr></table></figure></p><p><strong>通过yield返回值</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">show</span>(<span class="params">a</span>)</span>&#123;            </span><br><span class="line">            alert(a);</span><br><span class="line">            <span class="keyword">let</span> tmp = a*<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">yield</span> tmp;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> b = tmp+<span class="number">1</span>; <span class="comment">//11</span></span><br><span class="line">            alert(b);</span><br><span class="line">    </span><br><span class="line">             <span class="keyword">yield</span> b;</span><br><span class="line">    </span><br><span class="line">           <span class="keyword">let</span>  c = b*<span class="number">3</span>;<span class="comment">//33</span></span><br><span class="line">            alert(c);</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> gen = show(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">let</span> res1 = gen.next(); <span class="comment">//&#123;value:10,done:false&#125;</span></span><br><span class="line">        <span class="built_in">console</span>.log(res1);</span><br><span class="line">        <span class="keyword">let</span> res2 = gen.next(); <span class="comment">//&#123;value:11，done:false&#125;</span></span><br><span class="line">        <span class="built_in">console</span>.log(res2);</span><br><span class="line">        <span class="keyword">let</span> res3 =gen.next(); <span class="comment">//&#123;value:33，done:true&#125;</span></span><br><span class="line">        <span class="built_in">console</span>.log(res3);</span><br><span class="line">    <span class="built_in">Promise</span>适合一次性读一堆数据的操作，Generator适合有逻辑性的读取的操作</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="9-模块编程"><a href="#9-模块编程" class="headerlink" title="9. 模块编程"></a>9. 模块编程</h3><blockquote><p>在 ES6 中导入模块，使用 </p><ul><li><p><code>import 模块名 from ‘模块标识符’</code></p></li><li><p><code>import &#39;模块标识符&#39;</code> //例如导入css文件</p></li></ul><p>在 ES6 中使用<code>export default</code> 和 <code>export</code> 向外暴露成员</p><font color="red">注意：</font><ul><li><p><code>export default</code>向外暴露的成员，可以用任意变量来接收</p></li><li><p>在一个模块中，<code>export default</code> 只允许向外暴露一次</p></li><li><p>在一个模块中，可以同时使用 <code>export default</code> 和 <code>export</code> 向外暴露成员</p></li><li><p>使用 <code>export</code> 向外暴露的成员，只能使用<code>{}</code>的形式来接受，这种形式叫做<strong>【按需导出】</strong></p></li><li><p>使用<code>export</code> 向外暴露的成员，必须严格按照导出时的名称来接收，可以用 <code>as</code>来起别名</p></li></ul><p>相比在 <strong>node.js</strong> 中是使用<code>var 名称 = require(&#39;模块表示符&#39;)</code>来导入</p><p><strong>ES6</strong>中是用 <code>module.exports</code>和<code>exports</code>来暴露成员</p></blockquote><p><strong>本文作者</strong>：Gong Jintao<br><strong>本文地址</strong>： <a href="http://blog.gongjintao.com/2019/01/06/ECMAScript-6学习笔记/">http://blog.gongjintao.com/2019/01/06/ECMAScript-6学习笔记/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-变量&quot;&gt;&lt;a href=&quot;#1-变量&quot; class=&quot;headerlink&quot; title=&quot;1.变量&quot;&gt;&lt;/a&gt;1.变量&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;var&lt;/code&gt;声明变量的问题&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以重复声明变量&lt;/li&gt;
&lt;li&gt;无法限制修改&lt;/li&gt;
&lt;li&gt;没有块级作用域&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;ES6中新增了两个新的声明方法 &lt;code&gt;let&lt;/code&gt;和&lt;code&gt;const&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;let&lt;/code&gt;     不能重复声明，用于声明变量，有块级作用域&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const&lt;/code&gt;   不能重复声明，用于声明常量，有块级作用域&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;2-函数&quot;&gt;&lt;a href=&quot;#2-函数&quot; class=&quot;headerlink&quot; title=&quot;2.函数&quot;&gt;&lt;/a&gt;2.函数
    
    </summary>
    
      <category term="Web前端" scheme="http://blog.gongjintao.com/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="ES6" scheme="http://blog.gongjintao.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>Vue中的生命周期</title>
    <link href="http://blog.gongjintao.com/2019/01/05/Vue%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://blog.gongjintao.com/2019/01/05/Vue中的生命周期/</id>
    <published>2019-01-05T14:25:24.000Z</published>
    <updated>2019-07-02T03:40:47.117Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-生命周期定义"><a href="#1-生命周期定义" class="headerlink" title="1.生命周期定义"></a>1.生命周期定义</h4><blockquote><p>生命周期是指：从Vue实例创建、运行、到销毁期间，总是伴随着各种事件的发生，这些事件统称为生命周期。</p></blockquote><a id="more"></a><h4 id="2-生命周期钩子"><a href="#2-生命周期钩子" class="headerlink" title="2.生命周期钩子"></a>2.生命周期钩子</h4><blockquote><p>生命周期钩子即生命周期事件的别名</p><p>生命周期钩子 = 生命周期函数 = 生命周期事件</p></blockquote><h4 id="3-生命周期函数分类"><a href="#3-生命周期函数分类" class="headerlink" title="3.生命周期函数分类"></a>3.生命周期函数分类</h4><blockquote><ol><li>创建期间的生命周期函数<ul><li><code>beforeCreate</code> ：实例刚在内存中被创建出来；此时，还没有初始化好 data 和 methods 属性</li><li><code>created</code> : 实例已经在内存中创建好，此时 data 和 methods 已经初始化好了</li><li><code>beforeMount</code>：表示模板已经在内存中编译完成，还没有渲染到页面中去</li><li><code>mounted</code>: 内存中的模板已经真实的挂载到浏览器中的页面中了，用户已经可以看到渲染好的页面了</li></ul></li><li>运行期间的生命周期函数<ul><li><code>beforeUpdate</code> : 状态更新前执行该函数，此时界面还没有被更新，但是数据已经被更新，因此还没有开始重新渲染DOM节点</li><li><code>updated</code>: 实例更新完毕之后调用该函数，页面和data数据已经保持同步了，都是最新的数据，界面已经被重新渲染好了</li></ul></li><li>销毁期间的生命周期函数<ul><li><code>beforeDestroy</code>: 实例销毁之前调用。Vue实例从运行阶段进入了销毁阶段，实例上的data 和 methods ，过滤器，指令等都处于可用阶段还没有被真正销毁</li><li><code>destroyed</code>:Vue实例已经被完全销毁，实例上的data 和 methods，过滤器，指令等都不可用</li></ul></li></ol></blockquote><h4 id="4-生命周期函数图"><a href="#4-生命周期函数图" class="headerlink" title="4.生命周期函数图"></a>4.生命周期函数图</h4><p><img src="http://gjtblog-images.oss-cn-beijing.aliyuncs.com/lifecycle.png" alt></p><p><strong>本文作者</strong>：Gong Jintao<br><strong>本文地址</strong>： <a href="http://blog.gongjintao.com/2019/01/05/Vue中的生命周期/">http://blog.gongjintao.com/2019/01/05/Vue中的生命周期/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-生命周期定义&quot;&gt;&lt;a href=&quot;#1-生命周期定义&quot; class=&quot;headerlink&quot; title=&quot;1.生命周期定义&quot;&gt;&lt;/a&gt;1.生命周期定义&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;生命周期是指：从Vue实例创建、运行、到销毁期间，总是伴随着各种事件的发生，这些事件统称为生命周期。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Web前端" scheme="http://blog.gongjintao.com/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Vue" scheme="http://blog.gongjintao.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>CCF认证题库201312-3————最大的矩形</title>
    <link href="http://blog.gongjintao.com/2018/09/11/CCF%E8%AE%A4%E8%AF%81%E9%A2%98%E5%BA%93201312-3%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/"/>
    <id>http://blog.gongjintao.com/2018/09/11/CCF认证题库201312-3————最大的矩形/</id>
    <published>2018-09-11T11:27:46.000Z</published>
    <updated>2019-06-30T02:56:24.434Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><blockquote><p>在横轴上放了 n 个相邻的矩形，每个矩形的宽度是 1，而第 i（1 ≤ i ≤ n）个矩形的高度是 hi。这 n 个矩形构成了一个直方图。例如，下图中六个矩形的高度就分别是 3, 1, 6, 5, 2, 3。<br><img src="http://118.190.20.162/RequireFile.do?fid=Fmhrjgtb" alt><br><a id="more"></a>请找出能放在给定直方图里面积最大的矩形，它的边要与坐标轴平行。对于上面给出的例子，最大矩形如下图所示的阴影部分，面积是 10。<br><img src="http://118.190.20.162/RequireFile.do?fid=gNe4DHhD" alt></p></blockquote><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><blockquote><p>第一行包含一个整数 n，即矩形的数量 (1 ≤ n ≤ 1000)。<br>　第二行包含 n 个整数 h1, h2, … , hn，相邻的数之间由空格分隔。(1 ≤ hi ≤ 10000)。hi 是第 i 个矩形的高度。</p></blockquote><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><blockquote><p>输出一行，包含一个整数，即给定直方图内的最大矩形的面积。</p></blockquote><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>6<br>3 1 6 5 2 3</p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>10</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote><p>用的是最直接的思路，所以并非很好的解法。<br>因为对于直方图中的每一个矩形，都会决定一个最大矩形。高即该矩形的高，宽则是左右两个方向比它高的最后一个之间的相隔个数。然后在从这些矩形中找出最大的即可。</p></blockquote><h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">1002</span>;</span><br><span class="line"><span class="keyword">int</span> h[MAXN] = &#123;<span class="number">0</span>&#125;,n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sarea</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> h[])</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> left = i ,right = i; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;<span class="comment">//往左遍历</span></span><br><span class="line"><span class="keyword">if</span>(h[j]&gt;=h[i])&#123;</span><br><span class="line">left = j;        <span class="comment">//若遍历的矩形比该矩形高，则继续，边界left等于当前矩形的序号</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">break</span>;  <span class="comment">//若比该矩形低，则结束</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j= i+<span class="number">1</span>;j&lt;=n+<span class="number">1</span>;j++)&#123; <span class="comment">//向右遍历，同上</span></span><br><span class="line"><span class="keyword">if</span>(h[j]&gt;=h[i])&#123;</span><br><span class="line">right = j;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> v = h[i]*(right-left == <span class="number">0</span>?<span class="number">1</span>:right-left+<span class="number">1</span>);<span class="comment">//若right==left表明最大的矩形只有该矩形一条。</span></span><br><span class="line"><span class="keyword">if</span>(v&gt;ans) ans = v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;h[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;Sarea(n,h);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声明：菜鸟拙见，大神勿喷"><a href="#声明：菜鸟拙见，大神勿喷" class="headerlink" title="(声明：菜鸟拙见，大神勿喷)"></a><font color="red" size="4" face="宋体">(声明：菜鸟拙见，大神勿喷)</font></h2><p><strong>本文作者</strong>：Gong Jintao<br><strong>本文地址</strong>： <a href="http://blog.gongjintao.com/2018/09/11/CCF认证题库201312-3————最大的矩形/">http://blog.gongjintao.com/2018/09/11/CCF认证题库201312-3————最大的矩形/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在横轴上放了 n 个相邻的矩形，每个矩形的宽度是 1，而第 i（1 ≤ i ≤ n）个矩形的高度是 hi。这 n 个矩形构成了一个直方图。例如，下图中六个矩形的高度就分别是 3, 1, 6, 5, 2, 3。&lt;br&gt;&lt;img src=&quot;http://118.190.20.162/RequireFile.do?fid=Fmhrjgtb&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
      <category term="CCF试题库" scheme="http://blog.gongjintao.com/categories/CCF%E8%AF%95%E9%A2%98%E5%BA%93/"/>
    
    
      <category term="C/C++" scheme="http://blog.gongjintao.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>CCF认证题库201703-3————Markdown</title>
    <link href="http://blog.gongjintao.com/2018/09/05/CCF%E8%AE%A4%E8%AF%81%E9%A2%98%E5%BA%93201703-3%E2%80%94%E2%80%94%E2%80%94%E2%80%94Markdown/"/>
    <id>http://blog.gongjintao.com/2018/09/05/CCF认证题库201703-3————Markdown/</id>
    <published>2018-09-05T07:51:51.000Z</published>
    <updated>2019-06-30T02:54:03.518Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><blockquote><p>Markdown 是一种很流行的轻量级标记语言（lightweight markup language），广泛用于撰写带格式的文档。例如以下这段文本就是用 Markdown 的语法写成的：<br><img src="http://118.190.20.162/RequireFile.do?fid=Yy7nr9Yt" alt="01"><br><a id="more"></a>这些用 Markdown 写成的文本，尽管本身是纯文本格式，然而读者可以很容易地看出它的文档结构。同时，还有很多工具可以自动把 Markdown 文本转换成 HTML 甚至 Word、PDF 等格式，取得更好的排版效果。例如上面这段文本通过转化得到的 HTML 代码如下所示：<br><img src="http://118.190.20.162/RequireFile.do?fid=247472gj" alt="02"><br>本题要求由你来编写一个 Markdown 的转换工具，完成 Markdown 文本到 HTML 代码的转换工作。简化起见，本题定义的 Markdown 语法规则和转换规则描述如下：<br>　　●区块：区块是文档的顶级结构。本题的 Markdown 语法有 3 种区块格式。在输入中，相邻两个区块之间用一个或多个空行分隔。输出时删除所有分隔区块的空行。<br>　　○段落：一般情况下，连续多行输入构成一个段落。段落的转换规则是在段落的第一行行首插入 <code>&lt;p&gt;</code>，在最后一行行末插入 <code>&lt;/p&gt;</code>。<br>　　○标题：每个标题区块只有一行，由若干个 <code>#</code> 开头，接着一个或多个空格，然后是标题内容，直到行末。<code>#</code> 的个数决定了标题的等级。转换时，<code># Heading</code> 转换为 <code>&lt;h1&gt;Heading&lt;/h1&gt;</code>，<code>## Heading</code> 转换为 <code>&lt;h2&gt;Heading&lt;/h2&gt;</code>，以此类推。标题等级最深为 6。<br>　　○无序列表：无序列表由若干行组成，每行由 <code>*</code> 开头，接着一个或多个空格，然后是列表项目的文字，直到行末。转换时，在最开始插入一行 <code>&lt;ul&gt;</code>，最后插入一行 <code>&lt;/ul&gt;</code>；对于每行，<code>* Item</code> 转换为 <code>&lt;li&gt;Item&lt;/li&gt;</code>。本题中的无序列表只有一层，不会出现缩进的情况。<br>　　●行内：对于区块中的内容，有以下两种行内结构。<br>　　○强调：<code>_Text_</code> 转换为 <code>&lt;em&gt;Text&lt;/em&gt;</code>。强调不会出现嵌套，每行中 <code>_</code> 的个数一定是偶数，且不会连续相邻。注意 <code>_Text_</code> 的前后不一定是空格字符。<br>　　○超级链接：<code>[Text](Link)</code> 转换为 <code>&lt;a href=&quot;Link&quot;&gt;Text&lt;/a&gt;</code>。超级链接和强调可以相互嵌套，但每种格式不会超过一层。</p></blockquote><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><blockquote><p>　　输入由若干行组成，表示一个用本题规定的 Markdown 语法撰写的文档。</p></blockquote><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><blockquote><p>　　输出由若干行组成，表示输入的 Markdown 文档转换成产生的 HTML 代码。</p></blockquote><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p># Hello</p><p>Hello, world!</p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p><code>&lt;h1&gt;Hello&lt;/h1&gt;</code><br><code>&lt;p&gt;Hello, world!&lt;/p&gt;</code></p></blockquote><h3 id="评测用例规模与约定"><a href="#评测用例规模与约定" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h3><blockquote><p>　　本题的测试点满足以下条件：<br>　　●本题每个测试点的输入数据所包含的行数都不超过100，每行字符的个数（包括行末换行符）都不超过100。<br>　　●除了换行符之外，所有字符都是 ASCII 码 32 至 126 的可打印字符。<br>　　●每行行首和行末都不会出现空格字符。<br>　　●输入数据除了 Markdown 语法所需，内容中不会出现 <code>#</code>、<code>*</code>、<code>_</code>、<code>[</code>、<code>]</code>、<code>(</code>、<code>)</code>、<code>&lt;</code>、<code>&gt;</code>、<code>&amp;</code> 这些字符。<br>　　●所有测试点均符合题目所规定的 Markdown 语法，你的程序不需要考虑语法错误的情况。</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote><p>分两个部分进行处理，即区块和行列元素；然后建立vector容器html，存入处理后的每一行字符串。<br>1.首先处理行列元素，即处理强调符号和超级链接，分别构建deal1()和deal2()两个处理函数。注意的是这两个可以相互嵌套，所以需要将两个函数嵌套处理，所以需要提前申明。<br>2.区块分为三种，即段落，标题和无序列表。关键是段落和无序列表处理；当区块结束和文件末尾时，如果该区块是段落，则要在上一行末尾添加”&lt;/p&gt;”;如果该区块是无序列表，则要添加一个”&lt;/ul&gt;”。</p></blockquote><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">deal1</span><span class="params">(<span class="built_in">string</span> line)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">deal2</span><span class="params">(<span class="built_in">string</span> line)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//强调处理 </span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">deal1</span><span class="params">(<span class="built_in">string</span> line)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pos;</span><br><span class="line"><span class="keyword">while</span>((pos = line.find(<span class="string">"_"</span>))!=<span class="built_in">string</span>::npos)</span><br><span class="line">&#123;</span><br><span class="line">line.replace(pos,<span class="number">1</span>,<span class="string">"&lt;em&gt;"</span>);</span><br><span class="line">line.replace(line.find(<span class="string">"_"</span>,pos),<span class="number">1</span>,<span class="string">"&lt;/em&gt;"</span>);</span><br><span class="line">line = deal2(line);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> line;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//超链接处理 </span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">deal2</span><span class="params">(<span class="built_in">string</span> line)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pos;</span><br><span class="line"><span class="keyword">while</span>((pos = line.find(<span class="string">"["</span>))!=<span class="built_in">string</span>::npos)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> posR = line.find(<span class="string">"]"</span>,pos);</span><br><span class="line"><span class="keyword">int</span> posL1 = line.find(<span class="string">"("</span>,posR);</span><br><span class="line"><span class="keyword">int</span> posR1 = line.find(<span class="string">")"</span>,posL1);</span><br><span class="line"><span class="built_in">string</span> text = line.substr(pos+<span class="number">1</span>,posR-pos<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">string</span> link = line.substr(posL1+<span class="number">1</span>,posR1-posL1<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">string</span> a = <span class="string">"&lt;a href=\""</span>+link+<span class="string">"\"&gt;"</span>+text+<span class="string">"&lt;/a&gt;"</span>;</span><br><span class="line">line.replace(pos,posR1-pos+<span class="number">1</span>,a);</span><br><span class="line">line = deal1(line);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> line; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">string</span> line;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;  html;</span><br><span class="line"><span class="keyword">int</span> pSum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> paraFlag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> uSum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> listFlag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span>(getline(<span class="built_in">cin</span>,line))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(line.size()!=<span class="number">0</span>)<span class="comment">//如果字符串长度不为0 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> pos, sumH = <span class="number">0</span>; </span><br><span class="line"><span class="comment">//判断是否是段落 </span></span><br><span class="line"><span class="keyword">if</span>(*(line.begin())!=<span class="string">'#'</span> &amp;&amp; *(line.begin())!=<span class="string">'*'</span>)</span><br><span class="line">&#123;</span><br><span class="line">pSum++;</span><br><span class="line">paraFlag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(paraFlag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(pSum==<span class="number">1</span>) line = <span class="string">"&lt;p&gt;"</span>+line;<span class="comment">//是否是段落开头  </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否是标题 </span></span><br><span class="line"><span class="keyword">while</span>((pos = line.find(<span class="string">"#"</span>))!=<span class="built_in">string</span>::npos)</span><br><span class="line">&#123;</span><br><span class="line">sumH++;<span class="comment">//标题级别</span></span><br><span class="line">line.erase(pos,<span class="number">1</span>);</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"> <span class="comment">//判断是否是无序列表 </span></span><br><span class="line"><span class="keyword">while</span>((pos=line.find(<span class="string">"*"</span>))!=<span class="built_in">string</span>::npos) </span><br><span class="line">&#123;</span><br><span class="line">uSum++; </span><br><span class="line">listFlag = <span class="literal">true</span>;</span><br><span class="line">line.erase(pos,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将"#”和"*"去掉后，再去掉开头的多余空格 </span></span><br><span class="line"><span class="keyword">while</span>(*line.begin()==<span class="string">' '</span>)</span><br><span class="line">&#123;</span><br><span class="line">line.erase(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(listFlag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(uSum==<span class="number">1</span>) html.push_back(<span class="string">"&lt;ul&gt;"</span>); </span><br><span class="line">line = <span class="string">"&lt;li&gt;"</span> + line + <span class="string">"&lt;/li&gt;"</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理强调和超链接 </span></span><br><span class="line">line = deal1(line);</span><br><span class="line">line = deal2(line);</span><br><span class="line"><span class="keyword">if</span>(sumH)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> tmp[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(tmp,<span class="string">"%d"</span>,sumH);</span><br><span class="line"><span class="built_in">string</span> s= tmp;</span><br><span class="line">line = <span class="string">"&lt;h"</span>+s+<span class="string">"&gt;"</span>+line+<span class="string">"&lt;/h"</span>+s+<span class="string">"&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line">html.push_back(line);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//如果录入的是空行，说明是区块结束 </span></span><br><span class="line"><span class="keyword">if</span>(uSum &gt;= <span class="number">1</span>)<span class="comment">//如果区块结束，无序标签数目大于等于1，则在后面添加&lt;/ul&gt;,同时标志和计数器重置 </span></span><br><span class="line">&#123;</span><br><span class="line">html.push_back(<span class="string">"&lt;/ul&gt;"</span>); </span><br><span class="line">uSum = <span class="number">0</span>;</span><br><span class="line">listFlag =<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果区块结束，段落数目大于等于1，则在前一行后面添加&lt;/p&gt;,同时标志和计数器重置</span></span><br><span class="line"><span class="keyword">if</span>(pSum&gt;=<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::iterator it = html.end()<span class="number">-1</span>;</span><br><span class="line">*it =*it+<span class="string">"&lt;/p&gt;"</span>; </span><br><span class="line">pSum =  <span class="number">0</span>;</span><br><span class="line">paraFlag = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">line.clear();<span class="comment">//清空容器 </span></span><br><span class="line"> &#125; </span><br><span class="line"><span class="comment">//文件尾 也要判断 </span></span><br><span class="line"><span class="keyword">if</span>(uSum &gt;= <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">html.push_back(<span class="string">"&lt;/ul&gt;"</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(pSum&gt;=<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::iterator it = html.end()<span class="number">-1</span>;</span><br><span class="line"><span class="built_in">string</span> tmp = *it+<span class="string">"&lt;/p&gt;"</span>;</span><br><span class="line">*it = tmp; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;html.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;html[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解题总结"><a href="#解题总结" class="headerlink" title="解题总结"></a>解题总结</h3><blockquote><p>要熟悉string的各个内置函数的常见用法：<br>line.find(str,pos):表示从字符串line的pos位置往后面查找字串str，如果有则返回首次出现的位置，若不存在则返回<code>string::npos</code>;<br>line.substr(pos,len):表示从line的pos位置截取长度为len的字串，包括pos位置的值；<br>line.replace(pos,len,str):表示用字符串str替换line的pos位置往后的len长度的字串；<br>line.erase(pos_0,pos_n)：表示移除line中从位置pos_0到pos_n中间的字符串，包括pos_0,不包括pos_n，即[pos_0,pos_n);</p></blockquote><h2 id="声明：菜鸟拙见，大神勿喷"><a href="#声明：菜鸟拙见，大神勿喷" class="headerlink" title="(声明：菜鸟拙见，大神勿喷)"></a><font color="red" size="4" face="宋体">(声明：菜鸟拙见，大神勿喷)</font></h2><p><strong>本文作者</strong>：Gong Jintao<br><strong>本文地址</strong>： <a href="http://blog.gongjintao.com/2018/09/05/CCF认证题库201703-3————Markdown/">http://blog.gongjintao.com/2018/09/05/CCF认证题库201703-3————Markdown/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Markdown 是一种很流行的轻量级标记语言（lightweight markup language），广泛用于撰写带格式的文档。例如以下这段文本就是用 Markdown 的语法写成的：&lt;br&gt;&lt;img src=&quot;http://118.190.20.162/RequireFile.do?fid=Yy7nr9Yt&quot; alt=&quot;01&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="CCF试题库" scheme="http://blog.gongjintao.com/categories/CCF%E8%AF%95%E9%A2%98%E5%BA%93/"/>
    
    
      <category term="C/C++" scheme="http://blog.gongjintao.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>CCF认证题库201612-3————权限查询</title>
    <link href="http://blog.gongjintao.com/2018/09/03/CCF%E8%AE%A4%E8%AF%81%E9%A2%98%E5%BA%93201612-3%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E6%9D%83%E9%99%90%E6%9F%A5%E8%AF%A2/"/>
    <id>http://blog.gongjintao.com/2018/09/03/CCF认证题库201612-3————权限查询/</id>
    <published>2018-09-03T13:23:39.000Z</published>
    <updated>2019-06-30T02:53:35.441Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><blockquote><p>　　授权 (authorization) 是各类业务系统不可缺少的组成部分，系统用户通过授权机制获得系统中各个模块的操作权限。<br>　　本题中的授权机制是这样设计的：每位用户具有若干角色，每种角色具有若干权限。例如，用户 david 具有 manager 角色，manager 角色有 crm:2 权限，则用户 david 具有 crm:2 权限，也就是 crm 类权限的第 2 等级的权限。<a id="more"></a><br>　　具体地，用户名和角色名称都是由小写字母组成的字符串，长度不超过 32。权限分为分等级权限和不分等级权限两大类。分等级权限由权限类名和权限等级构成，中间用冒号“:”分隔。其中权限类名也是由小写字母组成的字符串，长度不超过 32。权限等级是一位数字，从 0 到 9，数字越大表示权限等级越高。系统规定如果用户具有某类某一等级的权限，那么他也将自动具有该类更低等级的权限。例如在上面的例子中，除 crm:2 外，用户 david 也具有 crm:1 和 crm:0 权限。不分等级权限在描述权限时只有权限类名，没有权限等级（也没有用于分隔的冒号）。<br>　　给出系统中用户、角色和权限的描述信息，你的程序需要回答多个关于用户和权限的查询。查询可分为以下几类：</p><ul><li>不分等级权限的查询：如果权限本身是不分等级的，则查询时不指定等级，返回是否具有该权限；</li><li>分等级权限的带等级查询：如果权限本身分等级，查询也带等级，则返回是否具有该类的该等级权限；</li><li>分等级权限的不带等级查询：如果权限本身分等级，查询不带等级，则返回具有该类权限的等级；如果不具有该类的任何等级权限，则返回“否”。</li></ul></blockquote><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><blockquote><p>　　输入第一行是一个正整数 p，表示不同的权限类别的数量。紧接着的 p 行被称为 P 段，每行一个字符串，描述各个权限。对于分等级权限，格式为 <category>:<level>，其中 <category> 是权限类名，<level> 是该类权限的最高等级。对于不分等级权限，字符串只包含权限类名。<br>　　接下来一行是一个正整数 r，表示不同的角色数量。紧接着的 r 行被称为 R 段，每行描述一种角色，格式为<br>　　<code>&lt;role&gt; &lt;s&gt; &lt;privilege 1&gt; &lt;privilege 2&gt; ... &lt;privilege s&gt;</code><br>　　其中<code>&lt;role&gt;</code> 是角色名称，<code>&lt;s&gt;</code> 表示该角色具有多少种权限。后面 <code>&lt;s&gt;</code> 个字符串描述该角色具有的权限，格式同 P 段。<br>　　接下来一行是一个正整数 u，表示用户数量。紧接着的 u 行被称为 U 段，每行描述一个用户，格式为<br>　　<code>&lt;user&gt; &lt;t&gt; &lt;role 1&gt; &lt;role 2&gt; ... &lt;role t&gt;</code><br>　　其中 <code>&lt;user&gt;</code> 是用户名，<code>&lt;t&gt;</code>表示该用户具有多少种角色。后面 <code>&lt;t&gt;</code> 个字符串描述该用户具有的角色。<br>　　接下来一行是一个正整数 q，表示权限查询的数量。紧接着的 q 行被称为 Q 段，每行描述一个授权查询，格式为 <code>&lt;user&gt; &lt;privilege&gt;</code>，表示查询用户 <code>&lt;user&gt;</code> 是否具有 <code>&lt;privilege&gt;</code> 权限。如果查询的权限是分等级权限，则查询中的 <privilege> 可指定等级，表示查询该用户是否具有该等级的权限；也可以不指定等级，表示查询该用户具有该权限的等级。对于不分等级权限，只能查询该用户是否具有该权限，查询中不能指定等级。<br>输出格式<br>　　输出共 q 行，每行为 false、true，或者一个数字。false 表示相应的用户不具有相应的权限，true 表示相应的用户具有相应的权限。对于分等级权限的不带等级查询，如果具有权限，则结果是一个数字，表示该用户具有该权限的（最高）等级。如果用户不存在，或者查询的权限没有定义，则应该返回 false。</privilege></level></category></level></category></p></blockquote><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>3<br>crm:2<br>git:3<br>game<br>4<br>hr 1 crm:2<br>it 3 crm:1 git:1 game<br>dev 2 git:3 game<br>qa 1 git:2<br>3<br>alice 1 hr<br>bob 2 it qa<br>charlie 1 dev<br>9<br>alice game<br>alice crm:2<br>alice git:0<br>bob git<br>bob poweroff<br>charlie game<br>charlie crm<br>charlie git:3<br>malice game</p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>false<br>true<br>false<br>2<br>false<br>true<br>false<br>true<br>false</p></blockquote><h3 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h3><blockquote><p>　　样例输入描述的场景中，各个用户实际的权限如下：<br>　　* 用户 alice 具有 crm:2 权限<br>　　* 用户 bob 具有 crm:1、git:2 和 game 权限<br>　　* 用户 charlie 具有 git:3 和 game 权限<br>　　* 用户 malice 未描述，因此不具有任何权限        </p></blockquote><h3 id="评测用例规模与约定"><a href="#评测用例规模与约定" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h3><blockquote><p>　　评测用例规模：<br>　　* 1 ≤ p, r, u ≤ 100<br>　　* 1 ≤ q ≤ 10 000<br>　　* 每个用户具有的角色数不超过 10，每种角色具有的权限种类不超过 10<br>　　约定：<br>　　* 输入保证合法性，包括：<br>　　1) 角色对应的权限列表（R 段）中的权限都是之前（P 段）出现过的，权限可以重复出现，如果带等级的权限重复出现，以等级最高的为准<br>　　2) 用户对应的角色列表（U 段）中的角色都是之前（R 段）出现过的，如果多个角色都具有某一分等级权限，以等级最高的为准<br>　　3) 查询（Q 段）中的用户名和权限类名不保证在之前（U 段和 P 段）出现过<br>　　* 前 20% 的评测用例只有一种角色<br>　　* 前 50% 的评测用例权限都是不分等级的，查询也都不带等级        </p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote><p><strong>首先</strong>构建权限的处理函数，即对权限字符串处理，返回<code>pair&lt;string,int&gt;</code> 的数据，第一个字段为权限名，第二个字段为等级，不分等级的权限则等级为-1；<br><strong>然后</strong>建立各项权限表：<br>1.用map先建立关于权限的权限表Prom；键值为权限名，对应的值为权限的等级；<br>2.用二维map建立关于角色与权限的角色权限表roleProm；键值为角色名，对应的值为该角色用的权限表。注意的是权限名可能重复出现，所以要判断在对应的权限表中是否已经存在该权限，且等级是否高于存在的权限的等级；<br>3.用二维map建立用户与权限的用户权限表，先录入的是该用户所对应的角色，然后将该角色的权限表的每一项录入用户的权限表中。注意权限名会重复出现，所以要录入该权限的最高等级。<br><strong>接下来</strong>进行查询：<br>1.判断是否在用户表和权限表中都存在，存在则继续，否则返回false；<br>2.查询对应的用户权限表中是否存在该权限，存在则继续，否则返回false；<br>3.查询对应的用户权限表中该权限是否是分等级的，是则继续，否则返回true;<br>4.若查询的权限是分等级的但没有给出等级号，则返回用户权限表中该权限的等级；若查询的等级号高于用户权限表中该权限的等级则返回false，否则返回true。</p></blockquote><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; prom;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; Prom; <span class="comment">//权限表 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt; <span class="built_in">string</span>, <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; &gt; roleProm; <span class="comment">//角色所拥有的权限</span></span><br><span class="line"><span class="comment">//string roles[maxn]; //角色名</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt; <span class="built_in">string</span>, <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; &gt; userProm; <span class="comment">//用户所拥有的权限</span></span><br><span class="line"><span class="comment">//string users[maxn]; //用户名 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//处理字符串，返回权限名和权限等级，不分等级，则等级为-1 </span></span><br><span class="line"><span class="function">prom <span class="title">dealProm</span><span class="params">(<span class="built_in">string</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> auth=<span class="string">""</span>;</span><br><span class="line"><span class="keyword">int</span> deg = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span>(p[i]!=<span class="string">':'</span> &amp;&amp; i&lt;p.size())&#123;</span><br><span class="line">auth += p[i];</span><br><span class="line">i++;</span><br><span class="line">&#125; </span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">while</span>(i&lt;p.size())&#123;</span><br><span class="line">deg = deg*<span class="number">10</span>+(p[i]-<span class="string">'0'</span>);</span><br><span class="line">i++;</span><br><span class="line">flag =<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!flag) deg = <span class="number">-1</span>;<span class="comment">//表明是不分等级的 </span></span><br><span class="line"><span class="function">prom <span class="title">tmp</span><span class="params">(auth,deg)</span></span>;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p,r,u,q;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;p;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;p;i++)&#123;</span><br><span class="line"><span class="built_in">string</span> authr;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;authr;</span><br><span class="line">prom tmp = dealProm(authr);</span><br><span class="line">Prom[tmp.first] = tmp.second; <span class="comment">//建立权限表 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;r;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;r;i++)&#123;</span><br><span class="line"><span class="built_in">string</span> role;</span><br><span class="line"><span class="keyword">int</span> s;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;role&gt;&gt;s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;s;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span> tmpor;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;tmpor;</span><br><span class="line">prom tmp = dealProm(tmpor);</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;::iterator it = roleProm[role].find(tmp.first);</span><br><span class="line"><span class="keyword">if</span>(it != roleProm[role].end())&#123;<span class="comment">//是否在角色权限表中存在 </span></span><br><span class="line"><span class="keyword">if</span>(it-&gt;second &lt; tmp.second)&#123;<span class="comment">//是否已存在的等级低于录入的权限的等级 </span></span><br><span class="line">it-&gt;second = tmp.second;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">roleProm[role][tmp.first] = tmp.second;  <span class="comment">//没有则直接 录入</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;u;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;u;i++)&#123;</span><br><span class="line"><span class="built_in">string</span> uName;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;uName&gt;&gt;t;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span> tName;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;tName;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;::iterator it = roleProm[tName].begin();</span><br><span class="line"><span class="keyword">for</span>(;it!=roleProm[tName].end();it++)<span class="comment">//将角色的权限写入用户的权限表中 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;::iterator it2 = userProm[uName].find(it-&gt;first);</span><br><span class="line"><span class="keyword">if</span>(it2!=userProm[uName].end())&#123;<span class="comment">//如果已经存在该权限 </span></span><br><span class="line"><span class="keyword">if</span>(it2-&gt;second &lt; it-&gt;second)&#123;<span class="comment">//判断等级是否高于存在的权限的的等级 </span></span><br><span class="line">it2-&gt;second = it-&gt;second;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">userProm[uName][it-&gt;first] = it-&gt;second;<span class="comment">//不存在则写入该权限项 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;q;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;q;i++)&#123;</span><br><span class="line"><span class="built_in">string</span> userName,selProm; </span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;userName&gt;&gt;selProm;</span><br><span class="line">prom tmp = dealProm(selProm);</span><br><span class="line"><span class="built_in">string</span> cate= tmp.first;</span><br><span class="line"><span class="keyword">int</span> degree = tmp.second;</span><br><span class="line"><span class="keyword">if</span>(Prom.find(cate)==Prom.end() || userProm.find(userName)==userProm.end() )&#123; <span class="comment">//如果权限表中没有该权限或着用户表中没有该用户 </span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"false"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(userProm[userName].find(cate)==userProm[userName].end())&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"false"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(userProm[userName][cate] != <span class="number">-1</span> )&#123;</span><br><span class="line"><span class="keyword">if</span>(degree == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;userProm[userName][cate]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">userProm[userName][cate] &lt; degree?<span class="built_in">cout</span>&lt;&lt;<span class="string">"false"</span>&lt;&lt;<span class="built_in">endl</span>:<span class="built_in">cout</span>&lt;&lt;<span class="string">"true"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"true"</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声明：菜鸟拙见，大神勿喷"><a href="#声明：菜鸟拙见，大神勿喷" class="headerlink" title="(声明：菜鸟拙见，大神勿喷)"></a><font color="red" size="4" face="宋体">(声明：菜鸟拙见，大神勿喷)</font></h2><p><strong>本文作者</strong>：Gong Jintao<br><strong>本文地址</strong>： <a href="http://blog.gongjintao.com/2018/09/03/CCF认证题库201612-3————权限查询/">http://blog.gongjintao.com/2018/09/03/CCF认证题库201612-3————权限查询/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;　　授权 (authorization) 是各类业务系统不可缺少的组成部分，系统用户通过授权机制获得系统中各个模块的操作权限。&lt;br&gt;　　本题中的授权机制是这样设计的：每位用户具有若干角色，每种角色具有若干权限。例如，用户 david 具有 manager 角色，manager 角色有 crm:2 权限，则用户 david 具有 crm:2 权限，也就是 crm 类权限的第 2 等级的权限。
    
    </summary>
    
      <category term="CCF试题库" scheme="http://blog.gongjintao.com/categories/CCF%E8%AF%95%E9%A2%98%E5%BA%93/"/>
    
    
      <category term="C/C++" scheme="http://blog.gongjintao.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>CCF试题库201312-2————ISBN号码</title>
    <link href="http://blog.gongjintao.com/2018/08/12/CCF%E8%AF%95%E9%A2%98%E5%BA%93201312-2%E2%80%94%E2%80%94%E2%80%94%E2%80%94ISBN%E5%8F%B7%E7%A0%81/"/>
    <id>http://blog.gongjintao.com/2018/08/12/CCF试题库201312-2————ISBN号码/</id>
    <published>2018-08-12T11:24:33.000Z</published>
    <updated>2019-06-30T02:54:35.355Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><blockquote><p>　每一本正式出版的图书都有一个 ISBN 号码与之对应，ISBN 码包括 9 位数字、1 位识别码和 3 位分隔符，其规定格式如 “x-xxx-xxxxx-x”，其中符号“-” 是分隔符（键盘上的减号），最后一位是识别码，例如 0-670-82162-4 就是一个标准的 ISBN 码。ISBN 码的首位数字表示书籍的出版语言，例如 0 代表英语；第一个分隔符 “-” 之后的三位数字代表出版社，例如 670 代表维京出版社；第二个分隔之后的五位数字代表该书在出版社的编号；最后一位为识别码。<br>识别码的计算方法如下：<a id="more"></a><br>首位数字乘以 1 加上次位数字乘以 2…… 以此类推，用所得的结果 mod 11，所得的余数即为识别码，如果余数为 10，则识别码为大写字母 X。例如 ISBN 号码 0-670-82162-4 中的识别码 4 是这样得到的：对 067082162 这 9 个数字，从左至右，分别乘以 1，2，…，9，再求和，即 0×1+6×2+……+2×9=158，然后取 158 mod 11 的结果 4 作为识别码。<br>编写程序判断输入的 ISBN 号码中识别码是否正确，如果正确，则仅输出 “Right”；如果错误，则输出是正确的 ISBN 号码。</p></blockquote><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><blockquote><p>输入只有一行，是一个字符序列，表示一本书的 ISBN 号码（保证输入符合 ISBN 号码的格式要求）。</p></blockquote><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><blockquote><p>输出一行，假如输入的 ISBN 号码的识别码正确，那么输出 “Right”，否则，按照规定的格式，输出正确的 ISBN 号码（包括分隔符 “-”）。       </p></blockquote><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>0-670-82162-4</p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>Right</p></blockquote><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>0-670-82162-0</p></blockquote><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>0-670-82162-4</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote><p>因为位数规定好了，所以算数比较简单，然后再进行判断即可。</p></blockquote><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 13</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> i,sum;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,&amp;s);</span><br><span class="line">sum=(s[<span class="number">0</span>]-<span class="string">'0'</span>)*<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=<span class="number">4</span>;i++)&#123;</span><br><span class="line">sum+=(s[i]-<span class="string">'0'</span>)*i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">6</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">sum+=(s[i]-<span class="string">'0'</span>)*(i<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>((sum%<span class="number">11</span>==<span class="number">10</span> &amp;&amp; s[N<span class="number">-1</span>] == <span class="string">'X'</span>)|| sum%<span class="number">11</span> == (s[N<span class="number">-1</span>]-<span class="string">'0'</span>))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Right"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N<span class="number">-1</span>;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>,s[i]);</span><br><span class="line">&#125;</span><br><span class="line">sum%<span class="number">11</span>==<span class="number">10</span>?<span class="built_in">printf</span>(<span class="string">"X"</span>):<span class="built_in">printf</span>(<span class="string">"%d"</span>,sum%<span class="number">11</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声明：菜鸟拙见，大神勿喷"><a href="#声明：菜鸟拙见，大神勿喷" class="headerlink" title="(声明：菜鸟拙见，大神勿喷)"></a><font color="red" size="4" face="宋体">(声明：菜鸟拙见，大神勿喷)</font></h2><p><strong>本文作者</strong>：Gong Jintao<br><strong>本文地址</strong>： <a href="http://blog.gongjintao.com/2018/08/12/CCF试题库201312-2————ISBN号码/">http://blog.gongjintao.com/2018/08/12/CCF试题库201312-2————ISBN号码/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;　每一本正式出版的图书都有一个 ISBN 号码与之对应，ISBN 码包括 9 位数字、1 位识别码和 3 位分隔符，其规定格式如 “x-xxx-xxxxx-x”，其中符号“-” 是分隔符（键盘上的减号），最后一位是识别码，例如 0-670-82162-4 就是一个标准的 ISBN 码。ISBN 码的首位数字表示书籍的出版语言，例如 0 代表英语；第一个分隔符 “-” 之后的三位数字代表出版社，例如 670 代表维京出版社；第二个分隔之后的五位数字代表该书在出版社的编号；最后一位为识别码。&lt;br&gt;识别码的计算方法如下：
    
    </summary>
    
      <category term="CCF试题库" scheme="http://blog.gongjintao.com/categories/CCF%E8%AF%95%E9%A2%98%E5%BA%93/"/>
    
    
      <category term="C/C++" scheme="http://blog.gongjintao.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>CCF试题库201312-1————出现次数最多的数</title>
    <link href="http://blog.gongjintao.com/2018/08/11/CCF%E8%AF%95%E9%A2%98%E5%BA%93201312-1%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E6%95%B0/"/>
    <id>http://blog.gongjintao.com/2018/08/11/CCF试题库201312-1————出现次数最多的数/</id>
    <published>2018-08-11T11:24:33.000Z</published>
    <updated>2019-06-30T02:59:52.812Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><blockquote><p>　给定 n 个正整数，找出它们中出现次数最多的数。如果这样的数有多个，请输出其中最小的一个。</p></blockquote><a id="more"></a><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><blockquote><p>　　输入的第一行只有一个正整数 n(1 ≤ n ≤ 1000)，表示数字的个数。<br>输入的第二行有 n 个整数 s1, s2, …, sn (1 ≤ si ≤ 10000, 1 ≤ i ≤ n)。相邻的数用空格分隔。</p></blockquote><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><blockquote><p>输出这 n 个次数中出现次数最多的数。如果这样的数有多个，输出其中最小的一个。</p></blockquote><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>6<br>10 1 10 20 30 20</p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>10</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote><p>此处规模不大，用hash表比较方便。</p></blockquote><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,i,s=<span class="number">0</span>,min,data;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">int</span> sum[<span class="number">10001</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;data);</span><br><span class="line">sum[data]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">10000</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(sum[i]&gt;s)&#123;</span><br><span class="line">s=sum[i];</span><br><span class="line">min=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,min);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声明：菜鸟拙见，大神勿喷"><a href="#声明：菜鸟拙见，大神勿喷" class="headerlink" title="(声明：菜鸟拙见，大神勿喷)"></a><font color="red" size="4" face="宋体">(声明：菜鸟拙见，大神勿喷)</font></h2><p><strong>本文作者</strong>：Gong Jintao<br><strong>本文地址</strong>： <a href="http://blog.gongjintao.com/2018/08/11/CCF试题库201312-1————出现次数最多的数/">http://blog.gongjintao.com/2018/08/11/CCF试题库201312-1————出现次数最多的数/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;　给定 n 个正整数，找出它们中出现次数最多的数。如果这样的数有多个，请输出其中最小的一个。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="CCF试题库" scheme="http://blog.gongjintao.com/categories/CCF%E8%AF%95%E9%A2%98%E5%BA%93/"/>
    
    
      <category term="C/C++" scheme="http://blog.gongjintao.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>CCF试题库201403-2————窗口</title>
    <link href="http://blog.gongjintao.com/2018/08/10/CCF%E8%AF%95%E9%A2%98%E5%BA%93201403-2%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E7%AA%97%E5%8F%A3/"/>
    <id>http://blog.gongjintao.com/2018/08/10/CCF试题库201403-2————窗口/</id>
    <published>2018-08-10T11:24:33.000Z</published>
    <updated>2019-06-30T04:28:59.398Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><blockquote><p>在某图形操作系统中, 有 N 个窗口, 每个窗口都是一个两边与坐标轴分别平行的矩形区域。窗口的边界上的点也属于该窗口。窗口之间有层次的区别, 在多于一个窗口重叠的区域里, 只会显示位于顶层的窗口里的内容。<br>　　当你点击屏幕上一个点的时候, 你就选择了处于被点击位置的最顶层窗口, 并且这个窗口就会被移到所有窗口的最顶层, 而剩余的窗口的层次顺序不变。如果你点击的位置不属于任何窗口, 则系统会忽略你这次点击。<br>　　现在我们希望你写一个程序模拟点击窗口的过程。</p></blockquote><a id="more"></a><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><blockquote><p>输入的第一行有两个正整数, 即 N 和 M。(1 ≤ N ≤ 10,1 ≤ M ≤ 10)<br>接下来 N 行按照从最下层到最顶层的顺序给出 N 个窗口的位置。 每行包含四个非负整数 x1, y1, x2, y2, 表示该窗口的一对顶点坐标分别为 (x1, y1) 和 (x2, y2)。保证 x1 &lt; x2,y1 2。<br>接下来 M 行每行包含两个非负整数 x, y, 表示一次鼠标点击的坐标。<br>题目中涉及到的所有点和矩形的顶点的 x, y 坐标分别不超过 2559 和 1439</p></blockquote><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><blockquote><p>输出包括 M 行, 每一行表示一次鼠标点击的结果。如果该次鼠标点击选择了一个窗口, 则输出这个窗口的编号 (窗口按照输入中的顺序从 1 编号到 N); 如果没有, 则输出 “IGNORED”(不含双引号)。</p></blockquote><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>3 4<br>0 0 4 4<br>1 1 5 5<br>2 2 6 6<br>1 1<br>0 0<br>4 4<br>0 5</p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>2<br>1<br>1<br>IGNORED</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote><p>思路较为简单：首先定义窗口结构体，包括窗口个定点的坐标以及其序号，然后输入数组中。输入坐标时，则反向循环数组（因为窗口输入时从底层到顶层；而点击需要先判断顶层）；若坐标在窗口内，则输出窗口序号，然后将该窗口移到最后一个，其余的窗口依次挪动位置。</p></blockquote><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">window</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x1,x2,y1,y2,index;</span><br><span class="line">&#125;Win;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,i,j,a,b;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    Win* wins;</span><br><span class="line">    wins = (Win*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Win)*n);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;wins[i].x1&gt;&gt;wins[i].y1&gt;&gt;wins[i].x2&gt;&gt;wins[i].y2;</span><br><span class="line">        wins[i].index=i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            Win temp;</span><br><span class="line">            <span class="keyword">if</span>((a&gt;=wins[i].x1 &amp;&amp; a&lt;=wins[i].x2) &amp;&amp; (b&gt;=wins[i].y1 &amp;&amp; b&lt;=wins[i].y2))&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;wins[i].index&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                temp = wins[i];</span><br><span class="line">                <span class="keyword">for</span>(j=i;j&lt;n<span class="number">-1</span>;j++)&#123;</span><br><span class="line">                    wins[j] = wins[j+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                wins[n<span class="number">-1</span>]=temp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"IGNORED"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声明：菜鸟拙见，大神勿喷"><a href="#声明：菜鸟拙见，大神勿喷" class="headerlink" title="(声明：菜鸟拙见，大神勿喷)"></a><font color="red" size="4" face="宋体">(声明：菜鸟拙见，大神勿喷)</font></h2><p><strong>本文作者</strong>：Gong Jintao<br><strong>本文地址</strong>： <a href="http://blog.gongjintao.com/2018/08/10/CCF试题库201403-2————窗口/">http://blog.gongjintao.com/2018/08/10/CCF试题库201403-2————窗口/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在某图形操作系统中, 有 N 个窗口, 每个窗口都是一个两边与坐标轴分别平行的矩形区域。窗口的边界上的点也属于该窗口。窗口之间有层次的区别, 在多于一个窗口重叠的区域里, 只会显示位于顶层的窗口里的内容。&lt;br&gt;　　当你点击屏幕上一个点的时候, 你就选择了处于被点击位置的最顶层窗口, 并且这个窗口就会被移到所有窗口的最顶层, 而剩余的窗口的层次顺序不变。如果你点击的位置不属于任何窗口, 则系统会忽略你这次点击。&lt;br&gt;　　现在我们希望你写一个程序模拟点击窗口的过程。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="CCF试题库" scheme="http://blog.gongjintao.com/categories/CCF%E8%AF%95%E9%A2%98%E5%BA%93/"/>
    
    
      <category term="C/C++" scheme="http://blog.gongjintao.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>CCF试题库201403-1————相反数</title>
    <link href="http://blog.gongjintao.com/2018/08/09/CCF%E8%AF%95%E9%A2%98%E5%BA%93201403-1%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E7%9B%B8%E5%8F%8D%E6%95%B0/"/>
    <id>http://blog.gongjintao.com/2018/08/09/CCF试题库201403-1————相反数/</id>
    <published>2018-08-09T11:24:33.000Z</published>
    <updated>2019-06-30T03:00:09.307Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><blockquote><p>有 N 个非零且各不相同的整数。请你编一个程序求出它们中有多少对相反数 (a 和 -a 为一对相反数)。</p></blockquote><a id="more"></a><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><blockquote><p>　第一行包含一个正整数 N。(1 ≤ N ≤ 500)。<br>第二行为 N 个用单个空格隔开的非零整数, 每个数的绝对值不超过 1000, 保证这些整数各不相同。</p></blockquote><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><blockquote><p>只输出一个整数, 即这 N 个数中包含多少对相反数。</p></blockquote><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>5<br>1 2 3 -1 -2</p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>2</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote><p>思路较为简单，嵌套两层循环即可。</p></blockquote><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,i,j,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> *a;</span><br><span class="line">    a = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((a[i]+a[j])==<span class="number">0</span>)&#123;</span><br><span class="line">                sum++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;sum;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声明：菜鸟拙见，大神勿喷"><a href="#声明：菜鸟拙见，大神勿喷" class="headerlink" title="(声明：菜鸟拙见，大神勿喷)"></a><font color="red" size="4" face="宋体">(声明：菜鸟拙见，大神勿喷)</font></h2><p><strong>本文作者</strong>：Gong Jintao<br><strong>本文地址</strong>： <a href="http://blog.gongjintao.com/2018/08/09/CCF试题库201403-1————相反数/">http://blog.gongjintao.com/2018/08/09/CCF试题库201403-1————相反数/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;有 N 个非零且各不相同的整数。请你编一个程序求出它们中有多少对相反数 (a 和 -a 为一对相反数)。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="CCF试题库" scheme="http://blog.gongjintao.com/categories/CCF%E8%AF%95%E9%A2%98%E5%BA%93/"/>
    
    
      <category term="C/C++" scheme="http://blog.gongjintao.com/tags/C-C/"/>
    
  </entry>
  
</feed>
