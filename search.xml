<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[机器学习中常用优化算法(优化器)]]></title>
    <url>%2Fpost%2F35f432a9.html</url>
    <content type="text"><![CDATA[1. 梯度下降系列1.1 梯度下降法及其三个变种1.1.1 BGD: Batch Gradient Descent批量梯度下降法，这里的批量实际上指的是全部的数据。每次迭代采用整个训练集数据来计算损失函数 $J(\theta)$ 对参数 $\theta$ 的梯度。迭代公式为： \theta = \theta - \eta \cdot \nabla_\theta J(\theta) 优点：每次迭代使用了全部样本，因此收敛过程比较稳定。对于损失函数是凸函数可以收敛到全局最优点，对于非凸函数，可以收敛到局部最优点。 缺点：因为每次迭代都用到了全部样本，所以计算速度较慢。而且不能对加入的新数据进行实时更新 1.1.2 SGD: Stochastic Gradient Descent随机梯度下降法，每次迭代只用一个样本来计算梯度。迭代公式为： \theta = \theta - \eta \cdot \nabla_\theta J(\theta;x^{(i)};y^{(i)}) 优点：每次只使用一个样本，训练速度快，包含一定的随机性；但从期望而言，每次计算的梯度基本是正确的。 缺点：更新频繁，带有随机性，会造成收敛过程震荡。 1.1.3 MBGD: Mini-Batch Gradient Descent小批量梯度下降，每次利用一小批的样本。即训练集为 N， 每次只用 n 个样本进行计算梯度。迭代公式为： \theta = \theta -\eta \cdot \nabla_\theta J(\theta;x^{(i:i+n)};y^{(i:i+n)}) 优点： 可以降低随机性，收敛更加稳定，且可以利用python库(如numpy) 的矩阵运算来进行更有效的梯度计算。 缺点：不能保证很好的收敛性，learning rate 如果选择的太小，收敛速度会很慢，如果太大，损失函数就会在极小值处不停地震荡甚至偏离。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798import numpy as npfrom matplotlib import pyplot as plt"""例子是最小二乘法拟合函数：h(\theta) = \theta.T X损失函数即均方误差:J(\theta) = (h(\theta)-y).T(h(\theta)-y)/2n残差值为： diff(\theta) = (h(\theta) - y)导数值为： delta(J) = (h(\theta)-Y)/n = diff(\theta) / n"""def BatchGradientDescent(theta, lr, X, Y): """ theta: 初始参数值 (m,1) lr: 学习率 X: 数据集，(num_example, m) Y: 真实值，(num_example, 1) """ n = X.shape[0] diff_value = np.dot(X, theta) - Y # (num_example,1) theta = theta - lr * np.dot(X.T, diff_value) / n return thetadef StochasticGradientDescent(theta, lr, X, Y): """ theta: 初始参数值 (m, 1) lr: 学习率 X: 数据集，(num_example, m) Y: 真实值，(num_example, 1) """ n = X.shape[0] for i in range(n): diff_value = np.dot(theta.T, X[i]) - Y[i] theta = theta - lr * diff_value * X[i].reshape(-1, 1) /n return thetadef MiniBatchGradientDescent(theta, lr, X, Y, batch_size): """ theta: 初始参数值 (m, 1) lr: 学习率 X: 数据集，(num_example, m) Y: 真实值，(num_example, 1) batch_size: 批量值 """ n = X.shape[0] batch_epcho = n // batch_size for i in range(batch_epcho): diff_value = np.dot(X[i*batch_size:(i+1)*batch_size], theta) - Y[i*batch_size:(i+1)*batch_size] theta = theta - lr * \ np.dot(X[i*batch_size:(i+1)*batch_size].T, diff_value) / n return thetaif __name__ == "__main__": num_examples = 1000 m = 4 X = np.random.randn(num_examples, m) Y = np.random.randn(num_examples, 1) np.random.seed(1024) theta_b = np.random.randn(m, 1) theta_s = np.random.randn(m, 1) theta_m = np.random.randn(m, 1) lr = 0.01 epochs = 500 loss_b = list() loss_s = list() loss_m = list() for epoch in range(epochs): theta_b = BatchGradientDescent(theta_b, lr, X, Y) h_b = np.dot(X, theta_b) cost_b = np.dot((h_b - Y).T, h_b-Y) / (2 * num_examples) loss_b.append(cost_b.reshape(1,)) theta_s = StochasticGradientDescent(theta_s, lr, X, Y) h_s = np.dot(X, theta_s) cost_s = np.dot((h_s - Y).T, h_s-Y) / (2 * num_examples) loss_s.append(cost_s.reshape(1,)) theta_m = MiniBatchGradientDescent(theta_m, lr, X, Y, 20) h_m = np.dot(X, theta_m) cost_m = np.dot((h_m - Y).T, h_m-Y) / (2 * num_examples) loss_m.append(cost_m.reshape(1,)) plt.figure() plt.plot(range(len(loss_b)), loss_b, label="BGD") plt.plot(range(len(loss_s)), loss_s, label="SGD") plt.plot(range(len(loss_m)), loss_m, label="MBGD") plt.legend() plt.xlabel('epochs') plt.ylabel('loss') plt.show() 1.2 Momentum梯度下降法容易被困在局部极小值点或鞍点来回震荡，可能存在曲面的另一个方向有更小的值；有时候梯度下降法收敛速度还是很慢。动量法就是为了解决这两个问题提出的。迭代公式： \begin{array}{l} v_{t}=\gamma v_{t-1}+\eta \nabla_{\theta} J(\theta) \\ \theta=\theta-v_{t} \end{array}当我们将一个小球从山上滚下来时，没有阻力的话，它的动量会越来越大，但是如果遇到了阻力，速度就会变小。加入的这一项，可以使得梯度方向不变的维度上速度变快，梯度方向有所改变的维度上的更新速度变慢，这样就可以加快收敛并减小震荡。 超参数设定值：一般$\gamma$ 取值 0.9 左右 1.3 Nesterov Momentum1.4 Adagrad1.5 Adam1.6 Adadelta1.7 RMSprop2. 牛顿法和拟牛顿法3. 拉格朗日乘子法4. 分治法4.1 坐标下降法4.2 SMO算法4.3 分阶段优化本文作者：Gong Jintao本文地址： https://gongjintao.com/post/35f432a9.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习常用损失函数]]></title>
    <url>%2Fpost%2F15c04377.html</url>
    <content type="text"><![CDATA[1. 交叉熵损失函数(Cross Entropy Loss)交叉熵损失函数最常用与分类问题。 二分类(逻辑回归)：在二分类中我们通常使用 Sigmoid 函数将模型的输出压缩到 $(0, 1)$ 区间内即 $\hat{y_i} \in (0,1 )$。 假设模型为： \begin{array}{c} p\left(y_{i}=1 | x_{i}\right)=\hat{y}_{i} \\ p\left(y_{i}=0 | x_{i}\right)=1-\hat{y}_{i} \end{array}合成一个式子： p(y_i|x_i) = (\hat{y_i})^{y_i}(1-\hat{y_i})^{1-y_i}假设数据集大小为 N，且服从独立同分布，则似然函数可以表示为： L(x, y)=\prod_{i=1}^{N}\left(\hat{y}_{i}\right)^{y_{i}}\left(1-\hat{y}_{i}\right)^{1-y_{i}}对似然取负对数得到交叉熵损失函数： NLL(x, y)=J_{C E}=-\sum_{i=1}^{N} y_{i} \log \left(\hat{y}_{i}\right)+\left(1-y_{i}\right) \log \left(1-\hat{y}_{i}\right)多分类：多分类思路与二分类一样的,但真实值 $y_i$ 是 One-hot 向量。同时模型输出的压缩由 Sigmoid 函数变成了 SoftMax 函数。 假设模型为： p\left(y_{i} | x_{i}\right)=\prod_{k=1}^{K}\left(\hat{y_{i}^{k}}\right)^{y_{i}^{k}}其中 $k \in K $ 表示第 $k$ 个类别。同样假设数据集大小为 N，且服从独立同分布。则似然函数为： N L L(x, y)=J_{C E}=-\sum_{i=1}^{N} \sum_{k=1}^{K} y_{i}^{k} \log \left(\hat{y_{i}^{k}}\right)由于 $y_i$ 是 One-hot 向量，除了目标类所在的索引为 1，其余索引都为 0 。因此上式可写成： J_{C E}=-\sum_{i=1}^{N} y_{i}^{c_{i}} \log ( \hat{y_i^{c_i}})其中$c_i $ 是样本 $x_i$ 的目标类。通常这个应用于多分类的交叉熵损失函数也被称为 SoftMax Loss 或者 Categorical Cross Entropy Loss。 代码实现如下： 1234567891011121314151617181920212223242526def cross_entropy_loss(x,y): """ x 一般是从全连接层的输出，(num_examples x num_classes) y 是标签 (num_examples x 1) """ n = y.shape[0] p = softmax(x) log_likelihood = -np.log(p[range(n),np.reshape(y,(n,))]) loss = np.sum(log_likelihood) / n return lossdef softmax(x): e_x = np.exp(x-np.max(x,axis = 1,keepdims=True)) return e_x / np.sum(e_x,axis=1,keepdims=True)if __name__ == "__main__": num_examples = 10 num_classes = 5 x = np.random.rand(num_examples,num_classes) y = np.random.randint(0,num_classes,(num_examples,)) cel = cross_entropy_loss(x,y) print(cel) 2. 均方误差(MSE——Mean Squared Error Loss)MSE是机器学习、深度学习回归任务中最常用的一种损失函数，也称 L2 Loss。 基本形式为： J_{M S E}=\frac{1}{N} \sum_{i=1}^{N}\left(y_{i}-\hat{y}_{i}\right)^{2}其中 $y_i$ 为真实值，$\hat{y_i}$ 为预测值。 代码如下： 1234567891011121314151617import numpy as npdef mean_squared_error_loss(y,y_hat): """ y 是真实值，(num__examples x 1) y_hat 是预测值， (num_examples x 1) """ n = y.shape[0] return np.sum((y-y_hat)**2) / n if __name__ == "__main__": num_examples = 10 true_value = np.random.rand(num_examples,1) test_value = np.random.rand(num_examples,1) mse = mean_squared_error_loss(true_value,test_value) print(mse) 3. 平均绝对误差(MAE——Mean Absolute Error Loss)也称为 L1 Loss，其基本形式为： J_{M A E}=\frac{1}{N} \sum_{i=1}^{N}\left|y_{i}-\hat{y}_{i}\right|代码如下： 123456789101112131415161718import numpy as npdef mean_absolute_error_loss(y, y_hat): """ y 是真实值，(num__examples x 1) y_hat 是预测值， (num_examples x 1) """ n = y.shape[0] return np.sum(np.fabs(y-y_hat)) / nif __name__ == "__main__": num_examples = 10 true_value = np.random.rand(num_examples, 1) test_value = np.random.rand(num_examples, 1) mse = mean_absolute_error_loss(true_value, test_value) print(mse) 4. 合页损失(Hinge Loss)合页损失是另一种二分类的损失函数，适用于最大化间隔的分类。如支持向量机SVM的损失函数可以看作是合页损失+L2正则化。基本形式为： J_{h i n g e}=\sum_{i=1}^{N} \max \left(0,1-\operatorname{sign}\left(y_{i}\right) \hat{y}_{i}\right)示意图如下： 代码如下： 123456789101112131415import numpy as npdef hinge_loss(y,y_hat): """ y 是真实值，值为1或-1，(num_examples x 1) y_hat 是预测值，(num_examples x 1) """ return np.sum(np.maximum(0,1-np.sign(y)*y_hat))if __name__ == "__main__": true_value = np.array([1, -1, 1, 1, -1, 1, -1, 1, -1, 1]) test_value = np.random.randn(10) hingeLoss = hinge_loss(true_value,test_value) print(hingeLoss) 参考： https://zhuanlan.zhihu.com/p/77686118?utm_source=qq 本文作者：Gong Jintao本文地址： https://gongjintao.com/post/15c04377.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Transformer Based]]></title>
    <url>%2Fpost%2F9436d27.html</url>
    <content type="text"><![CDATA[目前为止，我们已经可以对单词有基本的表示，如 Word2vec，Glove，fastText；但是这些方法都存在两个问题： 无论单词出现在何种上下文环境中，对这些单词都只有一种表示 可能需要非常细微的词义消歧 我们对一个单词只有一个表示，但是单词有不同的方面，包括语义、句法行为和语域/内涵 ELMo主要思想：想得到在上下文中词的含义，但是标准的学习任务 RNN 只能在已标记小数据集上进行。所以 pre-ELMo 提出了一种将双向语言模型中的预训练上下文嵌入加入到NLP系统中的通用半监督方法，并将其应用于序列标记任务 ELMo(Embeddings from Language Models) 不同于一般的词嵌入，其单词表示是整个输入句子的函数。 双向语言模型(biLM)给定含 $N$ 个token的序列：$(t_1,t_2,\dots,t_N)$ 前向语言模型通过给定前面的k-1个位置的token序列计算第k个token的出现的概率: p\left(t_{1}, t_{2}, \ldots, t_{N}\right)=\prod_{k=1}^{N} p\left(t_{k} | t_{1}, t_{2}, \ldots, t_{k-1}\right)后向语言模型类似于前向，区别在于将序列反转： p\left(t_{1}, t_{2}, \ldots, t_{N}\right)=\prod_{k=1}^{N} p\left(t_{k} | t_{k+1}, t_{k+2}, \ldots, t_{N}\right)biLM训练过程中的目标就是最大化: \begin{array}{l} \sum_{k=1}^{N}\left(\log p\left(t_{k} | t_{1}, \ldots, t_{k-1} ; \Theta_{x}, \vec{\Theta}_{L S T M}, \Theta_{s}\right)\right. \\ \left.\quad+\log p\left(t_{k} | t_{k+1}, \ldots, t_{N} ; \Theta_{x}, \overleftarrow{\Theta}_{L S T M}, \Theta_{s}\right)\right) \end{array}ELMo 对于每一个token $t_k$ ，通过一个 L 层的 biLM 来计算 2L+1 个表示： \begin{aligned} R_{k} &=\left\{\mathbf{x}_{k}^{L M}, \overrightarrow{\mathbf{h}}_{k, j}^{L M}, \overleftarrow{\mathbf{h}}_{k, j}^{L M} | j=1, \ldots, L\right\} \\ &=\left\{\mathbf{h}_{k, j}^{L M} | j=0, \ldots, L\right\} \end{aligned}其中 $\overrightarrow{\mathbf{h}}_{k, j}^{L M}$ 指前向 LM 第 j 层 LSTM 的输出，同理 $\overleftarrow{\mathbf{h}}_{k, j}^{L M}$ 是指反向 LM 第 j 层 LSTM 的输出。则 $\mathbf{h}_{k, j}^{L M} = \{\overrightarrow{\mathbf{h}}_{k, j}^{L M};\overleftarrow{\mathbf{h}}_{k, j}^{L M}\}$ 即每个 biLM 层的输出。$\mathbf{x}_k^{LM}$ 是对token进行直接编码的结果(这里是字符通过CNN编码)。 然后 ELMo 将所有层的输出 R 压缩为单个向量 \mathbf{E L M o}_{k}=E\left(R_{k} ; \mathbf{\Theta}_{e}\right)最简单的压缩方法是取最上层的结果做为token的表示 E\left(R_{k}\right)=\mathbf{h}_{k, L}^{L M}更通用的做法是通过一些参数来联合所有层的信息: \mathbf{E} \mathbf{L} \mathbf{M} \mathbf{o}_{k}^{\text {task}}=E\left(R_{k} ; \Theta^{\text {task}}\right)=\gamma^{\text {task}} \sum_{j=0}^{L} s_{j}^{\text {task}} \mathbf{h}_{k, j}^{L M}上式中 $s^{task}$ 是 softmax 出来的结果，$\gamma$ 是 scalar 参数，可以让模型放缩整个 ELMo 向量。 使用方法 最简版本 先固定一个权重, 构成一个 ELMO 向量 $ELMO^{task}$ , 然后联结最初始词向量(也就是通过字符卷积获得的向量) $x_k$ 得到 $\left[x_{k} ; E L M O_{k}^{\text {task}}\right]$ 然后将这个向量输入到任务的 RNN 模型中去. 然后在训练中一同训练权重因子。 加强版 我们可以在output处也加一个这样的向量,即 $[h_k;ELMO_k^{task}]$ 不同是,这里应该采用与输入中不同的权重因子. 最终版 可以在 ELMo 模型中加入 dropout, 以及采用 L2 loss的方法来提升模型。并且, 这里的 L2 项的系数 $\lambda$ 越大, 越有取各层平均值的意思。越小, 越可以发挥各个层之间的不同带来的效果. 但是并不是说, 越小越好。 预训练过程 使用 2 层 biLSTM 使用 character CNN 来初始化词表示 2048 char n-gram filters and 2 highway layers, 512 dim projection 使用 4096 维隐藏层状态和 512 的映射维度 使用 residual 联结 (残差连接) ELMo：不同层的权值 较低层更适合较低层次的语法 词性标注，句法依赖，命名实体识别 高层次更适合较高层次的语义 情感，语义标注，问答系统 Transformer动机想要模型并行化，但本质上 RNN 是串行的。除了 GRU 和 LSTMs，RNNs 任然需要 attention 机制来解决长期依赖问题。如果 attention 可以让我们到达任意时刻的状态，或许我们可以仅仅使用 attention 而不需要 RNN 概览 Non-recurrent sequence-to-sequence encoder-decoder model 任务：在平行语料库上的机器翻译问题 预测每个翻译的词语 损失函数是softmax分类器上的标准交叉熵误差 整体结构图如下： 详解Transformer 本质上是一个 encoder-decoder 模型，如下图所示：运用在机器翻译中的 Transformer 其 Encoders 包含 6 个 block，每个 block 的结构是相同的，仅权值不同；Decoders 与 Encoders 类似，但其中的 block 与之有细微差别。 EncoderEncoder的每个 block 又可分解成两个部分： Multihead attention 2 层的前馈神经网络(带有 ReLU 激活函数) 而这两个步骤中每个都包含如下操作： 残差连接 (Residual connection) 规范化 LayerNorm(x + Sublayer(x)) LayerNorm 可以将输入变成均值为 0 方差为 1 的数据。 （为了方便残差连接，模型的所有子层和嵌入层的输出都是 512 维） DecoderDecoder 中的每个 block 除了有 Encoder 的block 的两个子层，参残差连接和规范化之外，有以下两点改变： 屏蔽解码器的自注意力机制对先前产生的输出的影响，该屏蔽可以确保位置 $i$ 的预测只能依赖于小于 $i$ 的位置处的已知输出。 中间插入了一个 Encoder-Decoder Attention 的子层。其 queries 来自上一层，而 keys 和 values 来自 encoders 的输出。 Attention Attention 机制可以描述为将 queries 和一组键值对 $(k-v)$ 映射到输出，其中$q,k,v $都是向量. Dot-Product Attention A(q, K, V)=\sum_{i} \frac{e^{q \cdot k_{i}}}{\sum_{j} e^{q \cdot k_{j}}} v_{i}其矩阵表示为： A(Q, K, V)=\operatorname{softmax}\left(Q K^{T}\right) V其中 $q$ 和 $k$ 有相同的维度 $d_k$；$v$ 的维度是 $d_v$。所以最后的维度是 \left[|Q| \times d_{k}\right] \times\left[d_{k} \times|K|\right] \times\left[|K| \times d_{v}\right]即 $|Q| \times d_v$ Scaled Dot-Product AttentionDot-Product Attention 存在的问题：当维度 $d_k$ 变大，会导致 $q^Tk$ 的方差会增大 $\longrightarrow $ softmax 里的一些值变大 $\longrightarrow$ softmax 变得 $\longrightarrow$ 其梯度变得更小 解决办法就是用向量的长度做放缩： A(Q, K, V)=\operatorname{softmax}\left(\frac{Q K^{T}}{\sqrt{d_{k}}}\right) V Self-Attention 这一层可以帮助 encoder 在编码一个特定单词时，可以关注输入序列的其他单词。 假设输入序列是如下一个我们想要翻译的句子： ”The animal didn&#39;t cross the street because it was too tired” 我们在计算 “it” 时，self-attention 可以使之与 “animal”相关联。 Self-Attention计算过程详解： 从每个输入向量中(也就是每个单词的嵌入向量)创建三个向量$q,k,v$；这三个向量分别是用三个矩阵与 embedding 相乘所得到的。这三个向量的维度要比 embedding vector 的维度小，是64维；而 embedding vector 和 encoder 的输入和输出都是512 维。 根据当前单词对输入句子的每个单词评分，这个评分决定了当我们对句子中某个单词进行编码时，需要将多少注意力放到句子的其他部分。计算方式：将每个单词 $q$ 和 $k$ 分别做点积。 将得分除以 8 ，即 $\sqrt{64}$ ，也就是 $\sqrt{d_k}$ 。这可以使得梯度更加稳定。 然后再用 softmax 操作将其转换成概率。 将每个 $v$ 与 softmax score 相乘，这可以保持我们需要关注的单词的完整，并且去除无关的词。 将加权的 $v$ 值求和。这就产生了 self-attention 层在该位置的输出。 矩阵表达： Multi-Head Attention简单的 self-attention 存在的问题：只有一条路径让单词与另一个单词连接。大致结构如下： Multi-Head Attention 计算过程详解： 如果我们如上图做同样的 attention 计算，只是8次不同的加权矩阵，便可得到 8个不同的 Z 矩阵。 但这里有 8 个矩阵，而前馈神经网络的输入是一个，所以需要将这 8 个矩阵连接起来。具体操作： $Concate(Z_0,Z_1,\dots,Z_7)$ 用 $W^O$ 与 $Concate(Z_0,Z_1,\dots,Z_7)$ 相乘得到 $Z$ 总的运算流程如下： 公式表达： \begin{aligned} \operatorname{MultiHead}(Q, K, V) &\left.=\text { Concat (Z }_{1}, \ldots, \text { Z }_{\mathrm{h}}\right) W^{O} \\ \text { where Z }_{\mathrm{i}} &=\text { Attention }\left(Q W_{i}^{Q}, K W_{i}^{K}, V W_{i}^{V}\right) \end{aligned}Positional Encoding截至目前为止，Transformer 并没有捕捉顺序序列的能力，即无论句子的顺序是什么，Transformer 得到的结果都是类似的。为了解决这一问题，论文在编码词向量时引入了位置编码(Positional Encoding)的特征。具体操作如下图所示： 具体计算公式是： \begin{aligned} P E_{(p o s, 2 i)} &=\sin \left(\text {pos} / 10000^{2 i / d_{\text {model }}}\right) \\ P E_{(p o s, 2 i+1)} &=\cos \left(\text {pos} / 10000^{2 i / d_{\text {model }}}\right) \end{aligned}其中 $pos$ 是单词的位置，$i$ 是维度。 BertBert(Bidirectional Encoder Representations from Transformers) Bert 主要分为两个过程： pre-trained 在未标记数据上关于不同的pre-training任务上进行 Task #1: Masked LM Bert采用了双向的语言模型，但如果采用双向的话，就不可以采用预测下一个词的方式，因为模型可以看到要预测的值。所以采用了Masked LM，类似于完形填空。 具体做法： 随机mask输入的几个词，然后预测这些词。但是这样子做的坏处是因为fine-tuning阶段中并没有[MASK] token，所以导致了pre-training 和 ﬁne-tuning的不匹配的情况。所以为了减轻这个问题，文章中采用的做法是：对于要MASK 15%的tokens： 80% 替换成 [MASK] 10% 替换成随机的Token 10% 保持不变 Task #2:Next Sentence Prediction(NSP) 预先训练一个二值化的下一个句子预测任务，这个任务可以从任何单语语料库生成。具体来说，在为每个预训练示例选择句子A和B时，50%B是A后面的实际下一个句子（标记为IsNext），50%B是来自语料库的随机句子（标记为NotNext）。 fine-tuning 由前面的pre-trained参数初始化Bert模型，然后所有参数在使用标记数据在下游任务上进行微调。每个下游任务都有不同的微调模型，即便初始化时使用的同样的预训练参数。 模型结构： Transformer encoder Self attention =&gt; no locality bias Single multiplication per layer =&gt; efficiency on GPU/TPU Embedding layers 输入为：[CLS]+ 句子 A + [SEP] + 句子B +[SEP] [CLS]：代表分类任务的特殊token，它的输出即模型的pooler output [SEP]：分隔符 Encoder和Transformer的encoder是一样的。 Output模型的每一个输入都对应着一个输出，根据不同的任务可以选择不同的输出，主要有两类输出： pooler output：对应的是[CLS]的输出 sequence output: 对应的是所有其它的输入字的最后输出 参考 CS224N 2019 https://jalammar.github.io/illustrated-transformer/ 本文作者：Gong Jintao本文地址： https://gongjintao.com/post/9436d27.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Attention Based Model]]></title>
    <url>%2Fpost%2F4b37d30a.html</url>
    <content type="text"><![CDATA[Attention Based ModelMachine Translation早期的机器翻译 早期机器翻译是基于规则的，通过使用一个双语词典，将源语言的单词映射到目标语言对应的单词。 统计机器翻译：主要思想是从数据中学习一个概率模型。 假如要将法语翻译成英语。则需要找到一个在给定法语序列 $x$ 的条件下最合适的英文序列 $y$，即： \text{argmax}_y P(y|x)通过贝叶斯定理，可以将上式分为两个部分，分别进行学习： = \text{argmax}_y P(x|y) P(y) $P(x|y)$ 即翻译模型，如何合理的翻译出单词和短语，需要从平行语料中学习。 $P(y)$ 即语言模型，如何写好流利的英语。从单语数据中学习。 如何从平行语料库中学习翻译模型 $ P(x|y)$ ： 进一步分解： P(x,a|y)其中a是对齐方式，即源语言句子 $x$ 和目标语言句子 $y$之 间的字级的对应。 对齐方式有多种情况： 可能有些单词在另一种语言中没有对齐单词 多对一 一对多 多对多 那么如何来计算最优值： 如果列举每一种可能的 $y$ ，然后计算概率，则计算量太大。我们可以用一种启发式的搜索算法来寻找最佳翻译，摒弃概率太低的假设。这个过程称为解码(decoding) 神经机器翻译 神经机器翻译是用单个神经网络来进行机器翻译 其神经网络结构被称为 seq2seq ，它包括两个 RNNs seq2seq模型 seq2seq 除了用于机器翻译，也可以用于其他方面，如文本摘要，对话系统，语法分析，代码生成 训练 NMT 解码方法贪婪解码(Greedy Decoding)： 即在每一步中取最可能的单词。存在的问题是可能当前的最大概率的单词对于翻译整个句子来讲不一定是最优的选择，但由于每次我们都做greedy的选择我们没机会选择另一条整体最优的路径。 为解决这一问题，一个常用的方法是beam search decoding。其主要思想是，其基本思想是在decoder的每一步，我们不仅仅是取概率最大的单词，而是保存k个当前最有可能的翻译假设，其中k称作beam size，通常在5到10之间。 假设 $y_1,\dots,y_t$ 的分数是其概率的对数来表示，即 \operatorname{score}\left(y_{1}, \ldots, y_{t}\right)=\log P_{\mathrm{LM}}\left(y_{1}, \ldots, y_{t} | x\right)=\sum_{i=1}^{t} \log P_{\mathrm{LM}}\left(y_{i} | y_{1}, \ldots, y_{i-1}, x\right)分数越高越好。 从上图可知当 Beam size = k = 2 时，每一步都会找得分最高的 2 个，直到最后，再进行回溯。 编码结束，一般是产生了标识符，但每个假设产生标识符的时间不同，所以一般整个结束是在到了时刻 T(T是一个预定义的截止值)或者产生了至少 n 个完整假设。(n 是一个预定义的截止值)。 当我们有一组完全假设，如何选择分数最高的那一个？ 虽然分数越高越好，但求和中的每一项都是负数，这会导致长的翻译分数更低，所以最后在选取整句概率最大的翻译时，要对分数做归一化。 \frac{1}{t} \sum_{i=1}^{t} \log P_{\mathrm{LM}}\left(y_{i} | y_{1}, \ldots, y_{i-1}, x\right)NML的优缺点优点： 相比于 SMT ，NMT 有以下优点： 更好的效果 更加流畅 对上下文有更好的利用 对短语相似度有更好的利用 端到端优化单个神经网络： 不用单独优化某个子组件 所需的人力更少 不需要特征工程 对于所有的语言对可以用同样的方法 缺点： 相比于 SMT，NMT 有以下缺点： NMT 解释性较差： 难以 debug NMT较难控制： 无法轻松指定翻译规则或指导原则 存在安全问题 评估机器翻译BLEU(Bilingual Evaluation Understudy) BLEU 将机器翻译的结果和人工翻译的结果进行比较，然后基于以下条件计算得分： n-gram 精度（通常是1，2，3 和 4-grams） 对太短的系统翻译进行惩罚 BLEU 有用但是不够完美： 翻译一个句子有很多有效的方法 所以一个好的翻译可以得到一个很差的BLEU分数，因为它与人类翻译有很低的n-gram重叠 Attentionseq2seq 结构的瓶颈问题：在编码阶段，需要对所输入的所有信息都encode到encoder的最后一个hidden state上，这通常是不现实的，因此引入Attention来解决这个瓶颈。 主要思想：在解码器的每个步骤中，使用与编码器的直接连接来聚焦源序列的特定部分。 先用解码器的每个状态于编码器的各状态做点积得到 Attention scores 然后在 Attention scores 上取 softmax 得到其概率分布 Attention distribution 用 Attention distribution 求 encoder hidden state 的加权和，即 Attention output(主要包含来自被高度注意的隐藏状态的信息) 将 Attention output 与 decoder hidden state 连接，然后用其计算得到 $\hat{y}$(有时我们以从上一步中提取 Attention output，并将其输入解码器) 公式说明： encoder 隐变量状态 $h_1,\dots,h_N \in \mathbb{R}^h$ 第 $t$ 个时间步的decoder 隐变量状态 $s_t \in \mathbb{R}^h$ 得到第 $t$ 时间步的 attention scores： e^{t}=\left[s_{t}^{T} h_{1}, \ldots, s_{t}^{T} h_{N}\right] \in \mathbb{R}^{N} 用 softmax 求 attention distribution： \alpha^{t}=\operatorname{softmax}\left(e^{t}\right) \in \mathbb{R}^{N} 用 $\alpha^t$ 作为权重，来计算 encoder hidden state 的加权和，得到 attention output： \boldsymbol{a}_{t}=\sum_{i=1}^{N} \alpha_{i}^{t} \boldsymbol{h}_{i} \in \mathbb{R}^{h} 最后，将 attention output 与 decoder hidden state 连接起来: \left[\boldsymbol{a}_{t} ; \boldsymbol{s}_{t}\right] \in \mathbb{R}^{2 h} Attention 的好处： Attention 提升了 NMT 性能 让 decoder 关注源序列确定部分是非常有用的 Attention 解决了瓶颈问题 Attention 允许 decoderr 直接关注源序列，可以绕过瓶颈 Attention 有助于解决梯度消失问题 提供了直接连接远处状态的捷径 Attention 提供了一些可解释性 通过 attention distribute，可以知道 decoder 关注的重点 可以轻易得到(软)对齐，因为无需特意训练一个对齐系统 网络自动学习对齐 Attention 机制不仅可以用于seq2seq，也可以用于其它结构和任务。一个 Attention 更一般的定义如下： 给定一组向量值(value)和一个向量查询(query)，注意力机制是一种根据查询计算值的加权和的技术。 Attention 的一般步骤： 有向量值(values) $h_1,\dots,h_N \in \mathbb{R}^{d_1}$ 和 向量查询(query) $s \in \mathbb{R}^{d_2}$ 、 计算 attention scores $e \in \mathbb{R}^N$ 求 softmax 得到 attention distribution $\alpha$: \alpha=\operatorname{softmax}(e) \in \mathbb{R}^{N} 用 attention distribution 来计算 values 的加权和： \boldsymbol{a}=\sum_{i=1}^{N} \alpha_{i} \boldsymbol{h}_{i} \in \mathbb{R}^{d_{1}}从而获得了 attention output $\boldsymbol{a}$，有时候也称为上下文向量(context vector) 在计算第二步的时候，有多种方法因此有多种 attention 变体： Basic dot-product attention：$e_i = s^T h_i \in \mathbb{R}$，注：此处假设 $d_1 = d_2$ Multiplicative attention: $e_i = s^TWh_i \in \mathbb{R}$，其中 $W \in \mathbb{R}^{d_2 \times d_1}$ 是权值矩阵 Additive attention：$e_i = v^T \tanh(W_1h_i +W_2s) \in \mathbb{R}$ 其中 $W_1 \in \mathbb{R}^{d_3 \times d_1} ， W_2 \in \mathbb{R}^{d_3 \times d_2}$ 是权值矩阵，$v \in \mathbb{R}^{d_3}$ 是权值向量 $d_3$ 是一个超参数 本文作者：Gong Jintao本文地址： https://gongjintao.com/post/4b37d30a.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RNN IN NLP]]></title>
    <url>%2Fpost%2F9994ec50.html</url>
    <content type="text"><![CDATA[RNN IN NLPRNN Language Model模型结构 首先是词嵌入层。 e^{(t)} = Ex^{(t)}其中$x^{(t)} \in \mathbb{R}^{|V|}$代表单词或单词的one-hot编码。 然后是隐藏层单元，每个隐藏层单元的状态都等于对应的词向量的加权再加上其前一个隐藏层状态的加权之和。再通过激活函数。即： \boldsymbol{h}^{(t)}=\sigma\left(\boldsymbol{W}_{h} \boldsymbol{h}^{(t-1)}+\boldsymbol{W}_{e} \boldsymbol{e}^{(t)}+\boldsymbol{b}_{1}\right)其中 $h^{(0)}$ 是初始的隐藏层状态。 注：其中 $W_h$ 和 $W_e$ 在每一时间步都是相同的。 最后的输出概率，如下： \hat{\boldsymbol{y}}^{(t)}=\operatorname{softmax}\left(\boldsymbol{U} \boldsymbol{h}^{(t)}+\boldsymbol{b}_{2}\right) \in \mathbb{R}^{|V|} 模型优缺点 优点： 可以处理任意长度的输入 理论上计算第 $t$ 步的值可以使用前面许多步的信息 输入规模的增加不会增加模型规模 对于每一个时间步所使用的权重参数是一样的，保证了对称性。 缺点： 递归计算速度较慢 在实践中，很难从前面的许多步骤获取信息 模型训练 输入：一个大规模文本语料库，$x^{(1)},\dots,x^{(T)}$ 输出：每个单词的概率，$\hat{y}^{(t)}$ 对于每个时间步的损失函数可定义为交叉熵损失函数： J^{(t)}(\theta)=C E\left(\boldsymbol{y}^{(t)}, \hat{\boldsymbol{y}}^{(t)}\right)=-\sum_{w \in V} \boldsymbol{y}_{w}^{(t)} \log \hat{\boldsymbol{y}}_{w}^{(t)}=-\log \hat{\boldsymbol{y}}_{x_{t+1}}^{(t)}其中 $y^{(t)}$ 即单词 $x^{(t+1)}$ 的one-hot编码。 对整个训练集的所有损失函数取平均得到整体损失： J(\theta)=\frac{1}{T} \sum_{t=1}^{T} J^{(t)}(\theta)=\frac{1}{T} \sum_{t=1}^{T}-\log \hat{\boldsymbol{y}}_{x_{t+1}}^{(t)}训练过程如图所示: 模型的反向传播： 每一个时间步的损失函数对 $W_h$ 求导结果为（这是多变量求导的链式法则)： \frac{\partial J^{(t)}}{\partial \boldsymbol{W}_{\boldsymbol{h}}}=\left.\sum_{i=1}^{t} \frac{\partial J^{(t)}}{\partial \boldsymbol{W}_{\boldsymbol{h}}}\right|_{(i)} 模型的评估通常使用困惑度来衡量语言模型的好坏，主要思想是，句子概率越大，困惑度越小，模型越好： RNN模型中困惑度也等于交叉熵损失函数的指数: 而RNN模型对比 n-gram 模型有更小的困惑度。 梯度消失和梯度爆炸问题直觉： 推导： 因为：$\boldsymbol{h}^{(t)}=\sigma\left(\boldsymbol{W}_{h} \boldsymbol{h}^{(t-1)}+\boldsymbol{W}_{x} \boldsymbol{x}^{(t)}+\boldsymbol{b}_{1}\right)$ 因此：$\frac{\partial \boldsymbol{h}^{(t)}}{\partial \boldsymbol{h}^{(t-1)}}=\operatorname{diag}\left(\sigma^{\prime}\left(\boldsymbol{W}_{h} \boldsymbol{h}^{(t-1)}+\boldsymbol{W}_{x} \boldsymbol{x}^{(t)}+\boldsymbol{b}_{1}\right)\right) \boldsymbol{W}_{h}$ 则第 $i$ 步的损失对前第 $j$ 步隐藏状态 $h^{(j)}$ 求导为： \begin{aligned} \frac{\partial J^{(i)}(\theta)}{\partial \boldsymbol{h}^{(j)}} &=\frac{\partial J^{(i)}(\theta)}{\partial \boldsymbol{h}^{(i)}} \prod_{j]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CNN IN NLP]]></title>
    <url>%2Fpost%2F51f80686.html</url>
    <content type="text"><![CDATA[NLP中的CNN（Convolutional Neural Networks for Sentence Classification) 卷积假设 $x_i \in \mathbb{R}^k$ 是一个 $k$ 维的词向量，对应句子中的第 $i$ 个单词。则一个长为 $n$ 的句子可以表示为: \mathbf{x}_{1: n}=\mathbf{x}_{1} \oplus \mathbf{x}_{2} \oplus \ldots \oplus \mathbf{x}_{n}其中 $\oplus$ 是连接符。通常，用 $\mathbf{X}_{i:i+j}$ 来表示单词 $\mathbf{x_i,x_{i+1},\cdots,x_{i+j}}$ 的连接。卷积操作中的卷积核 $ \mathbf{w} \in \mathbb{R}^{hk}$，应用于一个窗口大小为 $h$ 个词上以产生一个特征。即： c_i = f(\mathbf{w} \cdot \mathbf{x}_{i:i+h-1} + b)其中 $b \in \mathbb{R}$ 是偏置项。则在整个句子的每个 $h$ 大小的窗口上$\{\mathbf{x}_{1：h},\mathbf{x}_{2:h+1},\cdots, \mathbf{x}_{n-h+1:n}\}$可以产生一张特征图如下： \mathbf{c} = [c_1,c_2,\cdots,c_{n-h+1}]其中 $\mathbf{c} \in \mathbb{R}^{n-h+1}$。 上图即一个句子在一个 $h$ 为 3 的卷积核下的卷积操作得到的特征图。也可以在卷积操作中填充 padding。 池化层最大池化即选出特征图 $\mathbf{c} 中最大的值$。 均值池化即取特征图的均值 多通道和多卷积核即可以使用多个卷积核（有不同的窗口$h$）来代表 一元语法，二元语法，三元语法等。也可以对于同样的 $h$ 有多个卷积核 下图即不同的 CNN 模型： 正则化Dropout: 建立一个伯努利随机变量的 masking 向量 $r$ ，每个变量以 $p$ 的概率为1。则在训练过程中的输出为： y = \text{softmax} (W^{(S)}(r \circ z)+b)本文作者：Gong Jintao本文地址： https://gongjintao.com/post/51f80686.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Basic Embedding Model]]></title>
    <url>%2Fpost%2F603c955b.html</url>
    <content type="text"><![CDATA[Basic Embedding Model1. NNLM(Neural Network Language Model) 不同与 $n-gram$ 统计语言模型的一种神经网络语言模型，并且可以在计算出句子联合概率的同时，求出词向量，但是速度较慢。 模型可以分成两部分理解: 首先是一个线性的embedding 层。它将输入的 n−1 个one−hot词向量，通过一个共享的$|V| \times $的矩阵$C$，映射为 n−1 个分布式的词向量。其中，$|V|$是词典的大小，$m$ 是embedding向量的维度（一个先验参数）。$C $矩阵里存储了要学习的词向量。 其次是一个简单的前向反馈神经网络 g 。它由一个tanh 隐层和一个softmax 输出层组成。通过将embedding 层输出的N−1 个词向量映射为一个长度为 $|V| $ 的概率分布向量，从而对词典中的word 在输入 context 下的条件概率做出预估： \hat{P}\left(w_{t} | w_{1}^{t-1}\right) \approx f\left(i, w_{t-1}, \cdots, w_{t-n+1}\right)=g\left(i, C\left(w_{t-1}\right), \cdots, C\left(w_{t-n+1}\right)\right) 然后可以通过最小化一个cross−entropy 的正则化损失函数来调整模型的参数$\theta =(C,w)$： L = \frac{1}{T}\sum_t \log f(w_t,w_{t-1},\cdots,w_{t-n+1},\theta) + R(\theta)其中 $R(\theta)$ 为正则项。 上述模型中，自由参数的个数仅仅和$|V|$ 线性相关。然后神经网络模型通过计算如下式子，即softmax 层，来得到输出概率： \hat{P}(w_t|w_{t-1},\cdots,w_{t-n+1}) = \frac{e^{y_{w_t}}}{\sum_i e^{y_i}}其中$y_i$ 是每个单词$i$ 的未规范化对数概率，由下式计算： y = b + Wx + U\tanh(d+Hx)$\tanh$逐元素计算的。其中 $W$ 是可选为 0 的，$x$ 则是输入的单词向量连接而成的： x=\left(C\left(w_{t-1}\right), C\left(w_{t-2}\right), \cdots, C\left(w_{t-n+1}\right)\right)令 $h$ 为隐藏单元的数量，$m$ 是每个词的词向量维度。 参数$\theta = (b,d,W,U,H,C)$说明： $W$ 为词特征层到输出层权的值矩阵，大小为 $|V| \times (n-1)m$，当没有直接连接词特征与输出层时，设置为 0 $b$ 为输出偏置矩阵，大小为 $|V| $ $d$ 为隐藏层偏置矩阵，大小为 $h$ $U$ 为隐藏层到输出层的权值矩阵，大小为 $|V| \times h$ $H$ 为隐藏层的权值矩阵，大小为 $h \times (n-1)m$ $C$ 即嵌入矩阵(词向量)，大小为 $|V| \times m$ 通过随机梯度下降法的每一步迭代为： \theta \leftarrow \theta+\varepsilon \frac{\partial \log \hat{P}\left(w_{t} | w_{t-1}, \cdots w_{t-n+1}\right)}{\partial \theta}2.Word2vecword2vec有两种常用算法： continuous bag-of-words (CBOW) :根据词向量从周围语境中预测中心词 skip-gram: 从中心词预测上下文词的分布（概率) 两种训练方法： negative sampling(负采样)：采样负样例 hierarchical softmax(分层softmax)：使用一个有效的树结构来计算所有词的概率 2.1 CBOW 首先用 one-hot 编码来表示上下文单词 定义两个矩阵：$ \mathcal{V} \in \mathbb{R}^{n \times|V|} 和 \mathcal{U} \in \mathbb{R}^{|V|\times n}$ $\mathcal{V}$ 是输入矩阵，其第 $i$ 列 $v_i$ 是词 $w_i$ 的 $n$ 维嵌入向量，用来表示上下文； $\mathcal{U}$ 是输出矩阵，其第 $j$ 行 $u_i$ 是词 $w_j$ 的 $n$ 维嵌入向量，用来表示中心词； 所以对于每个词都学习了两个向量。 具体步骤： 对one-hot编码来表示输入上下文: m: (x^{(c-m)},\dots,x^{(c-1)},x^{(c+1)},\dots,x^{(c+m)} \in \mathbb{R}^{|V|}) 求得上下文的嵌入向量: (v_{c-m}=\mathcal{V}x^{(c-m)},v_{c-m+1}=\mathcal{V}x^{(c-m+1)},\dots,v_{c+m}=\mathcal{V}x^{(c+m)} \in \mathbb{R}^n) 对这些向量求平均值: \hat{v}=\frac{v_{c-m}+v_{c-m+1}+\ldots+v_{c+m}}{2 m} \in \mathbb{R}^{n} 生成记分向量$z$，因为点积越高，相似度越高，为了达到较高的分数，$z$ 会把相似的词推的更近： z = \mathcal{U}\hat{v} \in \mathbb{R}^{|V|} 将分数转化成概率 \hat{y} = \text{softmax}(z) \in \mathbb{R}^{|V|} 生成的概率$\hat{y} \in \mathbb{R}^{|V|}$ 与真实概率$y \in \mathbb{R}^{|V|}$相对比 求解两个矩阵 $\mathcal{U} 和 \mathcal{V}$ 的训练过程： 首先定义损失函数为交叉熵函数： H(\hat{y},y) = -\sum_{j=1}^{|V|}y_i \log(\hat{y_j})因为 $y$ 是one-hot 向量，因此损失函数可以简化为： H(\hat{y},y) = -y_i \log(\hat{y_i})所以最终的模型即： \begin{aligned} \text { minimize } J &=-\log P\left(w_{c} | w_{c-m}, \ldots, w_{c-1}, w_{c+1}, \ldots, w_{c+m}\right) \\ &=-\log P\left(u_{c} | \hat{v}\right) \\ &=-\log \frac{\exp \left(u_{c}^{T} \hat{v}\right)}{\sum_{j=1}^{|V|} \exp \left(u_{j}^{T} \hat{v}\right)} \\ &=-u_{c}^{T} \hat{v}+\log \sum_{j=1}^{|V|} \exp \left(u_{j}^{T} \hat{v}\right) \end{aligned} 然后用随机梯度下降法来更新所有的参数 $u_i,v_i$。 基本模型图如下所示： 2.2 skip-gram过程与 CBOW 相反，矩阵$ \mathcal{V} 和 \mathcal{U}$ 定义和上面相同 具体步骤： 用one-hot 编码来表示中心词 $x \in \mathbb{R}^{|V|}$ 得到中心词的嵌入单词向量 $v_c = \mathcal{V}x \in \mathbb{R}^n$ 计算得分向量 $z = \mathcal{U}v_c $ 将得分向量用 softmax 转换成概率 \hat{y} = \text{softmax}(z)$\hat{y}_{c-m}, \ldots, \hat{y}_{c-1}, \hat{y}_{c+1}, \ldots, \hat{y}_{c+m}$ 即对应上下文每个单词的概率 与真实单词$y^{(c-m)}, \ldots, y^{(c-1)}, y^{(c+1)}, \ldots, y^{(c+m)}$ 做对比 定义损失函数： 与 CBOW 不同之处在于，此处用到了朴素贝叶斯假设，即在给定中心词的条件下，输出词之间是相互独立的，所以有： \begin{aligned} \text{minimize} J &=-\log P\left(w_{c-m}, \ldots, w_{c-1}, w_{c+1}, \ldots, w_{c+m} | w_{c}\right) \\ &=-\log \prod_{j=0, j \neq m}^{2 m} P\left(w_{c-m+j} | w_{c}\right) \\ & =-\log \prod_{j=0, j \neq m}^{2 m} P\left(u_{c-m+j} | v_{c}\right) \\ & =-\log \prod_{j=0, j \neq m}^{2 m} \frac{\exp \left(u_{c-m+j}^{T} v_{c}\right)}{\sum_{k=1}^{|V|} \exp \left(u_{k}^{T} v_{c}\right)} \\ &=-\sum_{j=0, j \neq m}^{2 m} u_{c-m+j}^{T} v_{c}+2 m \log \sum_{k=1}^{|V|} \exp \left(u_{k}^{T} v_{c}\right) \end{aligned}最后用随机梯度下降求解。 基本模型如下图所示： 2.3 Negative Sampling(负采样)因为在计算目标函数的时候，$|V|$上的求和计算量很大。因此可以近似计算它。对于每一个训练步骤，我们不必在整个词汇表上循环，只需举几个反面的例子，我们从噪声分布(Pn(w))中采样，其概率与词汇的频率顺序相匹配。 用 $(w,c)$ 来表示单词和上下文 $P(D=1 |w,c)$ 表示$(w,c)$来自与语料库中的概率，$P(D=0 | w,c)$表示不是来自与语料库的概率。然后用 sigmoid 函数对 $P(D = 1 | w,c)$ 建模： P(D=1 | w, c, \theta)=\sigma\left(v_{c}^{T} v_{w}\right)=\frac{1}{1+e^{\left(-v_{c}^{T} v_{w}\right)}} 建立新的目标函数，使得 $P(D=1|w,c,\theta) 和 P(D=0|w,c,\theta)$ 最大化，$\theta$ 代表模型的参数，在 word2vec 中即 $\mathcal{V} 和 \mathcal{U}$。 \begin{aligned} \theta &=\underset{\theta}{\operatorname{argmax}} \prod_{(w, c) \in D} P(D=1 | w, c, \theta) \prod_{(w, c) \in \tilde{D}} P(D=0 | w, c, \theta) \\ &=\underset{\theta}{\operatorname{argmax}} \prod_{(w, c) \in D} P(D=1 | w, c, \theta) \prod_{(w, c) \in \tilde{D}}(1-P(D=1 | w, c, \theta)) \\ &=\underset{\theta}{\operatorname{argmax}} \sum_{(w, c) \in D} \log P(D=1 | w, c, \theta)+\sum_{(w, c) \in \tilde{D}} \log (1-P(D=1 | w, c, \theta)) \\ &=\underset{\theta}{\operatorname{argmax}} \sum_{(w, c) \in D} \log \frac{1}{1+\exp \left(-u_{w}^{T} v_{c}\right)}+\sum_{(w, c) \in \tilde{D}} \log \left(1-\frac{1}{1+\exp \left(-u_{w}^{T} v_{c}\right)}\right) \\ &=\underset{\theta}{\operatorname{argmax}} \sum_{(w, c) \in D} \log \frac{1}{1+\exp \left(-u_{w}^{T} v_{c}\right)}+\sum_{(w, c) \in \tilde{D}} \log \left(\frac{1}{1+\exp \left(u_{w}^{T} v_{c}\right)}\right) \\ &=\underset{\theta}{\operatorname{argmin}}- \sum_{(w, c) \in D} \log \frac{1}{1+\exp \left(-u_{w}^{T} v_{c}\right)}-\sum_{(w, c) \in \tilde{D}} \log \left(\frac{1}{1+\exp \left(u_{w}^{T} v_{c}\right)}\right) \end{aligned}$\tilde{D}$ 是“负”语料库，即里面是一些出现概率较低的语句。 对于 skip-gram ，在中心词是 $c$ 上下文是 $c-m+j$ 时，目标函数是： -\log \sigma\left(u_{c-m+j}^{T} \cdot v_{c}\right)-\sum_{k=1}^{K} \log \sigma\left(-\tilde{u}_{k}^{T} \cdot v_{c}\right)对于 CBOW ，当中心词是 $u_c$ ，上下文是 $\hat{v}=\frac{v_{c-m}+v_{c-m+1}+\ldots+v_{c+m}}{2 m}$时，目标函数是： -\log \sigma\left(u_{c}^{T} \cdot \hat{v}\right)-\sum_{k=1}^{K} \log \sigma\left(-\tilde{u}_{k}^{T} \cdot \hat{v}\right)上式中的$\{\tilde{u}_k |k=1,\dots,K \}$即从 $P_n(w)$ 中采样的负样本。负采样率建议是二元语法模型下词频的 3/4 次方。 2.4 Hierarchical softmax(分层softmax)分层 softmax 用一个二叉树来表示词典中的所有单词。每个叶子节点即一个单词，顶点到叶子节点都只有唯一的一条路径。该模型中没有表示单词的输出，而每个中间节点与将模型将要学习的向量相关联。 该模型中，$P(w|w_i)$ 等价于从根节点到与代表单词$w$ 的叶结点的随机游走概率，其最大的优点即时间复杂度只有$O(\log(|V|))$。 用$L(w)$ 表示从根节点到叶结点 $w$ 的路径长度，$n(w,i)$ 表示该路径中第 $i$ 个中间节点，则 $n(w,L(w))$ 即 $w$ 的父节点。现对每一个中间节点 $n$ ，我们任意选择其子节点中的一个，记为 $ch(n)$。则概率可由下式算出： P\left(w | w_{i}\right)=\prod_{j=1}^{L(w)-1} \sigma\left([n(w, j+1)=\operatorname{ch}(n(w, j))] \cdot v_{n(w, j)}^{T} v_{w_{i}}\right)where [x]=\left\{\begin{array}{l} 1 \text { if } x \text { is true } \\ -1 \text { otherwise } \end{array}\right.$\sigma(\cdot)$即 sigmoid 函数 3. GloVe(Global Vector) LSA和word2vec作为两大类方法的代表，一个是利用了全局特征的矩阵分解方法，一个是利用局部上下文的方法。GloVe模型就是将这两中特征合并到一起的，即使用了语料库的全局统计（overall statistics）特征，也使用了局部的上下文特征（即滑动窗口）。 首先引入共现矩阵(Co-occurrence Matrix) 用 $X$ 来表示词与词之间的共现矩阵，每个元素 $X_{ij}$ 表示词 $j$ 出现在词 $i$ 上下文的次数。$X_i = \sum_kX{ik}$ 表示出现在词 $i$ 上下文所有单词的次数。然后用 $P_{ij} = P(w_j|w_i) =\frac{X_{ij}}{X_i}$ 表示词 $j$ 出现在词上下文的概率。 最小二乘法 回顾 skip-gram 模型，我们用 softmax 来计算词 $j$ 出现在词 $i$ 上下文的概率： Q_{i j}=\frac{\exp \left(\vec{u}_{j}^{T} \vec{v}_{i}\right)}{\sum_{w=1}^{W} \exp \left(\vec{u}_{w}^{T} \vec{v}_{i}\right)}其损失函数定义如下： J=-\sum_{i \in \text {corpus}} \sum_{j \in \text {context}(i)} \log Q_{i j}由于相同的单词i和j可以在语料库中多次出现，因此首先将i和j的相同值组合在一起更有效: J=-\sum_{i=1}^{W} \sum_{j=1}^{W} X_{i j} \log Q_{i j}其中 $X_{ij}$ 即共现矩阵。交叉熵损失的一个显著缺点是它要求分布 $Q$ 被适当地规范化，这涉及到整个词汇表上昂贵的求和。相反，我们使用一个最小二乘目标，其中 $P$ 和 $Q$ 中的标准化因子被丢弃： \hat{J}=\sum_{i=1}^{W} \sum_{j=1}^{W} X_{i}\left(\hat{P}_{i j}-\hat{Q}_{i j}\right)^{2}其中 $\hat{P}_{ij} = X_{ij}, \hat{Q}_{ij} = \exp(\vec{u}_j^T\vec{v}_i)$ 。但这也导致了新的问题：$X_{ij}$ 具有非常大的值，使优化变得困难。一个有效的办法就是给 $\hat{P}$ 和 $\hat{Q}$ 加一个 log： \begin{aligned} \hat{J} &=\sum_{i=1}^{W} \sum_{j=1}^{W} X_{i}\left(\log (\hat{P})_{i j}-\log \left(\hat{Q}_{i j}\right)\right)^{2} \\ &=\sum_{i=1}^{W} \sum_{j=1}^{W} X_{i}\left(\vec{u}_{j}^{T} \vec{v}_{i}-\log X_{i j}\right)^{2} \end{aligned}另一个观察是，权重因子 $X_i$ 不能保证是最优的。相反，我们引入了一个更一般的加权函数，我们也可以根据上下文单词自由选择: \hat{J}=\sum_{i=1}^{W} \sum_{j=1}^{W} f\left(X_{i j}\right)\left(\vec{u}_{j}^{T} \vec{v}_{i}-\log X_{i j}\right)^{2} 结论 综上所述，GloVe 模型通过只训练单词共现矩阵中的非零元素，有效地利用了全局统计信息，生成了一个具有有意义子结构的向量空间。在相同的语料库、词汇、窗口大小和训练时间下，它在词汇类比任务上始终优于word2vec。它可以更快地获得更好的结果，而且无论速度如何，也可以获得最佳的结果。 4. FastText模型结构： 首先是权值矩阵 $A$ ，将单词 $x_1,x_2,\dots,x_{N-1},x_{N}$ 映射成词向量，然后再对这些词向量取平均，得到隐藏层的文本表示，作为线性分类器的输入。 通过线性分类器后的输出，再使用 softmax 函数 $f$ 得到预测类别的概率分布。 损失函数可表达为: -\frac{1}{N} \sum_{n=1}^{N} y_{n} \log \left(f\left(B A x_{n}\right)\right)该模型使用随机梯度下降法和线性衰减学习率来进行训练。 本文作者：Gong Jintao本文地址： https://gongjintao.com/post/603c955b.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《统计学习方法》——决策树]]></title>
    <url>%2Fpost%2Ff5fe0882.html</url>
    <content type="text"><![CDATA[5.1 决策树模型与学习5.1.1 决策树模型​ 定义：分类决策树模型是一种描述对实例进行分类的树形结构。决策树由结点（node）和有向边（directed edge）组成。结点有两种类型：内部结点（internal node）和叶结点（leaf node）。内部结点表示一个特征或属性，叶结点表示一个类。 5.1.2 决策树与if-then规则​ 由决策树的根结点到叶结点的每一条路径构建一条规则；路径上内部结点的的特征对应着规则的条件，而叶结点的类对应着规则的结论。决策树的路径或其对应的if-then规则集合具有一个重要的性质：互斥并且完备。即，每一个实例都被一条路径或一条规则所覆盖，而且只被一条路径或一条规则所覆盖。 5.1.3 决策树与条件概率分布5.1.4 决策树学习​ 学习的目标是根据给定的训练数据集构建一个决策树模型，使它能够对实例进行正确的分类。决策树学习本质上是从训练数据集中归纳出一组分类规则。与训练数据集不相矛盾的决策树（即能对训练数据进行正确分类的决策树）可能有多个，也可能一个也没有。我们需要的是一个与训练数据矛盾较小的决策树，同时具有很好的泛化能力。 ​ 决策树学习的损失函数通常是正则化的极大似然函数。决策树学习的策略是以损失函数为目标函数的最小化。因为从所有可能的决策树中选取最优决策树是NP完全问题，所以现实中决策树学习算法通常采用启发式方法，近似求解这一最优化问题。这样得到的决策树是次最优（sub-optimal）的。 ​ 决策树学习的算法通常是一个递归地选择最优特征，并根据该特征对训练数据进行分割，使得对各个子数据集有一个最好的分类的过程。 ​ 为了防止发生过拟合现象，我们需要对已生成的树自下而上进行剪枝，将树变得更简单，从而使它具有更好的泛化能力。具体地，就是去掉过于细分的叶结点，使其回退到父结点，甚至更高的结点，然后将父结点或更高的结点改为新的叶结点。 5.2 特征选择5.2.1 特征选择问题​ 特征选择在于选取对训练数据具有分类能力的特征。这样可以提高决策树学习的效率。如果利用一个特征进行分类的结果与随机分类的结果没有很大差别，则称这个特征是没有分类能力的。经验上扔掉这样的特征对决策树学习的精度影响不大。通常特征选择的准则是信息增益或信息增益比。 5.2.2 信息增益​ 首先给出熵 和 条件熵的定义 熵（entropy）是表示随机变量不确定性的度量。设X是一个取有限个值的离散随机变量，其概率分布为 P\left(X=x_{i}\right)=p_{i}, \quad i=1,2, \cdots, n则随机变量X的熵定义为 H(X)=-\sum_{i=1}^{n} p_{i} \log p_{i} 本文作者：Gong Jintao本文地址： https://gongjintao.com/post/f5fe0882.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>《统计学习方法》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《统计学习方法》——朴素贝叶斯法]]></title>
    <url>%2Fpost%2F6ca7c45e.html</url>
    <content type="text"><![CDATA[4.1 朴素贝叶斯法的学习与分类4.1.1 基本方法​ 设输入空间$x⊆\mathrm{R}_n$为n维向量的集合，输出空间为类标记集合$\mathcal{Y}＝\{c_1,c_2,\ldots,c_K\}$。输入为特征向量$x∊\mathcal{X}$，输出为类标记（class label)$y\in \mathcal{Y}$。$X$是定义在输入空间$\mathcal{X}$上的随机向量，$Y$是定义在输出空间$\mathcal{Y}$上的随机变量。$P(X,Y)$是$X$和$Y$的联合概率分布。训练数据集 T=\left\{\left(x_{1}, y_{1}\right),\left(x_{2}, y_{2}\right), \cdots,\left(x_{N}, y_{N}\right)\right\}由$P(X,Y)$独立同分布产生。 ​ 朴素贝叶斯法通过训练数据集学习联合概率分布$P(X,Y)$。具体地，学习以下先验概率分布及条件概率分布。先验概率分布 P\left(Y=c_{k}\right), \quad k=1,2, \cdots, K条件概率分布 P\left(X=x | Y=c_{k}\right)=P\left(X^{(1)}=x^{(1)}, \cdots,\left.X^{(n)}\right|^{(n)} | Y=c_{k}\right), \quad k=1,2, \cdots, K于是学习到联合概率分布$P(X,Y)$。 ​ 朴素贝叶斯法对条件概率分布作了条件独立性的假设，具体如下： \begin{aligned} P\left(X=x | Y=c_{k}\right) &=P\left(X^{(1)}=x^{(1)}, \cdots, X^{(n)}=x^{(n)} | Y=c_{k}\right) \\ &=\prod_{j=1}^{n} P\left(X^{(j)}=x^{(j)} | Y=c_{k}\right) \end{aligned}​ 朴素贝叶斯法分类时，对给定的输入$x$，通过学习到的模型计算后验概率分布$ P(Y＝c_k|X＝x)$，将后验概率最大的类作为$x$的类输出。后验概率计算根据贝叶斯定理进行： P\left(Y=c_{k} | X=x\right)=\frac{P\left(X=x | Y=c_{k}\right) P\left(Y=c_{k}\right)}{\sum_{k} P\left(X=x | Y=c_{k}\right) P\left(Y=c_{k}\right)}将条件独立性假设代入上式，则朴素贝叶斯分类器可表示为 y=f(x)=\arg \max _{c_{k}} \frac{P\left(Y=c_{k}\right) \prod_{j} P\left(X^{(j)}=x^{(j)} | Y=c_{k}\right)}{\sum_{k} P\left(Y=c_{k}\right) \prod_{j} P\left(X^{(j)}=x^{(j)} | Y=c_{k}\right)}因为对于所有的$c_k$上式的分母都是一样的，所以 y=\arg \max _{c_{k}} P\left(Y=c_{k}\right) \prod_{j} P\left(X^{(j)}=x^{(j)} | Y=c_{k}\right)4.1.2 后验概率最大化的含义​ 朴素贝叶斯法将实例分到后验概率最大的类中。这等价于期望风险最小化。 证明： 假设选择0-1损失函数，即： L(Y, f(X))=\left\{\begin{array}{ll}{1,} & {Y \neq f(X)} \\ {0,} & {Y=f(X)}\end{array}\right.这时期望风险函数为： R_{\mathrm{exp}}(f)=E[L(Y, f(X))]期望是对联合分布$P(X,Y)$取的。由此取条件期望 R_{\mathrm{exp}}(f)=E_{X} \sum_{k=1}^{K}\left[L\left(c_{k}, f(X)\right)\right] P\left(c_{k} | X\right)为了使期望风险最小化，只需对$X=x$逐个极小化，由此得到： \begin{aligned} f(x) &=\arg \min _{y \in \mathcal{Y}} \sum_{k=1}^{K} L\left(c_{k}, y\right) P\left(c_{k} | X=x\right) \\ &=\arg \min _{y \in \mathcal{Y}} \sum_{k=1}^{K} P\left(y \neq c_{k} | X=x\right) \\ &=\arg \min _{y \in \mathcal{Y}}\left(1-P\left(y=c_{k} | X=x\right)\right) \\ &=\arg \max _{y \in \mathcal{Y}} P\left(y=c_{k} | X=x\right) \end{aligned}即根据期望风险最小化准则就得到了后验概率最大化准则： f(x)=\arg \max _{c_{k}} P\left(c_{k} | X=x\right)4.2 朴素贝叶斯法的参数估计4.2.1 极大似然估计​ 朴素贝叶斯法中，学习意味着估计先验概率$P(Y＝c_k)$和条件概率$P(X^{(j)}＝x^{(j)}|Y＝c_k)$ 先验概率的极大似然估计是 P\left(Y=c_{k}\right)=\frac{\sum_{i=1}^{N} I\left(y_{i}=c_{k}\right)}{N}, \quad k=1,2, \cdots, K设第$j$个特征$x^{(j)}$可能取值的集合为$\{a_j1,a_j2,\ldots,a_{jSj} \}$，条件概率$P(x^{(j)}＝a_{jl}|Y＝c_k)$的极大似然估计是: \begin{array}{l}{\qquad P\left(X^{(j)}=a_{j l} | Y=c_{k}\right)=\frac{\sum_{i=1}^{N} I\left(x_{i}^{(j)}=a_{j l}, y_{i}=c_{k}\right)}{\sum_{i=1}^{N} I\left(y_{i}=c_{k}\right)}} \\ {j=1,2, \cdots, n ; \quad l=1,2, \cdots, S_{i} ; \quad k=1,2, \cdots, K}\end{array}式中，$x_i^{j}$是第$i$个样本的第$j$个特征；$a_{jl}$是第$j$个特征可能取的第$l$个值；$I$为指示函数。 4.2.2 学习与分类算法​ 朴素贝叶斯算法： 输入： 1. 训练数据$T=\left\{\left(x_{1}, y_{1}\right),\left(x_{2}, y_{2}\right), \ldots,\left(x_{N}, y_{N}\right)\right\}$，其中$x_{i}=\left(x_{i}^{(1)}, x_{i}^{(2)}, \cdots, x_{i}^{(n)}\right)^{\mathrm{T}}$，具体含义如上述。$y_i \in \{c_1,c_2,\ldots,c_K\}$; ​ 2. 实例$x$ 输出： 实例$x$的分类 算法步骤： 计算先验概率和条件概率： P\left(Y=c_{k}\right)=\frac{\sum_{i=1}^{N} I\left(y_{i}=c_{k}\right)}{N}, \quad k=1,2, \cdots, K \\ P\left(X^{(j)}=a_{j l} | Y=c_{k}\right)=\frac{\sum_{i=1}^{N} I\left(x_{i}^{(i)}=a_{jl}, y_{i}=c_{k}\right)}{\sum_{i=1}^{N} I\left(y_{i}=c_{k}\right)} \\ j=1,2, \cdots, n ; \quad l=1,2, \cdots, S_{j} ; \quad k=1,2, \cdots, K 对于给定的实例$x=\left(x^{(1)}, x^{(2)}, \ldots, x^{n)}\right)^{\mathrm{T}}$，计算 P\left(Y=c_{k}\right) \prod_{j=1}^{n} P\left(X^{(j)}=x^{(j)} | Y=c_{k}\right), \quad k=1,2, \cdots, K 确定实例$x$的类 y=\arg \max _{c_{k}} P\left(Y=c_{k}\right) \prod_{j=1}^{n} P\left(X^{(j)}=x^{(j)} | Y=c_{k}\right) 4.2.3 贝叶斯估计​ 用极大似然估计可能会出现所要估计的概率值为0的情况。这时会影响到后验概率的计算结果，使分类产生偏差。解决这一问题的方法是采用贝叶斯估计。 ​ 条件概率的贝叶斯估计： P_{\lambda}\left(X^{(j)}=a_{j l} | Y=c_{k}\right)=\frac{\sum_{i=1}^{N} I\left(x_{i}^{(j)}=a_{jl} ,y_{i}=c_{k}\right)+\lambda}{\sum_{i=1}^{N} I\left(y_{i}=c_{k}\right)+S_{j} \lambda}式中$\lambda \geqslant 0$。等价于在随机变量各个取值的频数上赋予一个正数$\lambda &gt; 0$.当$\lambda = 0$ 时就是极大似然估计。常取$\lambda = 1$ ，这时称为拉普拉斯平滑（Laplace smoothing）。 ​ 先验概率的贝叶斯估计为 ： P_{\lambda}\left(Y=c_{k}\right)=\frac{\sum_{i=1}^{N} I\left(y_{i}=c_{k}\right)+\lambda}{N+K \lambda}习题4.1 用极大似然估计法推出朴素贝叶斯法中的概率估计公式（4.8）及公式（4.9）。 证明：(4.8式) 设$p = P(Y = c_k)， m = \sum_{i=1}^{N}I(y_i = c_k)$，则似然函数为： L(p) = \tbinom{N}{m}p^{m}(1-p)^{N-m}​ 两边取对数可得： \ln(L(p)) = \ln\tbinom{N}{m} + m\ln p + (N-m)\ln (1-p)​ 然后对$p$ 求导，并令等式等于 $0$ 可得： \frac{m}{p} - \frac{N-m}{1-p} = 0 \\​ 解得$p = \frac{m}{N} $，即 P(Y= c_k) = \frac{\sum_{i=1}^{N}I(y_i=c_k)}{N}​ （4.9式）设$p = P(X^{(j)} =a_{jl} | Y = c_k) ，m = \sum_{i=1}^{N}I(x_i^{(j)} = a_{jl},y_i = c_k ) , n = \sum_{i=1}^{N}I(y_i = c_k)$ ​ 则似然函数为： L(p) = \tbinom{n}{m}p^{m}(1-p)^{n-m}​ 两边取对数得： \ln(L(p)) = \ln \tbinom{n}{m} + m \ln p + (n-m)\ln(1-p)​ 然后两边对$p$求导，并令等式等于$0$可得 \frac{m}{p} - \frac{n-m}{1-p} = 0​ 解得$p = \frac{m}{n}$，即 P(X^{(j)} =a_{jl} | Y = c_k) = \frac{ \sum_{i=1}^{N}I(x_i^{(j)} = a_{jl})}{\sum_{i=1}^{N}I(y_i = c_k)}4.2 用贝叶斯估计法推出朴素贝叶斯法中的概率估计公式（4.10）及公式（4.11）。 TODO 本文作者：Gong Jintao本文地址： https://gongjintao.com/post/6ca7c45e.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>《统计学习方法》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习算法源码之k近邻算法]]></title>
    <url>%2Fpost%2F5e870969.html</url>
    <content type="text"><![CDATA[KD树实现KNN算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124import numpy as npimport matplotlib.pyplot as plt# 创建结点类class Node(object): def __init__(self): self.lchild = None self.rchild = None self.feature = None # 结点的特征向量 self.axes = None # 结点的划分平面所在的维度 def get_str(self): # 返回结点的信息 return [self.lchild,self.rchild,self.feature,self.axes]class KDTree(object): def __init__(self,input_x,input_y): self._input_x = input_x self._input_y = input_y self._nearest = [] # 用于存储离目标点最近的点,包括特征向量，距离，和标签 # 构建KD树 def build_tree(self): return self._build_tree(self._input_x,0) def _build_tree(self, data, r): root = Node() [n, m] = np.shape(data) if n == 0: return # 对data的第r维坐标进行排序 sorted_data = data[data[:, r].argsort()] # 取中间的元素 mid = n//2 root.feature = sorted_data[mid] root.axes = r # 更新r r = (r + 1) % m root.lchild = self._build_tree(sorted_data[:mid], r) root.rchild = self._build_tree(sorted_data[mid + 1:], r) return root def _get_distance(self,a,b): return np.sqrt(sum((a-b)**2)) # 求离目标点最近的k个点 def _check_nearest(self,current,target,k): d = self._get_distance(current,target) l = len(self._nearest) if l &lt; k: self._nearest.append([current,d]) else: farthest_d = self._get_farthest()[1] if farthest_d &gt; d: # 将最远点移除 new_nearest = [item for item in self._nearest if item[1] &lt; farthest_d] new_nearest.append([current,d]) self._nearest = new_nearest # 找出_nearest中距离目标点最远的点 def _get_farthest(self): farthest = None for item in self._nearest: if not farthest: farthest = item elif farthest[1] &lt; item[1]: farthest = item return farthest # 在以tree为根结点的树中寻找叶结点，并将查找路径保存在stack中 def _search_leaf(self,tree,target,stack): travel_tree = tree while travel_tree: [lchild,rchild,feature,axes] = travel_tree.get_str() if target[axes] &gt;= feature[axes]: next_node = rchild next_direction = 'right' # 记录哪个方向被访问过了 elif target[axes] &lt; feature[axes]: next_node = lchild next_direction = 'left' stack.append([travel_tree,next_direction]) travel_tree = next_node # 搜索kd树 def search_kd_tree(self,tree,target,k=1): stack = [] self._search_leaf(tree,target,stack) # 一直搜索到叶结点，并将路径入栈 while stack: [node,next_direction] = stack.pop() #出栈 # 当前结点的信息 [lchild,rchild,feature,axes] = node.get_str() self._check_nearest(feature,target,k) # 检查当前结点的距离 if node.lchild and node.rchild is None: #如果当前结点是叶子结点，继续下一个循环 continue [farthest,distance] = self._get_farthest() if abs(feature[axes] - farthest[axes]) &lt; distance: # 如果当前结点的轴经过了圆 if next_direction == 'right': try_node = lchild else: try_node = rchild self._search_leaf(try_node,target,stack) return self._nearest # 分类 def classify(self): types = dict() for item in self._nearest: if item[-1] in types: types[item[-1]] += 1 else: types[item[-1]] = 1 return max(types,key=types.get) 123456789101112131415161718192021222324252627282930313233343536373839if __name__ == '__main__': data = np.array([[6.27, 5.50], [1.24, -2.86], [17.05, -12.79], [-6.88, -5.40], [-2.96, -0.50], [7.75, -22.68], [10.80, -5.03], [-4.60, -10.55], [-4.96, 12.61], [1.75, 12.26], [15.31, -13.16], [7.83, 15.70], [14.63, -0.35]]) labels = np.array([1,2,3,2,2,3,3,2,1,1,3,1,3]) kd = KDTree(data,labels) tree = kd.build_tree() target = [-1,-5] # 求离点(-1,-5)最近的三个点 nearest = kd.search_kd_tree(tree,target,3) print(nearest) plt.figure(dpi=100) # 指定像素 for i in range(len(labels)): if labels[i] ==1: color = 'c' elif labels[i] == 2: color = 'b' else: color = 'g' plt.scatter(data[i][0],data[i][1],c=color,s=30,alpha=0.8) plt.scatter(target[0],target[1],c='r',s=30,alpha=0.8) for item in nearest: plt.plot([target[0],item[0][0]],[target[1],item[0][1]],'r--') plt.show() 1[[array([ 1.24, -2.86]), 3.0979347959568164], [array([-6.88, -5.4 ]), 5.89358973801197], [array([-2.96, -0.5 ]), 4.908319468005317]] 参考自此处 https://www.joinquant.com/view/community/detail/bb850ee76d1cae16cc587f29c4439ebd) 本文作者：Gong Jintao本文地址： https://gongjintao.com/post/5e870969.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《统计学习方法》——k近邻算法]]></title>
    <url>%2Fpost%2F8f99d48c.html</url>
    <content type="text"><![CDATA[3.1 k近邻算法​ k近邻法（k-nearest neighbor，k-NN）是一种基本分类与回归方法。k近邻法的输入为实例的特征向量，对应于特征空间的点；输出为实例的类别，可以取多类。k近邻法假设给定一个训练数据集，其中的实例类别已定。分类时，对新的实例，根据其k个最近邻的训练实例的类别，通过多数表决等方式进行预测。 ​ 算法如下： 输入： 训练数据集 $T=\left\{\left(x_{1}, y_{1}\right),\left(x_{2}, y_{2}\right), \cdots,\left(x_{N}, y_{N}\right)\right\}$，其中，$x_i \in \mathcal{X} \subseteq \mathrm{R}^{n}$为实例的特证向量，$y_i \in \mathcal{Y} = \{c_1,c_2,\ldots,c_K\}$为实例的类别，$i = 1,2,\ldots,N$; 实例特征向量$x$ 输出： 实例$x$所属的类$y$。 算法步骤： 根据给定的距离度量，在训练集 $T$ 中找出与 $x$ 最邻近的 $k$ 个点，涵盖这 $k$ 个点的$x$的邻域记作$N_k(x)$； 在$N_k(x)$ 中根据分类决策规则 (如多数表决) 决定 $x$ 的类别 $y$： y=\arg \max _{c_{j}} \sum_{x_{i} \in N_{k}(x)} I\left(y_{i}=c_{j}\right), \quad i=1,2, \cdots, N ; \quad j=1,2, \cdots, K$I$为指示函数，即当 $y_i＝c_j$ 时 $I$ 为1，否则 $I$ 为0。 3.2 k近邻模型​ k近邻法使用的模型实际上对应于对特征空间的划分。模型由三个基本要素——距离度量、k值的选择和分类决策规则决定。 3.2.1 模型​ 特征空间中，对每个训练实例点 $x_i$，距离该点比其他点更近的所有点组成一个区域，叫作单元（cell）。每个训练实例点拥有一个单元，所有训练实例点的单元构成对特征空间的一个划分。最近邻法将实例 $x_i$的类 $y_i$作为其单元中所有点的$类标记（class label）$。这样，每个单元的实例点的类别是确定的。 3.2.2 距离度量​ 特征空间中两个实例点的距离是两个实例点相似程度的反映。k近邻模型的特征空间一般是$n$ 维实数向量空间$\mathrm{R}^n$。使用的距离是欧氏距离，但也可以是其他距离，如更一般的Lp距离（Lp distance）或Minkowski距离（Minkowski distance）。 $x_{i}=\left(x_{i}^{(1)}, x_{i}^{(2)}, \cdots, x_{i}^{(n)}\right)^{\mathrm{T}} ,x_{j}=\left(x_{j}^{(1)}, x_{j}^{(2)}, \cdots, x_{j}^{(n)}\right)^{\mathrm{T}}$ $L_p距离定义为$ ：$L_{p}\left(x_{i}, x_{j}\right)=\left(\sum_{l=1}^{n}\left|x_{i}^{(l)}-x_{j}^{(l)}\right|^{p}\right)^{\frac{1}{p}}$ 当 $p=2$ ,则为欧氏距离； 当 $p = 1$ ，则为曼哈顿距离 当 $p = \infty$，则是各个坐标距离的最大值，或称切比雪夫距离。 3.2.3 k值的选择​ k值的减小就意味着整体模型变得复杂，容易发生过拟合。k值的增大就意味着整体的模型变得简单。在应用中，k值一般取一个比较小的数值。通常采用交叉验证法来选取最优的k值。 3.2.4 分类决策规则​ 多数表决规则（majority voting rule）有如下解释：如果分类的损失函数为0-1损失函数，分类函数为 f: \mathrm{R}^{n} \rightarrow \{ c_1,c_2,\ldots,c_K\}那么误分类的概率是 P(Y \neq f(X)) = 1 - P(Y = f(X))对给定的实例$x\in \mathcal{X}$，其最近邻的 k 个训练实例点构成集合$N_k(x)$。如果涵盖$N_k(x)$的区域的类别是$c_j$，那么误分类率是 \frac{1}{k} \sum_{x_{i} \in N_{k}(x)} I\left(y_{i} \neq c_{j}\right)=1-\frac{1}{k} \sum_{x_{i} \in N_{k}(x)} I\left(y_{i}=c_{j}\right)要使误分类率最小即经验风险最小，就要使$\sum_{x_{i} \in N_{k}(x)} I\left(y_{i}=c_{j}\right)$最大。 3.3 k近邻法的实现：kd树​ 实现k近邻法时，主要考虑的问题是如何对训练数据进行快速k近邻搜索。 3.3.1 构造kd树​ kd树是一种对k维空间中的实例点进行存储以便对其进行快速检索的树形数据结构。kd树是二叉树，表示对k维空间的一个划分（partition）。构造kd树相当于不断地用垂直于坐标轴的超平面将k维空间切分，构成一系列的k维超矩形区域。kd树的每个结点对应于一个k维超矩形区域。构造kd树的算法如下： 输入：k维空间数据集$T＝\{x_1，x_2,\ldots,x_N\}$,其中 $x_i =\left(x_{i}^{(1)}, x_{i}^{(2)}, \cdots, x_{i}^{(k)}\right)^{\mathrm{T}}, i = 1,2,\ldots,N$; 输出：kd树 算法步骤： 选择 $x^{(1)}$ 为坐标轴，以$T$ 中所有实例的 $x^{(1)}$ 坐标的中位数 为切分点，将根结点对应的超矩形区域切分为两个子区域。切分由通过切分点并与坐标轴$x^{(1)}$垂直的超平面实现。由根结点生成深度为 1 的左、右子结点：左子结点对应坐标$x^{(1)}$ 小于切分点的子区域，右子结点对应坐标$x^{(1)}$ 大于切分点的子区域。将落在切分超平面上的实例点保存在根结点。 重复：对深度为 j 的结点，按 1 的方法进行切分，只不过是将上标 1 换成 $l, l = j(\mathrm{mod} k) + 1$ 直到两个子区域没有实例存在时停止。从而形成kd树的区域划分。 3.3.2 搜索kd树​ 用kd树的最近邻搜索算法如下： 输入： 1. 已构造的 kd 树；2. 目标点 x； 输出： x 的最近邻。 算法步骤： 在 kd 树中找到包含目标点 x 的叶结点： 从根结点出发，递归地向下访问kd树。若目标点 x 当前维的坐标小于切分点的坐标，则移动到左子结点，否则移动到右子结点。直到子结点为叶结点为止。 以此叶结点为“当前最近点” 递归地向上回退，在每个结点进行一下操作： 如果该结点保存的实例点比当前最近点距离目标点更近，则以该实例点为“当前最近点” 当前最近点一定存在于该结点一个子结点对应的区域。检查该子结点的父结点的另一子结点对应的区域是否有更近的点。如果有则移动到该点，如果没有，向上回退。 当回退到根结点时，搜索结束。最后的“当前最近点”即为 x 的最近邻点。 ​ 此处的 $KD$树 仅是找出距离目标点的最近的点，对应k近邻算法中的k=1；如果 k ≥ 2，则可以设置一个 k 维数组用于存储距离目标点最近的 k 个实例。然后用下面这一步代替上面算法步骤中 3 的第一小步。 当递归到$KD$树的某一结点时， 如果数组长度小于 k，则将该结点添加到数组； 如果数组长度等于 k，则比较该节点到目标点的距离与数组中的最大距离，若大于数组中的最大距离，则继续下一步，否则用该结点替换数组中最大距离的那个实例 具体算法步骤可以参考知乎上这篇文章——kd 树算法之详细篇。 习题​ 3.1 参照图3.1，在二维空间中给出实例点，画出k为1和2时的k近邻法构成的空间划分，并对其进行比较，体会k值选择与模型复杂度及预测准确率的关系。 ​ Todo ​ 3.2 利用例题3.2构造的kd树求点$x＝(3, 4.5)^\mathrm{T}$的最近邻点。 ​ 解： 从根结点$(7,2)$出发，向下访问 kd树 ，依次比较$x^{(1)}, x^{(2)},,x^{(1) } $找到包含目标结点$(3,4.5)$ 的叶结点$(4,7)$。以$(4,7)$为“当前最近点”，距离约为 2.69。 递归向上回退到$(5,4)$，距$(3,4.5)$约2.06，所以更新“当前最近点”为$(5,4)$ 以$(3,4.5)$为圆心，到“当前最近点”$(5,4)$距离为半径的圆和以$(5,4)$为父结点的另一个子结点$(2,3)$所在的区域相交，于是移动到$(2,3)$ 移动到$(2,3)$，发现距离$(3,4.5)$约1.80，于是更新“当前最近点”为(2,3);由于$(2,3)$是叶结点，所以 直接回退 回退到根结点$(7,2)$，$(3,4.5)$与根结点距离约为4.72，大于到“当前最近点”的距离；同时以$(3,4.5)$为圆心，以与到“当前最近点”的距离为半径的圆和 根结点的另一个子结点$(9,6)$所在的区域不相交。所以搜索结束，得到最近点$(2,3)$ 3.3 参照算法3.3，写出输出为x的k近邻的算法。 本文作者：Gong Jintao本文地址： https://gongjintao.com/post/8f99d48c.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>《统计学习方法》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习算法源码之感知机]]></title>
    <url>%2Fpost%2F86fbaf80.html</url>
    <content type="text"><![CDATA[感知机算法的原始形式123456789101112131415161718192021222324252627282930313233343536373839404142import numpy as npimport matplotlib.pyplot as plt# 生成数据集data = np.asarray([[3, 3], [4, 3], [1, 1]])label = np.asarray([1, 1, -1])# 初始化参数w = np.asarray([0, 0])b = 0learning_rate = 1# 误分类个数为数据集的长度N = len(data)while N &gt; 0: for i in range(len(data)): # 选取数据 sample = data[i] # 计算损失函数 loss = label[i] * (w.dot(sample.transpose()) + b) if loss &lt;= 0: # 更新参数 w = w + learning_rate * label[i] * sample b = b + learning_rate * label[i] N = N if N==len(data) else N+1 else: # 误分类个数减1 N -= 1 print(w,b) %matplotlib inlineplt.scatter(data[:2, 0],data[:2, 1], marker='+')plt.scatter(data[-1, 0],data[-1, 1])line_x = np.arange(0,5,0.01)line_y = -(w[0] * line_x + b) / w[1]plt.plot(line_x, line_y)plt.show() 123456[2 2] 0[1 1] -1[0 0] -2[2 2] -2[1 1] -3[1 1] -3 感知机算法的对偶形式12345678910111213141516171819202122232425262728293031323334353637383940414243import numpy as npimport matplotlib.pyplot as plt# 输入数据集data = np.asarray([[3, 3], [4, 3], [1, 1]])label = np.asarray([1, 1, -1])# 初始化参数alpha = np.zeros(3)b = 0learning_rate = 1# 计算Gram矩阵G = np.asarray([[x.dot(y) for x in data ] for y in data])# 误分类个数为数据集的长度N = len(data)while N &gt; 0: for i in range(len(data)): sample = data[i] loss = label[i]*(np.dot(alpha*label,G[:,i]) + b) if loss &lt;= 0: # 更新参数 alpha[i] = alpha[i] + learning_rate b = b + learning_rate * label[i] N = N if N==len(data) else N+1 else: # 误分类个数减1 N -= 1 print(alpha,b) # 求出 ww = np.dot(data.T,alpha*label)print(w) %matplotlib inlineplt.scatter(data[:2, 0],data[:2, 1], marker='+')plt.scatter(data[-1, 0],data[-1, 1])line_x = np.arange(0,5,0.01)line_y = -(w[0] * line_x + b) / w[1]plt.plot(line_x, line_y)plt.show() 1234567[1. 0. 1.] 0[1. 0. 2.] -1[1. 0. 3.] -2[2. 0. 4.] -2[2. 0. 5.] -3[2. 0. 5.] -3[1. 1.] 本文作者：Gong Jintao本文地址： https://gongjintao.com/post/86fbaf80.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《统计学习方法》——感知机]]></title>
    <url>%2Fpost%2F607b5cc4.html</url>
    <content type="text"><![CDATA[2.1 感知机模型定义 假设输入空间 （特征空间）是$\mathcal{X}\subseteq R^n$，输出空间是$\mathcal{Y} = \{+1,-1\}$。输入$x \in \mathcal{X}$表示实例的特征向量，对应于输入空间（特征空间）的点；输出$y \in \mathcal{Y}$ 表示实例的类别。由输入空间到输出空间的如下函数 f(x)=\operatorname{sign}(w \cdot x+b)称为感知机。其中，$w$和$b$为感知机模型参数，$w \in R^n$叫作权值（weight）或权值向量（weight vector），$b\in R$叫作偏置（bias），$w·x$表示$w$和$x$的内积。sign是符号函数。 感知机是一种线性分类模型，属于判别模型。感知机模型的假设空间是定义在特征空间中的所有线性分类模型（linear classification model）或线性分类器(linear classifier)，即函数集合$\{f | f(x)=w\cdot x+b\}$。对应于特征空间$R^n$中的一个超平面 $S$，其中$w$是超平面的法向量，$b$是超平面的截距。这个超平面将特征空间划分为两个部分。位于两部分的点（特征向量）分别被分为正、负两类。 2.2 感知机学习策略2.2.1 数据集的线性可分性定义 给定一个数据集 $T=\left\{\left(x_{1}, y_{1}\right),\left(x_{2}, y_{2}\right), \cdots,\left(x_{N}, y_{N}\right)\right\}$，其中,$x_i \in \mathcal{X}=R^n, y_i \in \mathcal{Y}=\{+1,-1\}, \quad i=1,2, \ldots, N$，如果存在某个超平面 $S$ w \cdot x + b=0能够将数据集的正实例点和负实例点完全正确地划分到超平面的两侧，即对所有 $y_i = +1$ 的实例$i$，有$w·xi+b&gt;0$，对所有 $y_i＝-1$ 的实例 $i$，有 $w·xi+b&lt;0$，则称数据集 $T$ 为线性可分数据集（linearly separable data set）；否则，称数据集 $T$ 线性不可分。 2.2.2 感知机学习策略​ 感知机确定了一个学习策略，即定义（经验）损失函数并将损失函数极小化，该损失函数即误分类点到超平面 $S$ 的总距离。给定训练数据集 T=\left\{\left(x_{1}, y_{1}\right),\left(x_{2}, y_{2}\right), \cdots,\left(x_{N}, y_{N}\right)\right\}其中，$x_i \in \mathcal{X}=R^n, y_i \in \mathcal{Y}=\{+1,-1\}, \quad i=1,2, \ldots, N$。感知机$\operatorname{sign}(w \cdot x+b)$学习的损失函数定义为 L(w, b)=-\sum_{x_{i} \in M} y_{i}\left(w \cdot x_{i}+b\right)其中$M$为误分类点的集合。这个损失函数就是感知机学习的经验风险函数。感知机学习的策略是在假设空间中选取使损失函数式（4）最小的模型参数$ w,b $，即感知机模型。 2.3 感知机学习算法2.3.1 感知机学习算法的原始形式感知机学习算法是对以下最优化问题的算法: \min _{w, b} L(w, b)=-\sum_{x_{i} \in M} y_{i}\left(w \cdot x_{i}+b\right)我们采用随机梯度下降法(stochastic gradient descent)。算法如下： 输入： $T=\left\{\left(x_{1}, y_{1}\right),\left(x_{2}, y_{2}\right), \cdots,\left(x_{N}, y_{N}\right)\right\}$， 其中$x_i \in \mathcal{X}=R^n, y_i \in \mathcal{Y}=\{+1,-1\}, \quad i=1,2, \ldots, N$ 学习率 $\eta(0&lt;\eta \leqslant1)$ 输出： $ w,b;感知机模型 f(x) = \operatorname{sign}(w \cdot x+b) $ 。 算法步骤： 选取初值$w_0,b_0$ 在训练集中选取数据$(x_i,y_i)$ 如果$y_i(w \cdot x_i + b) \leqslant 0$ w \leftarrow w + \eta y_ix_i\\ b \leftarrow b + \eta y_i 转至 2 ，直至训练集中没有误分类点。 2.3.2 算法的收敛性​ 对于线性可分数据集感知机学习算法原始形式收敛，即经过有限次迭代可以得到一个将训练数据集完全正确划分的分离超平面及感知机模型。所以只需证明迭代次数$k$有上界即可。 2.3.3 感知机学习算法的对偶形式​ 对偶形式的基本想法是，将$w$和$b$表示为实例$x_i$和标记$y_i$的线性组合的形式，通过求解其系数而求得$w$和$b$。设初始值$w_0=0,b_0=0$，误分类点$(x_i,y_i)$在更新过程中被使用的次数为$ n_i $，则最后学习到的$w和b$可以分别表示为 w = \sum_{i=1}^{N}\alpha_i y_i x_i\\ b = \sum_{i=1}^{N} \alpha_i y_i其中，$\alpha_i = n_i \eta i= 1,2,\ldots,N$。实例点更新次数越多，意味着它距离分离超平面越近，也就越难正确分类。感知机学习算法的对偶形式具体如下： 输入： $T=\left\{\left(x_{1}, y_{1}\right),\left(x_{2}, y_{2}\right), \cdots,\left(x_{N}, y_{N}\right)\right\}$， 其中$x_i \in \mathcal{X}=R^n, y_i \in \mathcal{Y}=\{+1,-1\}, \quad i=1,2, \ldots, N$ 学习率 $\eta(0&lt;\eta \leqslant1)$ 输出： $ \alpha ,b; 感知机模型 f(x) =\operatorname{sign}\left(\sum_{j=1}^{N} \alpha_{j} y_{j} x_{j} \cdot x+b\right), 其中a = (a_1,a_2,\ldots,a_N)^{\mathrm{T}}$ 算法步骤： $a \leftarrow 0, b \leftarrow 0 $ 在训练集中选取数据$(x_i,y_i)$ 如果$y_{i}\left(\sum_{j=1}^{N} \alpha_{j} y_{j} x_{j} \cdot x_{i}+b\right) \leqslant 0$ \begin{array}{c}{\alpha_{i} \leftarrow \alpha_{i}+\eta} \\ {b \leftarrow b+\eta y_{i}}\end{array} 转至2直到没有误分类数据。 ​ 对偶形式中可知训练实例仅以内积的形式出现。可以预先将训练集中实例间的内积计算出来并以矩阵的形式存储，这个矩阵就是所谓的Gram矩阵（Gram matrix）。 G=\left[x_{i} \cdot x_{j}\right]_{N \times N}习题​ 2.1 Minsky与Papert指出：感知机因为是线性模型，所以不能表示复杂的函数，如异或（XOR）。验证感知机为什么不能表示异或。 ​ 解：异或函数(XOR)表示如下： $x_{1}$ $x_{2}$ $x_{1} \oplus x_{2}$ 1 0 1 1 1 0 0 0 0 0 1 1 ​ 在图中展示如下： ​ ​ 显然异或的数据集是线性不可分的，我们无法用一条直线将两类样本划分，所以感知机不能表示异或。 ​ 2.2 模仿例题2.1，构建从训练数据集求解感知机模型的例子。 ​ 参考此文 ​ 2.3 证明以下定理：样本集线性可分的充分必要条件是正实例点集所构成的凸壳与负实例点集所构成的凸壳互不相交。 ​ Todo 本文作者：Gong Jintao本文地址： https://gongjintao.com/post/607b5cc4.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>《统计学习方法》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《统计学习方法》——概论]]></title>
    <url>%2Fpost%2Fc179653c.html</url>
    <content type="text"><![CDATA[1.1 统计学习 定义：统计学习（statistical learning）是关于计算机基于数据构建概率统计模型并运用模型对数据进行预测与分析的一门学科。统计学习也称为统计机器学习（statistical machine learning）。 1.1.1 特点 建立在计算机及网络之上的 以数据为研究对象 目的是对数据进行预测与分析 以方法为中心 包含了概率论、统计学、信息论、计算理论、最优化理论及计算机科学等多个领域，并且在发展中逐步形成独自的理论体系与方法论。 1.1.2 对象 ​ 统计学习的对象是数据（data）。它从数据出发，提取数据的特征，抽象出数据的模型，发现数据中的知识，又回到对数据的分析与预测中去。 ​ 统计学习关于数据的基本假设是同类数据具有一定的统计规律性，这是统计学习的前提。由于它们具有统计规律性，所以可以用概率统计方法来加以处理。比如，可以用随机变量描述数据中的特征，用概率分布描述数据的统计规律。 ​ 在统计学习过程中，以变量或变量组表示数据。数据分为由连续变量和离散变量表示的类型。 1.1.3 目的 ​ 统计学习总的目标就是考虑学习什么样的模型和如何学习模型，以使模型能对数据进行准确的预测与分析，同时也要考虑尽可能地提高学习效率。 1.1.4 方法 统计学习包括： 监督学习(supervised learning) 非监督学习(unsupervised learning) 半监督学习(semi-supervised learning) 强化学习(reinforcement learning) 监督学习的方法可以概括成：从给定的、有限的、用于学习的训练数据(training data)集合出发，假设数据是独立同分布产生的；并且假设要学习的模型属于某个函数的集合，称为假设空间(hypothesis space)；应用某个评价准则(evaluation criterion)，从假设空间中选取一个最优的模型，使它对已知训练数据及未知测试数据(test data)在给定的评价准则下有最优的预测；最优模型的选取由算法实现。所以统计学习方法的三要素，分别为模型（model）、策略（strategy）和算法（algorithm）。 实现统计学习方法的步骤如下： 得到一个有限的训练数据集合； 确定包含所有可能的模型的假设空间，即学习模型的集合； 确定模型选择的准则，即学习的策略； 实现求解最优模型的算法，即学习的算法； 通过学习方法选择最优模型； 利用学习的最优模型对新数据进行预测或分析。 监督学习的主要应用问题： 分类问题 标注问题 回归问题 1.1.5 研究 统计学习研究一般包括统计学习方法（statistical learning method）、统计学习理论（statistical learning theory）及统计学习应用（application of statistical learning）三个方面。 统计学习方法：开发新的学习方法 统计学习理论：探求统计学习方法的有效性与效率，以及统计学习的基本理论问题 统计学习应用：考虑将统计学习方法应用到实际问题中去，解决实际问题 1.1.6 重要性 统计学习是处理海量数据的有效方法。 统计学习是计算机智能化的有效手段。 统计学习是计算机科学发展的一个重要组成部分。 1.2 监督学习1.2.1 基本概念 输入空间（input space）: 输入的所有可能取值的集合。 输出空间（output space）: 输出的所有可能 取值的集合。 特征空间（feature space）：每个具体的输入是一个实例（instance），通常由特征向量（feature vector）表示。这时，所有特征向量存在的空间称为特征空间（feature space）。模型实际上都是定义在特征空间上的。 根据输入、输出变量的不同类型，对预测任务给予不同的名称： 均为连续变量：回归问题 输出变量为有限个离散变量：分类问题 均为变量序列：标注问题 联合概率分布: 监督学习假设输入与输出的随机变量 X 和 Y 遵循联合概率分布P(X,Y)。P(X,Y)表示分布函数，或分布密度函数。 假设空间（hypothesis space）: 监督学习的目的在于学习一个由输入到输出的映射，这一映射由模型来表示。模型属于由输入空间到输出空间的映射的集合，这个集合就是假设空间。 监督学习的模型可以是概率模型或非概率模型，由条件概率分布P(Y|X)或决策函数（decision function）Y=f(X)表示，随具体学习方法而定。对具体的输入进行相应的输出预测时，写作P(y|x)或Y=f(x)。 1.2.2 问题的形式化 1.3 统计学习三要素 方法 = 模型＋策略 + 算法 1.3.1 模型 在监督学习过程中，模型就是所要学习的条件概率分布或决策函数。模型的假设空间（hypothesis space）包含所有可能的条件概率分布或决策函数。由集合表示如下： \mathcal{F}=\left\{f | Y=f_{\theta}(X), \theta \in \mathbf{R}^{n}\right\}\\或者 \mathcal{F}=\left\{P\left|P_{\theta}(Y | X), \theta \in \mathbf{R}^{n}\right\}\right.公式(1)表示定义在决策函数上的集合，公式(2)表示定义在条件概率上的集合。其中$ \theta $ 表示为参数向量（parameter space） 。 1.3.2 策略 首先引入损失函数与风险函数的概念。 损失函数(loss function)度量模型一次预测的好坏，和代价函数(cost function)表示的意义相同 常用的损失函数有以下几种： 0-1损失函数（0-1 loss function） L(Y, f(X))=\left\{\begin{array}{ll}{1,} & {Y \neq f(X)} \\ {0,} & {Y=f(X)}\end{array}\right. 平方损失函数（quadratic loss function） L(Y, f(X))=(Y-f(X))^{2} 绝对损失函数（absolute loss function） L(Y, f(X))=|Y-f(X)| 对数损失函数（logarithmic loss function）或对数似然损失函数 L(Y, P(Y | X))=-\log P(Y | X) 风险函数(risk function)度量平均意义下模型预测的好坏，也称为期望损失（expected loss），定义如下： R_{\mathrm{exp}}(f)=E_{P}[L(Y, f(X))]=\int_{\mathcal{X} \times \mathcal{Y}} L(y, f(x)) P(x, y) \mathrm{d} x \mathrm{d} y ​ ​ 学习的目标就是选择期望风险最小的模型。但是由于联合分布$P(X,Y)$是未知的，$R_{exp}(f)$不能直接计算。于是引入经验风险。 经验风险（empirical risk）：模型f(X)关于训练数据集的平均损失，也称经验损失（empirical loss）；记作$R_{emp}$: R_{\mathrm{emp}}(f)=\frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right) ​ ​ 根据大数定律，当样本容量N趋于无穷时，经验风险$R_{emp}f$趋于期望风险$R_{exp}f$。但是，由于现实中训练样本数目有限，甚至很小，所以用经验风险估计期望风险常常并不理想，要对经验风险进行一定的矫正。这就关系到监督学习的两个基本策略：经验风险最小化和结构风险最小化。 经验风险最小化（empirical risk minimization，ERM）：按照经验风险最小化求最优模型就是求解最优化问题； \min _{f \in \mathcal{F}} \frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right)其中，$\mathcal{F}$ 是假设空间。 结构风险最小化（structural risk minimization，SRM）：是为了防止过拟合而提出来的策略。结构风险最小化等价于正则化（regularization）。结构风险在经验风险上加上表示模型复杂度的正则化项（regularizer）或罚项（penalty term）。 R_{\mathrm{srm}}(f)=\frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right)+\lambda J(f)其中$J(f)$为模型的复杂度，是定义在假设空间 $\mathcal{F}$上的泛函。模型 $f$ 越复杂，复杂度$J(f)$就越大；反之，模型 $f$ 越简单，复杂度$J(f)$就越小。$\lambda \ge 0$是系数，用以权衡经验风险和模型复杂度。所以求最优模型，就是求解最优化问题： \min _{f \in \mathcal{F}} \frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right)+\lambda J(f) 这样，监督学习问题就变成了经验风险或结构风险函数的最优化问题。这时经验或结构风险函数是最优化的目标函数。 1.3.3 算法 ​ 算法是指学习模型的具体计算方法。统计学习基于训练数据集，根据学习策略，从假设空间中选择最优模型，最后需要考虑用什么样的计算方法求解最优模型。这时，统计学习问题归结为最优化问题，统计学习的算法成为求解最优化问题的算法。 1.4 模型评估与模型选择1.4.1 训练误差与测试误差 ​ 当损失函数给定时，基于损失函数的模型的训练误差（training error）和模型的测试误差（test error）就自然成为学习方法评估的标准。训练误差的大小，对判断给定的问题是不是一个容易学习的问题是有意义的，但本质上不重要。测试误差反映了学习方法对未知的测试数据集的预测能力，是学习中的重要概念。通常将学习方法对未知数据的预测能力称为泛化能力（generalization ability）。 1.4.2 过拟合与模型选择 ​ 如果一味追求提高对训练数据的预测能力，所选模型的复杂度则往往会比真模型更高。这种现象称为过拟合（over-fitting）。过拟合是指学习时选择的模型所包含的参数过多，以致于出现这一模型对已知数据预测得很好，但对未知数据预测得很差的现象。 1.5 正则化与交叉验证1.5.1 正则化 ​ 模型选择的典型方法是正则化（regularization）。正则化是结构风险最小化策略的实现，是在经验风险上加一个正则化项（regularizer）或罚项(penalty term)。正则化项一般是模型复杂度的单调递增函数，模型越复杂，正则化值就越大。比如，正则化项可以是模型参数向量的范数。 ​ 正则化一般具有如下形式： \min _{f \in \mathcal{F}} \frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right)+\lambda J(f)其中，第1项是经验风险，第2项是正则化项，$\lambda \ge 0$为调整两者之间关系的系数。 1.5.2 交叉验证 ​ 如果给定的样本数据充足，进行模型选择的一种简单方法是随机地将数据集切分成三部分，分别为训练集（training set）、验证集（validation set）和测试集（test set）。训练集用来训练模型，验证集用于模型的选择，而测试集用于最终对学习方法的评估。在学习到的不同复杂度的模型中，选择对验证集有最小预测误差的模型。 ​ 但是，在许多实际应用中数据是不充足的。为了选择好的模型，可以采用交叉验证方法。交叉验证的基本想法是重复地使用数据；把给定的数据进行切分，将切分的数据集组合为训练集与测试集，在此基础上反复地进行训练、测试以及模型选择。 ​ 有以下几种常用的交叉验证方法： 简单交叉验证：首先随机地将已给数据分为两部分，一部分作为训练集，另一部分作为测试集；然后用训练集在各种条件下训练模型，从而得到不同的模型；在测试集上评价各个模型的测试误差，选出测试误差最小的模型。 S折交叉验证：首先随机地将已给数据切分为S个互不相交的大小相同的子集；然后利用S-1个子集的数据训练模型，利用余下的子集测试模型；将这一过程对可能的S种选择重复进行；最后选出S次评测中平均测试误差最小的模型。 留一交叉验证：S折交叉验证的特殊情形是S＝N，称为留一交叉验证（leave-one-out cross validation）。往往在数据缺乏的情况下使用。 1.6 泛化能力1.6.1 泛化误差 ​ 现实中采用最多的办法是通过测试误差来评价学习方法的泛化能力。但这种评价是依赖于测试数据集的。因为测试数据集是有限的，很有可能由此得到的评价结果是不可靠的。统计学习理论试图从理论上对学习方法的泛化能力进行分析。 ​ 首先给出泛化误差的定义。如果学到的模型是$\hat{f}$，那么用这个模型对未知数据预测的误差即为泛化误差（generalization error） R_{\mathrm{exp}}(\hat{f})=E_{P}[L(Y, \hat{f}(X))]=\int_{\mathcal{X} \times \mathcal{Y}} L(y, \hat{f}(x)) P(x, y) \mathrm{d} x \mathrm{d} y事实上，泛化误差就是所学习到的模型的期望风险。 1.6.2 泛化误差上界 ​ 学习方法的泛化能力分析往往是通过研究泛化误差的概率上界进行的，简称为泛化误差上界（generalization error bound）。泛化误差上界通常具有以下性质： 它是样本容量的函数，当样本容量增加时，泛化上界趋于0； 它是假设空间容量（capacity）的函数，假设空间容量越大，模型就越难学，泛化误差上界就越大。 关于对二类分类问题，泛化误差上界不等式的证明，即证明： ​ 当假设空间是有限个函数的集合$\mathcal{F}＝{f_1，f_2,…,f_d}$时，对任意一个函数 $f \in \mathcal{F}$，至少以概率$1-\delta$，以下不等式成立： R(f) \leqslant \hat{R}(f)+\varepsilon(d, N, \delta)其中， \varepsilon(d, N, \delta)=\sqrt{\frac{1}{2 N}\left(\log d+\log \frac{1}{\delta}\right)}需要用到Hoeffding不等式： ​ 设是$S_n = \sum_{i-1}^{n}X_i$是独立随机变量$X_1,X_2,…,X_n$之和，$X_i \in [a_i，b_i ]$，则对任意$t &gt; 0$，以下不等式成立： \begin{array}{l}{P\left(S_{n}-E S_{n} \geqslant t\right) \leqslant \exp \left(\frac{-2 t^{2}}{\sum_{i=1}^{n}\left(b_{i}-a_{i}\right)^{2}}\right)} \\ {P\left(E S_{n}-S_{n} \geqslant t\right) \leqslant \exp \left(\frac{-2 t^{2}}{\sum_{i=1}^{n}\left(b_{i}-a_{i}\right)^{2}}\right)}\end{array}证明： ​ ∵ 对于任意函数$f \in \mathcal{F}$，$\hat{R}(f)$是 N 个独立的随机变量 $L(Y,f(X))$的样本均值，$R(f)$是随机变量$L(Y,f(X))$的期望值。如果损失函数取值于区间$[0,1]$，即对所有$i$，$[a_i，b_i ]＝[0,1]$，那么由Hoeffding不等式可得： \begin{aligned} P(R(f)-\hat{R}(f) \geqslant \varepsilon) &= P(E[\sum_{i=1}^{N}L\left(y_i,f(x_i) \right)]- \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right) \geqslant N \cdot\varepsilon) \\ & \leqslant \exp \left(\frac{-2 (N \cdot \varepsilon)^{2}}{\sum_{i=1}^{n}\left(b_{i}-a_{i}\right)^{2}}\right)\\ & = \exp \left(\frac{-2 (N \cdot \varepsilon)^{2}}{N}\right)\\ & = exp \left( -2N\varepsilon^2\right) \end{aligned}由于$\mathcal{F}=\{ f_1,f_2,…,f_d \}$是一个有限集合，故 \begin{aligned} P(\exists f \in \mathcal{F}:R(f)-\hat{R}(f) \geqslant \varepsilon) &=P\left(\bigcup_{f \in \mathcal{F}}\{R(f)-\hat{R}(f) \geqslant \varepsilon\}\right) \\ & \leqslant \sum_{f \in \mathcal{F}}P(R(f)-\hat{R}(f) \geqslant \varepsilon) \\ & \leqslant d \exp(-2N\varepsilon^2) \end{aligned}或者等价的，对任意$f \in \mathcal{F}$，有 P(R(f)-\hat{R}(f)]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>《统计学习方法》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的数组迭代方法总结]]></title>
    <url>%2Fpost%2F5189ba24.html</url>
    <content type="text"><![CDATA[ECMAScript 5中的数组迭代方法总结在 ECMAscript 5 中为数组定义了5个迭代方法，每个方法都接收两个参数： 要在每一项上运行的函数,该函数可接受三个参数(通常只需要第一个参数值，后面两个可以忽略)： 数组项的值: item 该项在数组中的位置: index 数组对象本身: array 运行调用函数(第一个参数)的作用域对象，为可选参数。如果有第二个参数，则调用的函数被看做是第二个参数的方法。也就是说，在调用函数时传递进去的第二个参数作为它的this关键字的值来使用。 下面依次介绍这5个方法的作用和用法： every() 对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true；否则返回false。示例如下： 1234567var arr = [1,2,3,4,5,4,3,2,1];var everyResult = arr.every(function(item)&#123; return (item &gt; 2);&#125;);alert(everyResult); //false some() 对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true；否则返回false。示例如下： 1234567var arr = [1,2,3,4,5,4,3,2,1];var someResult = arr.some(function(item)&#123; return (item &gt; 2);&#125;);alert(someResult); //true 注意：every()和some()方法较为相似。要区分它们的判断条件。前者需全部满足才返回true，后者只需一项满足即可。 filter() 对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。示例如下： 1234567var arr = [1,2,3,4,5,4,3,2,1];var filterResult = arr.filter(function(item)&#123; return (item &gt; 2);&#125;);alert(filterResult); //[3,4,5,4,3] map() 对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。示例如下： 1234567var arr = [1,2,3,4,5,4,3,2,1];var mapResult = arr.map(function(item)&#123; return (item*2);&#125;);alert(mapResult); //[2,4,6,8,10,8,6,4,2] 注意： filter()和map()返回的都是新的数组，但不改变原数组的值。 forEach() 对数组中的每一项运行给定函数，这个函数没有返回值,本质上与使用for循环迭代数组一样。示例如下： 123456var arr = [1,2,3,4,5,4,3,2,1];arr.forEach( function(item, index) &#123; // 执行某些操作 console.log('index:'+index+' item:'+item);&#125;); 总结： 数组对象是javascript中常用的类型，要熟悉数组的各种方法，需在平常开发中反复练习并理解记忆。 本文作者：Gong Jintao本文地址： https://gongjintao.com/post/5189ba24.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF认证题库201712-2————游戏]]></title>
    <url>%2Fpost%2F8cf8d4b3.html</url>
    <content type="text"><![CDATA[问题描述 有n个小朋友围成一圈玩游戏，小朋友从1至n编号，2号小朋友坐在1号小朋友的顺时针方向，3号小朋友坐在2号小朋友的顺时针方向，……，1号小朋友坐在n号小朋友的顺时针方向。游戏开始，从1号小朋友开始顺时针报数，接下来每个小朋友的报数是上一个小朋友报的数加1。若一个小朋友报的数为k的倍数或其末位数（即数的个位）为k，则该小朋友被淘汰出局，不再参加以后的报数。当游戏中只剩下一个小朋友时，该小朋友获胜。例如，当n=5, k=2时： 1号小朋友报数1； 2号小朋友报数2淘汰； 3号小朋友报数3； 4号小朋友报数4淘汰； 5号小朋友报数5； 1号小朋友报数6淘汰； 3号小朋友报数7； 5号小朋友报数8淘汰； 3号小朋友获胜。 给定n和k，请问最后获胜的小朋友编号为多少？ 输入格式 输入一行，包括两个整数n和k，意义如题目所述。 输出格式 输出一行，包含一个整数，表示获胜的小朋友编号。 样例输入 5 2 样例输出 3 样例输入 7 3 样例输出 4 数据规模和约定 对于所有评测用例，1 ≤ n ≤ 1000，1 ≤ k ≤ 9。 解题思路 可以设置数组初始值为0，淘汰的便设置为1；然后逐步循环；设置判断条件，即数组中0的个数为1，表明只有一个未被淘汰，退出循环汰。 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;bool check(int a[],int n)&#123; int sum=0,i; for(i=0;i&lt;n;i++) &#123; if(a[i]==0) &#123; sum++; &#125; &#125; if(sum==1) return false; else return true;&#125;int main()&#123; int n,k,i=0,data=1; cin&gt;&gt;n&gt;&gt;k; int arr[n]; memset(arr,0,n); while(check(arr,n)) &#123; if(arr[i]==0) &#123; data++; &#125; if(data%k==0||data%10==k) &#123; arr[i]=1; &#125; i++; if(i==n) &#123; i=0; &#125; &#125; for(i=0;i&lt;n;i++)&#123; if(arr[i]==0)&#123; cout&lt;&lt;i+1; &#125; &#125; return 0;&#125; (声明：菜鸟拙见，大神勿喷)本文作者：Gong Jintao本文地址： https://gongjintao.com/post/8cf8d4b3.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>CCF试题库</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF认证题库201403-4————无线网络]]></title>
    <url>%2Fpost%2Fb6dc74a0.html</url>
    <content type="text"><![CDATA[问题描述 目前在一个很大的平面房间里有 n 个无线路由器，每个无线路由器都固定在某个点上。任何两个无线路由器只要距离不超过 r 就能互相建立网络连接。 除此以外，另有 m 个可以摆放无线路由器的位置。你可以在这些位置中选择至多 k 个增设新的路由器。 你的目标是使得第 1 个路由器和第 2 个路由器之间的网络连接经过尽量少的中转路由器。请问在最优方案下中转路由器的最少个数是多少？ 输入格式 第一行包含四个正整数 n,m,k,r。(2 ≤ n ≤ 100,1 ≤ k ≤ m ≤ 100, 1 ≤ r ≤ 108)。 接下来 n 行，每行包含两个整数 xi 和 yi, 表示一个已经放置好的无线 路由器在 (xi, yi) 点处。输入数据保证第 1 和第 2 个路由器在仅有这 n 个路由器的情况下已经可以互相连接 (经过一系列的中转路由器)。 接下来 m 行，每行包含两个整数 xi 和 yi, 表示 (xi, yi) 点处可以增设 一个路由器。 输入中所有的坐标的绝对值不超过 108, 保证输入中的坐标各不相同。 输出格式 输出只有一个数，即在指定的位置中增设 k 个路由器后，从第 1 个路 由器到第 2 个路由器最少经过的中转路由器的个数。 样例输入 5 3 1 30 05 50 30 53 53 34 43 0 样例输出 2 解题思路 此题属于求最短路，可以用 BFS (广度优先搜索) 快速方便解出，因为从顶点出发，层序遍历时，最优先到达终点的路径就是最短路径。需要注意的是，增设的路由器只有 k 个，所有对每个点进行遍历时，需要对 k 进行判断。但不是设一个全局的 cnt 来表示增设的路由器，应该是这条路径上的增设的路由器个数，因为如果设全局，即便不在该路径上，但只要遍历到了增设位置， cnt 就会加 1，使得判断失误。所以应该对每个顶点结果体设一个单独的 cnt，用来累计从起点一直到当前点所增设的路由器个数。 代码实例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;#define ll long longconst int MAXN = 201; // 最大点数 struct dot&#123; ll x, y; // 点的坐标 int level; // 层次，用来计算路径长度 bool flag; // 用于判断点是否是新增的点 int cnt; // 用于累计从起点到当前点增设的路由器的个数&#125;Dot[MAXN];// 原来路由器个数，另有m个可以摆放路由器的位置，可以增设的路由器个数, 半径 int n, m, k, r;// 图 int G[MAXN][MAXN];// 是否被访问 bool vis[MAXN] = &#123;false&#125;; // 判断两点是否可达 bool inRange(int u, int v) &#123; return pow(Dot[u].x-Dot[v].x, 2) + pow(Dot[u].y-Dot[v].y, 2) &lt;= pow(r, 2);&#125; int BFS(int st, int ed) &#123; queue&lt;int&gt; q; q.push(st); Dot[st].level = 0; // 初始化顶点层次为 0 Dot[st].cnt = 0; // 初始化访问顶点时，增设点数为 0 vis[st] = true; // 设置被访问 while(!q.empty())&#123; int u = q.front(); //取出顶点 q.pop(); // 弹出顶点 if(u == ed) return Dot[u].level - 1; // 总顶点数为 n + m for(int v = 1; v &lt;= n + m; v++)&#123; // 如果 顶点可达 &amp;&amp; 顶点未被访问 if( G[u][v] == 1 &amp;&amp; vis[v] == false &amp;&amp; Dot[u].cnt &lt;= k) &#123; vis[v] = true; // 对增设的路由进行判断，如果当前是增设的路由，则路径上的增设路由加 1，否则不变 Dot[v].cnt = (Dot[v].flag) ? Dot[u].cnt+1 : Dot[u].cnt; q.push(v); Dot[v].level = Dot[u].level + 1; &#125; &#125; &#125;&#125;int main() &#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;r; // 设图的初值均为 0，表示不可达 fill(G[0], G[0] + MAXN*MAXN, 0); for(int i = 1; i &lt;= n+m; i++)&#123; cin&gt;&gt;Dot[i].x&gt;&gt;Dot[i].y; if(i &lt;= n) Dot[i].flag = false;// 设置是否是增设位置 else Dot[i].flag = true; &#125; // 初始化 for(int i = 1; i &lt;= MAXN; i++)&#123; for(int j = i+1; j &lt;= MAXN; j++)&#123; if(inRange(i, j)) G[i][j] = G[j][i] = 1;// 如果在半径内，则设为 1 表示两点可达 &#125; &#125; int step = BFS(1, 2); cout&lt;&lt;step&lt;&lt;endl; return 0;&#125; (声明：菜鸟拙见，大神勿喷)本文作者：Gong Jintao本文地址： https://gongjintao.com/post/b6dc74a0.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>CCF试题库</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF认证题库201312-4————有趣的数]]></title>
    <url>%2Fpost%2Fbfb9437a.html</url>
    <content type="text"><![CDATA[问题描述 我们把一个数称为有趣的，当且仅当： 它的数字只包含 0, 1, 2, 3，且这四个数字都出现过至少一次。 所有的 0 都出现在所有的 1 之前，而所有的 2 都出现在所有的 3 之前。 最高位数字不为 0。因此，符合我们定义的最小的有趣的数是 2013。除此以外，4 位的有趣的数还有两个：2031 和 2301。请计算恰好有 n 位的有趣的数的个数。由于答案可能非常大，只需要输出答案除以 1000000007 的余数。 输入格式 输入只有一行，包括恰好一个正整数 n (4 ≤ n ≤ 1000)。 输出格式 输出只有一行，包括恰好 n 位的整数中有趣的数的个数除以 1000000007 的余数。 样例输入 4 样例输出 3 解题思路 此题采用动态规划的解法。 由题可知，1 和 3 分别出现在 0 和 2 之后，所以先考虑 0 或 2 的位置，又由于 0 不能摆在最高位，所以先考虑 2 的摆放。在不考虑所有数字都齐的情况下，则共有如下六种合法的状态： 只含 2； 只含 2, 0; 只含 2, 3; 只含 2, 0, 1; 只含 2, 0, 3; 包含 4 种数字。 用 dp[i][j],j=1,2,3,4,5，来表示长度为i的整数，满足上面的第j号状态的个数。 如dp[3][1]=1,即长度为 3， 只包含 2 的整数只有 1 个，即222； 如dp[3][2]=2，即长度为 3， 只包含 2 和 0 的整数有 2 个，因为所有的 2 必须在 3 前面，则只有三种情况，即223,233； 如dp[4][3]=3，即长度为4，只包含 2 和 3 的整数有 3 个，因为所有的 2 必须在 3 前面，则只有三种情况，即2223,2233,2333； … 所以我们可以推出状态转移方程如下： dp[i][1]=1; dp[i][2]=2*dp[i-1][2]+dp[i-1][1]，即位数为 i 且只含2、0的整数 可以由位数为 i-1 且只含2、0的整数在末尾添加 0 或 2 所得； 可以由位数为 i-1 且只含 2 的整数在末尾添加 0 所得。 dp[i][3]=dp[i-1][3]+dp[i-1][1]，即位数为 i 且只含 2、3 的整数 可以由位数为 i-1 且只含2、3的整数在末尾添加 3 可得； 可以由为数为 i-1 且只含 2 的整数在末尾添加 3 可得。 dp[i][4]=2*dp[i-1][4]+dp[i-1][2]，即位数为 i 且只含 2、0 和 1 的整数 可以由位数为 i-1 且只含2、0 和 1 的整数在末尾添加 1 或 2 可得； 可以由为数为 i-1 且只含 2 或 0 的整数在末尾添加 1 可得。 dp[i][5]=2*dp[i-1][5]+dp[i-1][2]+dp[i-1][3]，即位数为 i 且只含 2、0 和 3 的整数 可以由位数为 i-1 且只含2、0 和 3 的整数在末尾添加 2 或 3 可得； 可以由为数为 i-1 且只含 2 或 0 的整数在末尾添加 3 可得。 可以由为数为 i-1 且只含 2 或 3 的整数在末尾添加 0 可得。 dp[i][6]=2*dp[i-1][6]+dp[i-1][4]+dp[i-1][5]，即位数为 i 且包含 4 种数字的整数 可以由位数为 i-1 且包含 4 种数字的整数在末尾添加 1 或 3 可得； 可以由为数为 i-1 且只含 2 、0 和 1 的整数在末尾添加 3 可得; 可以由为数为 i-1 且只含 2 、0 和 3 的整数在末尾添加 1 可得 代码实例12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;#define mod 1000000007const int maxn = 1002;long long dp[maxn][6]; int main () &#123; memset(dp,0,sizeof(dp)); int n; cin&gt;&gt;n; dp[1][1] = 1; for(int i = 2; i &lt;= n; i++)&#123; dp[i][1]=1; dp[i][2]=(2*dp[i-1][2] % mod + dp[i-1][1]) % mod; dp[i][3]=(dp[i-1][3] + dp[i-1][1]) % mod; dp[i][4]=(2*dp[i-1][4] % mod + dp[i-1][2]) % mod; dp[i][5]=((2*dp[i-1][5] % mod + dp[i-1][2]) % mod + dp[i-1][3]) % mod; dp[i][6]=((2*dp[i-1][6] % mod + dp[i-1][4]) % mod + dp[i-1][5]) % mod; &#125; cout&lt;&lt;dp[n][6]&lt;&lt;endl; return 0;&#125; (声明：菜鸟拙见，大神勿喷)本文作者：Gong Jintao本文地址： https://gongjintao.com/post/bfb9437a.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>CCF试题库</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVC和MVVM模式特点和区别]]></title>
    <url>%2Fpost%2Fec52047e.html</url>
    <content type="text"><![CDATA[1.概述 MVC 和 MVVM 都是常见的软件架构设计模式（Architectural Pattern），它通过分离关注点来改进代码的组织方式。它们的不同部分是 C(Controller)、VM(View-Model)，而相同的部分则是 MV(Model-View)。 2. MVC M(Model)：数据保存层，用于存储业务的数据，一旦数据发生变化，Model 将发送到相关的 View，用户得到反馈 V(View)：视图层，用于向用户展示数据，并传送指令到 Controller C(Controller): 业务逻辑层，用于完成用户请求的事件，然后通知 Model 改变数据 图示如下： MVC 允许在不改变视图的情况下改变视图对用户输入的响应方式，用户对 View 的操作交给了 Controller 处理，在 Controller 中响应 View 的事件调用 Model 的接口对数据进行操作，一旦 Model 发生变化便通知相关视图进行更新。注意：MVC 中也可以直接通过 Controller 接受指令。 3. MVVM M(Model)：数据层，不同于 MVC 中的 Model , MVVM 中的 Model 层只关注数据本身，不关心任何行为。 V(View)：视图层，用于向用户渲染展示数据 VM(View-Model): 视图逻辑层，可以实现数据的双向绑定，当 Model 发生变化，ViewModel 就会自动更新；ViewModel 变化，Model 也会更新。View 的变动，自动反映在 ViewModel，而ViewModel 的更新，也会自动引起 View 的变化。 图示如下： 整体来看，比 MVC/MVP 精简了很多，不仅仅简化了业务与界面的依赖，还解决了数据频繁更新，不用操作DOM。因为在 MVVM 中，View 不知道 Model 的存在，ViewModel 和 Model 也察觉不到 View，这种低耦合模式可以使开发过程更加容易，提高应用的可重用性。 本文作者：Gong Jintao本文地址： https://gongjintao.com/post/ec52047e.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript6学习笔记]]></title>
    <url>%2Fpost%2F92cd569b.html</url>
    <content type="text"><![CDATA[1.变量 var声明变量的问题 可以重复声明变量 无法限制修改 没有块级作用域 ES6中新增了两个新的声明方法 let和const let 不能重复声明，用于声明变量，有块级作用域 const 不能重复声明，用于声明常量，有块级作用域 2.函数2.1 箭头函数：()=&gt;{}&gt; 如果只有一个参数，()则可以省略 如果只有一个return,{}可以省略 2.2 函数的参数2.2.1 参数扩展/展开1234//收集参数 function show(a,b,...args)&#123;&#125; show(1,2,3,4,5); //...arg会接收剩余的参数(3,4,5)，但必须时最后一个位置 123//展开数组let arr =[1,2,3];...arr; //相当于将arr展开:1,2,3 2.2.2 默认参数 即参数一开始就有默认值 3.解构赋值 左右两边结构必须一样 右边必须是个有值的变量 生命和赋值不能分开（必须在一句语句中完成） 123let [a,b,c] = [1,2,3]; //数组let &#123;a,b,c&#125; = &#123;a:1, b:2, c:8&#125;;//jsonvar &#123; bar, foo &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;//对象 4.数组1. map(一对一的映射)123456let arr = [12,5,8];/*let result = arr.map(function(item)&#123; return item*2;&#125;)*/let result = arr.map(item=&gt;item*2);alert(result); //输出24,10,16 2. reduce(一堆对一个)1234567891011let arr =[12,34,5,33]; //求平均值 let result = arr.reduce(function(tmp,item,index)&#123; if(index!=arr.length-1)&#123; //不是最后一次运算 return tmp+item; &#125;else&#123; //最后一次运算 return (tmp+item)/arr.length; &#125; &#125;) alert(result);//21 3. filter(过滤器)1234567var arr = [1,2,3,4,5,4,3,2,1]; var filterResult = arr.filter(function(item)&#123; return (item &gt; 2); &#125;); alert(filterResult); //[3,4,5,4,3] 4. forEach(迭代) 123456 var arr = [1,2,3,4,5,4,3,2,1]; arr.forEach( function(item, index) &#123; // 执行某些操作 console.log('index:'+index+' item:'+item);&#125;); 5.字符串5.1 两个新方法 startsWith(用于判断字符串的开头)1234567let str ='https://www.baidu.com';if(str.startsWith('https://'))&#123; alert("加密网址")；&#125;else&#123; alert("普通网址")；&#125; endsWith(用于判断字符串的结尾)123456789let str="name.txt";if(str.endsWith('.txt'))&#123; alert("文本文件");&#125;else if(str.endsWith('.jpg'))&#123; alert("JPG图片");&#125;else&#123; alert("其他");&#125; 5.2. 模板字符串(用反单引号`来定义字符串) 可以直接将在字符串中解析变量，将变量写在 ${}中； 可以定义多行字符串 6.面向对象 class关键字、构造器和类分开了 class里面可以直接加方法 12345678910111213141516class User&#123; constructor(id,name)&#123; this.id = id; this.name =name; &#125; showName()&#123; alert(this.name); &#125; showId()&#123; alert(this.id); &#125; &#125; var u1 =new User(1,'Tom'); u1.showName(); u1.showId(); 继承 12345678910111213141516class VipUser extends User&#123; constructor(id,name,level)&#123; super(id,name); this.level = level; &#125; showLevel()&#123; alert(this.level); &#125;&#125;var v1 = new VipUser(2,'Jack',3);v1.showName();v1.showId();v1.showLevel(); 7.Promise 所谓 Promise 对象，就是代表了未来某个将要发生的事件（通常是一个异步操作）。它的好处在于，有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。 12345678910111213let p = new Promise(function(resolve,reject)&#123; if(/*异步操作成功*/)&#123; resolve(value); &#125;else&#123; reject(error); &#125;&#125;);p.then(function(value)&#123; //操作成功&#125;,function(error)&#123; //操作失败&#125;) 利用ajax请求数据 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; let p = new Promise(function(resolve,reject)&#123; $.ajax(&#123; url: 'data/abc.txt', dataType:'json', success(arr)&#123; resolve(arr); &#125;, error(err)&#123; reject(err); &#125; &#125;) &#125;); p.then(function(arr)&#123; alert('成功了'+arr); &#125;,function(err)&#123; alert('失败了'+err); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 利用ajax请求多个数据 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; function createPromise(url)&#123; return new Promise(function(resolve,reject)&#123; $.ajax(&#123; url, dataType:'json', success(arr)&#123; resolve(arr); &#125;, error(err)&#123; reject(err); &#125; &#125;) &#125;); &#125; Promise.all([ createPromise('data/abc.txt'),//也可直接写一个$.ajax(&#123;&#125;),因为其返回的就是一个Promise对象 createPromise('data/json.txt') ]).then(function(arr)&#123; let [res1,res2] = arr; alert(res1); alert(res2); &#125;,function(err)&#123; alert('至少有一个失败了'); console.log(err); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 8.Generator 首先，可以把它理解成一个函数的内部状态的遍历器，每调用一次，函数的内部状态发生一次改变（可以理解成发生某些事件）。在形式上，Generator 是一个普通函数，但是有两个特征。一是，function 命令与函数名之间有一个星号；二是，函数体内部使用 yield 语句，定义遍历器的每个成员，即不同的内部状态。 通过yield传参1234567891011function *show()&#123; alert('a'); let a = yield; //yield可以传参 alert('b'); alert(a); &#125; let gen = show(); gen.next(12); //第一个next()传参并没有用，所以这里弹出'a' gen.next(5); //next()传参会传给yield，所以弹出'b'之后，弹出的是5 通过yield返回值123456789101112131415161718192021222324function *show(a)&#123; alert(a); let tmp = a*2; yield tmp; let b = tmp+1; //11 alert(b); yield b; let c = b*3;//33 alert(c); return c; &#125; let gen = show(5); let res1 = gen.next(); //&#123;value:10,done:false&#125; console.log(res1); let res2 = gen.next(); //&#123;value:11，done:false&#125; console.log(res2); let res3 =gen.next(); //&#123;value:33，done:true&#125; console.log(res3); Promise适合一次性读一堆数据的操作，Generator适合有逻辑性的读取的操作 9. 模块编程 在 ES6 中导入模块，使用 import 模块名 from ‘模块标识符’ import &#39;模块标识符&#39; //例如导入css文件 在 ES6 中使用export default 和 export 向外暴露成员 注意： export default向外暴露的成员，可以用任意变量来接收 在一个模块中，export default 只允许向外暴露一次 在一个模块中，可以同时使用 export default 和 export 向外暴露成员 使用 export 向外暴露的成员，只能使用{}的形式来接受，这种形式叫做【按需导出】 使用export 向外暴露的成员，必须严格按照导出时的名称来接收，可以用 as来起别名 相比在 node.js 中是使用var 名称 = require(&#39;模块表示符&#39;)来导入 ES6中是用 module.exports和exports来暴露成员 本文作者：Gong Jintao本文地址： https://gongjintao.com/post/92cd569b.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue中的生命周期]]></title>
    <url>%2Fpost%2F99504a05.html</url>
    <content type="text"><![CDATA[1.生命周期定义 生命周期是指：从Vue实例创建、运行、到销毁期间，总是伴随着各种事件的发生，这些事件统称为生命周期。 2.生命周期钩子 生命周期钩子即生命周期事件的别名 生命周期钩子 = 生命周期函数 = 生命周期事件 3.生命周期函数分类 创建期间的生命周期函数 beforeCreate ：实例刚在内存中被创建出来；此时，还没有初始化好 data 和 methods 属性 created : 实例已经在内存中创建好，此时 data 和 methods 已经初始化好了 beforeMount：表示模板已经在内存中编译完成，还没有渲染到页面中去 mounted: 内存中的模板已经真实的挂载到浏览器中的页面中了，用户已经可以看到渲染好的页面了 运行期间的生命周期函数 beforeUpdate : 状态更新前执行该函数，此时界面还没有被更新，但是数据已经被更新，因此还没有开始重新渲染DOM节点 updated: 实例更新完毕之后调用该函数，页面和data数据已经保持同步了，都是最新的数据，界面已经被重新渲染好了 销毁期间的生命周期函数 beforeDestroy: 实例销毁之前调用。Vue实例从运行阶段进入了销毁阶段，实例上的data 和 methods ，过滤器，指令等都处于可用阶段还没有被真正销毁 destroyed:Vue实例已经被完全销毁，实例上的data 和 methods，过滤器，指令等都不可用 4.生命周期函数图 本文作者：Gong Jintao本文地址： https://gongjintao.com/post/99504a05.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF认证题库201312-3————最大的矩形]]></title>
    <url>%2Fpost%2F47ebd58b.html</url>
    <content type="text"><![CDATA[问题描述 在横轴上放了 n 个相邻的矩形，每个矩形的宽度是 1，而第 i（1 ≤ i ≤ n）个矩形的高度是 hi。这 n 个矩形构成了一个直方图。例如，下图中六个矩形的高度就分别是 3, 1, 6, 5, 2, 3。请找出能放在给定直方图里面积最大的矩形，它的边要与坐标轴平行。对于上面给出的例子，最大矩形如下图所示的阴影部分，面积是 10。 输入格式 第一行包含一个整数 n，即矩形的数量 (1 ≤ n ≤ 1000)。 第二行包含 n 个整数 h1, h2, … , hn，相邻的数之间由空格分隔。(1 ≤ hi ≤ 10000)。hi 是第 i 个矩形的高度。 输出格式 输出一行，包含一个整数，即给定直方图内的最大矩形的面积。 样例输入 63 1 6 5 2 3 样例输出 10 解题思路 用的是最直接的思路，所以并非很好的解法。因为对于直方图中的每一个矩形，都会决定一个最大矩形。高即该矩形的高，宽则是左右两个方向比它高的最后一个之间的相隔个数。然后在从这些矩形中找出最大的即可。 代码实例1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;using namespace std;const int MAXN=1002;int h[MAXN] = &#123;0&#125;,n;int Sarea(int n,int h[])&#123; int ans = 0; for(int i=1;i&lt;=n;i++)&#123; int left = i ,right = i; for(int j = i-1;j&gt;=0;j--)&#123;//往左遍历 if(h[j]&gt;=h[i])&#123; left = j; //若遍历的矩形比该矩形高，则继续，边界left等于当前矩形的序号 &#125;else&#123; break; //若比该矩形低，则结束 &#125; &#125; for(int j= i+1;j&lt;=n+1;j++)&#123; //向右遍历，同上 if(h[j]&gt;=h[i])&#123; right = j; &#125;else&#123; break; &#125; &#125; int v = h[i]*(right-left == 0?1:right-left+1);//若right==left表明最大的矩形只有该矩形一条。 if(v&gt;ans) ans = v; &#125; return ans;&#125;int main()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;h[i]; &#125; cout&lt;&lt;Sarea(n,h); return 0;&#125; (声明：菜鸟拙见，大神勿喷)本文作者：Gong Jintao本文地址： https://gongjintao.com/post/47ebd58b.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>CCF试题库</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF认证题库201703-3————Markdown]]></title>
    <url>%2Fpost%2F4545002f.html</url>
    <content type="text"><![CDATA[问题描述 Markdown 是一种很流行的轻量级标记语言（lightweight markup language），广泛用于撰写带格式的文档。例如以下这段文本就是用 Markdown 的语法写成的：这些用 Markdown 写成的文本，尽管本身是纯文本格式，然而读者可以很容易地看出它的文档结构。同时，还有很多工具可以自动把 Markdown 文本转换成 HTML 甚至 Word、PDF 等格式，取得更好的排版效果。例如上面这段文本通过转化得到的 HTML 代码如下所示：本题要求由你来编写一个 Markdown 的转换工具，完成 Markdown 文本到 HTML 代码的转换工作。简化起见，本题定义的 Markdown 语法规则和转换规则描述如下： ●区块：区块是文档的顶级结构。本题的 Markdown 语法有 3 种区块格式。在输入中，相邻两个区块之间用一个或多个空行分隔。输出时删除所有分隔区块的空行。 ○段落：一般情况下，连续多行输入构成一个段落。段落的转换规则是在段落的第一行行首插入 &lt;p&gt;，在最后一行行末插入 &lt;/p&gt;。 ○标题：每个标题区块只有一行，由若干个 # 开头，接着一个或多个空格，然后是标题内容，直到行末。# 的个数决定了标题的等级。转换时，# Heading 转换为 &lt;h1&gt;Heading&lt;/h1&gt;，## Heading 转换为 &lt;h2&gt;Heading&lt;/h2&gt;，以此类推。标题等级最深为 6。 ○无序列表：无序列表由若干行组成，每行由 * 开头，接着一个或多个空格，然后是列表项目的文字，直到行末。转换时，在最开始插入一行 &lt;ul&gt;，最后插入一行 &lt;/ul&gt;；对于每行，* Item 转换为 &lt;li&gt;Item&lt;/li&gt;。本题中的无序列表只有一层，不会出现缩进的情况。 ●行内：对于区块中的内容，有以下两种行内结构。 ○强调：_Text_ 转换为 &lt;em&gt;Text&lt;/em&gt;。强调不会出现嵌套，每行中 _ 的个数一定是偶数，且不会连续相邻。注意 _Text_ 的前后不一定是空格字符。 ○超级链接：[Text](Link) 转换为 &lt;a href=&quot;Link&quot;&gt;Text&lt;/a&gt;。超级链接和强调可以相互嵌套，但每种格式不会超过一层。 输入格式 输入由若干行组成，表示一个用本题规定的 Markdown 语法撰写的文档。 输出格式 输出由若干行组成，表示输入的 Markdown 文档转换成产生的 HTML 代码。 样例输入 # Hello Hello, world! 样例输出 &lt;h1&gt;Hello&lt;/h1&gt;&lt;p&gt;Hello, world!&lt;/p&gt; 评测用例规模与约定 本题的测试点满足以下条件： ●本题每个测试点的输入数据所包含的行数都不超过100，每行字符的个数（包括行末换行符）都不超过100。 ●除了换行符之外，所有字符都是 ASCII 码 32 至 126 的可打印字符。 ●每行行首和行末都不会出现空格字符。 ●输入数据除了 Markdown 语法所需，内容中不会出现 #、*、_、[、]、(、)、&lt;、&gt;、&amp; 这些字符。 ●所有测试点均符合题目所规定的 Markdown 语法，你的程序不需要考虑语法错误的情况。 解题思路 分两个部分进行处理，即区块和行列元素；然后建立vector容器html，存入处理后的每一行字符串。1.首先处理行列元素，即处理强调符号和超级链接，分别构建deal1()和deal2()两个处理函数。注意的是这两个可以相互嵌套，所以需要将两个函数嵌套处理，所以需要提前申明。2.区块分为三种，即段落，标题和无序列表。关键是段落和无序列表处理；当区块结束和文件末尾时，如果该区块是段落，则要在上一行末尾添加”&lt;/p&gt;”;如果该区块是无序列表，则要添加一个”&lt;/ul&gt;”。 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;string deal1(string line);string deal2(string line);//强调处理 string deal1(string line)&#123; int pos; while((pos = line.find("_"))!=string::npos) &#123; line.replace(pos,1,"&lt;em&gt;"); line.replace(line.find("_",pos),1,"&lt;/em&gt;"); line = deal2(line); &#125; return line;&#125; //超链接处理 string deal2(string line)&#123; int pos; while((pos = line.find("["))!=string::npos) &#123; int posR = line.find("]",pos); int posL1 = line.find("(",posR); int posR1 = line.find(")",posL1); string text = line.substr(pos+1,posR-pos-1); string link = line.substr(posL1+1,posR1-posL1-1); string a = "&lt;a href=\""+link+"\"&gt;"+text+"&lt;/a&gt;"; line.replace(pos,posR1-pos+1,a); line = deal1(line); &#125; return line; &#125;int main()&#123; string line; vector&lt;string&gt; html; int pSum = 0; bool paraFlag = false; int uSum = 0; bool listFlag = false; while(getline(cin,line)) &#123; if(line.size()!=0)//如果字符串长度不为0 &#123; int pos, sumH = 0; //判断是否是段落 if(*(line.begin())!='#' &amp;&amp; *(line.begin())!='*') &#123; pSum++; paraFlag = true; &#125; if(paraFlag) &#123; if(pSum==1) line = "&lt;p&gt;"+line;//是否是段落开头 &#125; //判断是否是标题 while((pos = line.find("#"))!=string::npos) &#123; sumH++; //标题级别 line.erase(pos,1); &#125; //判断是否是无序列表 while((pos=line.find("*"))!=string::npos) &#123; uSum++; listFlag = true; line.erase(pos,1); &#125; //将"#”和"*"去掉后，再去掉开头的多余空格 while(*line.begin()==' ') &#123; line.erase(0,1); &#125; if(listFlag) &#123; if(uSum==1) html.push_back("&lt;ul&gt;"); line = "&lt;li&gt;" + line + "&lt;/li&gt;"; &#125; //处理强调和超链接 line = deal1(line); line = deal2(line); if(sumH) &#123; char tmp[2]; sprintf(tmp,"%d",sumH); string s= tmp; line = "&lt;h"+s+"&gt;"+line+"&lt;/h"+s+"&gt;"; &#125; html.push_back(line); &#125;else&#123; //如果录入的是空行，说明是区块结束 if(uSum &gt;= 1) //如果区块结束，无序标签数目大于等于1，则在后面添加&lt;/ul&gt;,同时标志和计数器重置 &#123; html.push_back("&lt;/ul&gt;"); uSum = 0; listFlag =false; &#125; //如果区块结束，段落数目大于等于1，则在前一行后面添加&lt;/p&gt;,同时标志和计数器重置 if(pSum&gt;=1) &#123; vector&lt;string&gt;::iterator it = html.end()-1; *it =*it+"&lt;/p&gt;"; pSum = 0; paraFlag = false; &#125; &#125; line.clear();//清空容器 &#125; // 文件尾 也要判断 if(uSum &gt;= 1) &#123; html.push_back("&lt;/ul&gt;"); &#125; if(pSum&gt;=1) &#123; vector&lt;string&gt;::iterator it = html.end()-1; string tmp = *it+"&lt;/p&gt;"; *it = tmp; &#125; for(int i=0;i&lt;html.size();i++) &#123; cout&lt;&lt;html[i]&lt;&lt;endl; &#125; return 0;&#125; 解题总结 要熟悉string的各个内置函数的常见用法：line.find(str,pos):表示从字符串line的pos位置往后面查找字串str，如果有则返回首次出现的位置，若不存在则返回string::npos;line.substr(pos,len):表示从line的pos位置截取长度为len的字串，包括pos位置的值；line.replace(pos,len,str):表示用字符串str替换line的pos位置往后的len长度的字串；line.erase(pos_0,pos_n)：表示移除line中从位置pos_0到pos_n中间的字符串，包括pos_0,不包括pos_n，即[pos_0,pos_n); (声明：菜鸟拙见，大神勿喷)本文作者：Gong Jintao本文地址： https://gongjintao.com/post/4545002f.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>CCF试题库</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF认证题库201612-3————权限查询]]></title>
    <url>%2Fpost%2Ffa3686ed.html</url>
    <content type="text"><![CDATA[问题描述 授权 (authorization) 是各类业务系统不可缺少的组成部分，系统用户通过授权机制获得系统中各个模块的操作权限。 本题中的授权机制是这样设计的：每位用户具有若干角色，每种角色具有若干权限。例如，用户 david 具有 manager 角色，manager 角色有 crm:2 权限，则用户 david 具有 crm:2 权限，也就是 crm 类权限的第 2 等级的权限。 具体地，用户名和角色名称都是由小写字母组成的字符串，长度不超过 32。权限分为分等级权限和不分等级权限两大类。分等级权限由权限类名和权限等级构成，中间用冒号“:”分隔。其中权限类名也是由小写字母组成的字符串，长度不超过 32。权限等级是一位数字，从 0 到 9，数字越大表示权限等级越高。系统规定如果用户具有某类某一等级的权限，那么他也将自动具有该类更低等级的权限。例如在上面的例子中，除 crm:2 外，用户 david 也具有 crm:1 和 crm:0 权限。不分等级权限在描述权限时只有权限类名，没有权限等级（也没有用于分隔的冒号）。 给出系统中用户、角色和权限的描述信息，你的程序需要回答多个关于用户和权限的查询。查询可分为以下几类： 不分等级权限的查询：如果权限本身是不分等级的，则查询时不指定等级，返回是否具有该权限； 分等级权限的带等级查询：如果权限本身分等级，查询也带等级，则返回是否具有该类的该等级权限； 分等级权限的不带等级查询：如果权限本身分等级，查询不带等级，则返回具有该类权限的等级；如果不具有该类的任何等级权限，则返回“否”。 输入格式 输入第一行是一个正整数 p，表示不同的权限类别的数量。紧接着的 p 行被称为 P 段，每行一个字符串，描述各个权限。对于分等级权限，格式为 :，其中 是权限类名， 是该类权限的最高等级。对于不分等级权限，字符串只包含权限类名。 接下来一行是一个正整数 r，表示不同的角色数量。紧接着的 r 行被称为 R 段，每行描述一种角色，格式为 &lt;role&gt; &lt;s&gt; &lt;privilege 1&gt; &lt;privilege 2&gt; ... &lt;privilege s&gt; 其中&lt;role&gt; 是角色名称，&lt;s&gt; 表示该角色具有多少种权限。后面 &lt;s&gt; 个字符串描述该角色具有的权限，格式同 P 段。 接下来一行是一个正整数 u，表示用户数量。紧接着的 u 行被称为 U 段，每行描述一个用户，格式为 &lt;user&gt; &lt;t&gt; &lt;role 1&gt; &lt;role 2&gt; ... &lt;role t&gt; 其中 &lt;user&gt; 是用户名，&lt;t&gt;表示该用户具有多少种角色。后面 &lt;t&gt; 个字符串描述该用户具有的角色。 接下来一行是一个正整数 q，表示权限查询的数量。紧接着的 q 行被称为 Q 段，每行描述一个授权查询，格式为 &lt;user&gt; &lt;privilege&gt;，表示查询用户 &lt;user&gt; 是否具有 &lt;privilege&gt; 权限。如果查询的权限是分等级权限，则查询中的 可指定等级，表示查询该用户是否具有该等级的权限；也可以不指定等级，表示查询该用户具有该权限的等级。对于不分等级权限，只能查询该用户是否具有该权限，查询中不能指定等级。输出格式 输出共 q 行，每行为 false、true，或者一个数字。false 表示相应的用户不具有相应的权限，true 表示相应的用户具有相应的权限。对于分等级权限的不带等级查询，如果具有权限，则结果是一个数字，表示该用户具有该权限的（最高）等级。如果用户不存在，或者查询的权限没有定义，则应该返回 false。 样例输入 3crm:2git:3game4hr 1 crm:2it 3 crm:1 git:1 gamedev 2 git:3 gameqa 1 git:23alice 1 hrbob 2 it qacharlie 1 dev9alice gamealice crm:2alice git:0bob gitbob poweroffcharlie gamecharlie crmcharlie git:3malice game 样例输出 falsetruefalse2falsetruefalsetruefalse 样例说明 样例输入描述的场景中，各个用户实际的权限如下： * 用户 alice 具有 crm:2 权限 * 用户 bob 具有 crm:1、git:2 和 game 权限 * 用户 charlie 具有 git:3 和 game 权限 * 用户 malice 未描述，因此不具有任何权限 评测用例规模与约定 评测用例规模： * 1 ≤ p, r, u ≤ 100 * 1 ≤ q ≤ 10 000 * 每个用户具有的角色数不超过 10，每种角色具有的权限种类不超过 10 约定： * 输入保证合法性，包括： 1) 角色对应的权限列表（R 段）中的权限都是之前（P 段）出现过的，权限可以重复出现，如果带等级的权限重复出现，以等级最高的为准 2) 用户对应的角色列表（U 段）中的角色都是之前（R 段）出现过的，如果多个角色都具有某一分等级权限，以等级最高的为准 3) 查询（Q 段）中的用户名和权限类名不保证在之前（U 段和 P 段）出现过 * 前 20% 的评测用例只有一种角色 * 前 50% 的评测用例权限都是不分等级的，查询也都不带等级 解题思路 首先构建权限的处理函数，即对权限字符串处理，返回pair&lt;string,int&gt; 的数据，第一个字段为权限名，第二个字段为等级，不分等级的权限则等级为-1；然后建立各项权限表：1.用map先建立关于权限的权限表Prom；键值为权限名，对应的值为权限的等级；2.用二维map建立关于角色与权限的角色权限表roleProm；键值为角色名，对应的值为该角色用的权限表。注意的是权限名可能重复出现，所以要判断在对应的权限表中是否已经存在该权限，且等级是否高于存在的权限的等级；3.用二维map建立用户与权限的用户权限表，先录入的是该用户所对应的角色，然后将该角色的权限表的每一项录入用户的权限表中。注意权限名会重复出现，所以要录入该权限的最高等级。接下来进行查询：1.判断是否在用户表和权限表中都存在，存在则继续，否则返回false；2.查询对应的用户权限表中是否存在该权限，存在则继续，否则返回false；3.查询对应的用户权限表中该权限是否是分等级的，是则继续，否则返回true;4.若查询的权限是分等级的但没有给出等级号，则返回用户权限表中该权限的等级；若查询的等级号高于用户权限表中该权限的等级则返回false，否则返回true。 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;algorithm&gt;using namespace std;typedef pair&lt;string,int&gt; prom;map&lt;string,int&gt; Prom; //权限表 map&lt; string, map&lt;string,int&gt; &gt; roleProm; //角色所拥有的权限//string roles[maxn]; //角色名map&lt; string, map&lt;string,int&gt; &gt; userProm; //用户所拥有的权限//string users[maxn]; //用户名 //处理字符串，返回权限名和权限等级，不分等级，则等级为-1 prom dealProm(string p)&#123; int i=0; string auth=""; int deg = 0; bool flag = false; while(p[i]!=':' &amp;&amp; i&lt;p.size())&#123; auth += p[i]; i++; &#125; i++; while(i&lt;p.size())&#123; deg = deg*10+(p[i]-'0'); i++; flag =true; &#125; if(!flag) deg = -1;//表明是不分等级的 prom tmp(auth,deg); return tmp;&#125;int main()&#123; int p,r,u,q; cin&gt;&gt;p; for(int i=0;i&lt;p;i++)&#123; string authr; cin&gt;&gt;authr; prom tmp = dealProm(authr); Prom[tmp.first] = tmp.second; //建立权限表 &#125; cin&gt;&gt;r; for(int i=0;i&lt;r;i++)&#123; string role; int s; cin&gt;&gt;role&gt;&gt;s; for(int j=0;j&lt;s;j++) &#123; string tmpor; cin&gt;&gt;tmpor; prom tmp = dealProm(tmpor); map&lt;string,int&gt;::iterator it = roleProm[role].find(tmp.first); if(it != roleProm[role].end())&#123; //是否在角色权限表中存在 if(it-&gt;second &lt; tmp.second)&#123; //是否已存在的等级低于录入的权限的等级 it-&gt;second = tmp.second; &#125;else&#123; continue; &#125; &#125;else&#123; roleProm[role][tmp.first] = tmp.second; //没有则直接 录入 &#125; &#125; &#125; cin&gt;&gt;u; for(int i=0;i&lt;u;i++)&#123; string uName; int t; cin&gt;&gt;uName&gt;&gt;t; for(int i=0;i&lt;t;i++) &#123; string tName; cin&gt;&gt;tName; map&lt;string,int&gt;::iterator it = roleProm[tName].begin(); for(;it!=roleProm[tName].end();it++) //将角色的权限写入用户的权限表中 &#123; map&lt;string,int&gt;::iterator it2 = userProm[uName].find(it-&gt;first); if(it2!=userProm[uName].end())&#123; //如果已经存在该权限 if(it2-&gt;second &lt; it-&gt;second)&#123; //判断等级是否高于存在的权限的的等级 it2-&gt;second = it-&gt;second; &#125;else&#123; continue; &#125; &#125;else&#123; userProm[uName][it-&gt;first] = it-&gt;second; //不存在则写入该权限项 &#125; &#125; &#125; &#125; cin&gt;&gt;q; for(int i=0;i&lt;q;i++)&#123; string userName,selProm; cin&gt;&gt;userName&gt;&gt;selProm; prom tmp = dealProm(selProm); string cate= tmp.first; int degree = tmp.second; if(Prom.find(cate)==Prom.end() || userProm.find(userName)==userProm.end() )&#123; //如果权限表中没有该权限或着用户表中没有该用户 cout&lt;&lt;"false"&lt;&lt;endl; &#125;else if(userProm[userName].find(cate)==userProm[userName].end())&#123; cout&lt;&lt;"false"&lt;&lt;endl; &#125;else if(userProm[userName][cate] != -1 )&#123; if(degree == -1)&#123; cout&lt;&lt;userProm[userName][cate]&lt;&lt;endl; &#125;else&#123; userProm[userName][cate] &lt; degree?cout&lt;&lt;"false"&lt;&lt;endl:cout&lt;&lt;"true"&lt;&lt;endl; &#125; &#125;else&#123; cout&lt;&lt;"true"&lt;&lt;endl; &#125; &#125; return 0;&#125; (声明：菜鸟拙见，大神勿喷)本文作者：Gong Jintao本文地址： https://gongjintao.com/post/fa3686ed.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>CCF试题库</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF试题库201312-2————ISBN号码]]></title>
    <url>%2Fpost%2Fdf46e976.html</url>
    <content type="text"><![CDATA[问题描述 每一本正式出版的图书都有一个 ISBN 号码与之对应，ISBN 码包括 9 位数字、1 位识别码和 3 位分隔符，其规定格式如 “x-xxx-xxxxx-x”，其中符号“-” 是分隔符（键盘上的减号），最后一位是识别码，例如 0-670-82162-4 就是一个标准的 ISBN 码。ISBN 码的首位数字表示书籍的出版语言，例如 0 代表英语；第一个分隔符 “-” 之后的三位数字代表出版社，例如 670 代表维京出版社；第二个分隔之后的五位数字代表该书在出版社的编号；最后一位为识别码。识别码的计算方法如下：首位数字乘以 1 加上次位数字乘以 2…… 以此类推，用所得的结果 mod 11，所得的余数即为识别码，如果余数为 10，则识别码为大写字母 X。例如 ISBN 号码 0-670-82162-4 中的识别码 4 是这样得到的：对 067082162 这 9 个数字，从左至右，分别乘以 1，2，…，9，再求和，即 0×1+6×2+……+2×9=158，然后取 158 mod 11 的结果 4 作为识别码。编写程序判断输入的 ISBN 号码中识别码是否正确，如果正确，则仅输出 “Right”；如果错误，则输出是正确的 ISBN 号码。 输入格式 输入只有一行，是一个字符序列，表示一本书的 ISBN 号码（保证输入符合 ISBN 号码的格式要求）。 输出格式 输出一行，假如输入的 ISBN 号码的识别码正确，那么输出 “Right”，否则，按照规定的格式，输出正确的 ISBN 号码（包括分隔符 “-”）。 样例输入 0-670-82162-4 样例输出 Right 样例输入 0-670-82162-0 样例输出 0-670-82162-4 解题思路 因为位数规定好了，所以算数比较简单，然后再进行判断即可。 代码示例123456789101112131415161718192021222324#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define N 13int main()&#123; char s[N]; int i,sum; scanf("%s",&amp;s); sum=(s[0]-'0')*1; for(i=2;i&lt;=4;i++)&#123; sum+=(s[i]-'0')*i; &#125; for(i=6;i&lt;=10;i++)&#123; sum+=(s[i]-'0')*(i-1); &#125; if((sum%11==10 &amp;&amp; s[N-1] == 'X')|| sum%11 == (s[N-1]-'0'))&#123; printf("Right"); &#125;else&#123; for(i=0;i&lt;N-1;i++)&#123; printf("%c",s[i]); &#125; sum%11==10?printf("X"):printf("%d",sum%11); &#125; return 0;&#125; (声明：菜鸟拙见，大神勿喷)本文作者：Gong Jintao本文地址： https://gongjintao.com/post/df46e976.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>CCF试题库</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF试题库201312-1————出现次数最多的数]]></title>
    <url>%2Fpost%2Fa0be2792.html</url>
    <content type="text"><![CDATA[问题描述 给定 n 个正整数，找出它们中出现次数最多的数。如果这样的数有多个，请输出其中最小的一个。 输入格式 输入的第一行只有一个正整数 n(1 ≤ n ≤ 1000)，表示数字的个数。输入的第二行有 n 个整数 s1, s2, …, sn (1 ≤ si ≤ 10000, 1 ≤ i ≤ n)。相邻的数用空格分隔。 输出格式 输出这 n 个次数中出现次数最多的数。如果这样的数有多个，输出其中最小的一个。 样例输入 610 1 10 20 30 20 样例输出 10 解题思路 此处规模不大，用hash表比较方便。 代码示例123456789101112131415161718#include&lt;stdio.h&gt;int main()&#123; int n,i,s=0,min,data; scanf("%d",&amp;n); int sum[10001]=&#123;0&#125;; for(i=0;i&lt;n;i++)&#123; scanf("%d",&amp;data); sum[data]++; &#125; for(i=1;i&lt;=10000;i++)&#123; if(sum[i]&gt;s)&#123; s=sum[i]; min=i; &#125; &#125; printf("%d",min); return 0; &#125; (声明：菜鸟拙见，大神勿喷)本文作者：Gong Jintao本文地址： https://gongjintao.com/post/a0be2792.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>CCF试题库</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF试题库201403-2————窗口]]></title>
    <url>%2Fpost%2F27206541.html</url>
    <content type="text"><![CDATA[问题描述 在某图形操作系统中, 有 N 个窗口, 每个窗口都是一个两边与坐标轴分别平行的矩形区域。窗口的边界上的点也属于该窗口。窗口之间有层次的区别, 在多于一个窗口重叠的区域里, 只会显示位于顶层的窗口里的内容。 当你点击屏幕上一个点的时候, 你就选择了处于被点击位置的最顶层窗口, 并且这个窗口就会被移到所有窗口的最顶层, 而剩余的窗口的层次顺序不变。如果你点击的位置不属于任何窗口, 则系统会忽略你这次点击。 现在我们希望你写一个程序模拟点击窗口的过程。 输入格式 输入的第一行有两个正整数, 即 N 和 M。(1 ≤ N ≤ 10,1 ≤ M ≤ 10)接下来 N 行按照从最下层到最顶层的顺序给出 N 个窗口的位置。 每行包含四个非负整数 x1, y1, x2, y2, 表示该窗口的一对顶点坐标分别为 (x1, y1) 和 (x2, y2)。保证 x1 &lt; x2,y1 2。接下来 M 行每行包含两个非负整数 x, y, 表示一次鼠标点击的坐标。题目中涉及到的所有点和矩形的顶点的 x, y 坐标分别不超过 2559 和 1439 输出格式 输出包括 M 行, 每一行表示一次鼠标点击的结果。如果该次鼠标点击选择了一个窗口, 则输出这个窗口的编号 (窗口按照输入中的顺序从 1 编号到 N); 如果没有, 则输出 “IGNORED”(不含双引号)。 样例输入 3 40 0 4 41 1 5 52 2 6 61 10 04 40 5 样例输出 211IGNORED 解题思路 思路较为简单：首先定义窗口结构体，包括窗口个定点的坐标以及其序号，然后输入数组中。输入坐标时，则反向循环数组（因为窗口输入时从底层到顶层；而点击需要先判断顶层）；若坐标在窗口内，则输出窗口序号，然后将该窗口移到最后一个，其余的窗口依次挪动位置。 代码示例12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;stdlib.h&gt;using namespace std;typedef struct window&#123; int x1,x2,y1,y2,index;&#125;Win;int main()&#123; int n,m,i,j,a,b; cin&gt;&gt;n&gt;&gt;m; Win* wins; wins = (Win*)malloc(sizeof(Win)*n); for(i=0;i&lt;n;i++)&#123; cin&gt;&gt;wins[i].x1&gt;&gt;wins[i].y1&gt;&gt;wins[i].x2&gt;&gt;wins[i].y2; wins[i].index=i+1; &#125; while(m)&#123; cin&gt;&gt;a&gt;&gt;b; int flag=0; for(i=n-1;i&gt;=0;i--)&#123; Win temp; if((a&gt;=wins[i].x1 &amp;&amp; a&lt;=wins[i].x2) &amp;&amp; (b&gt;=wins[i].y1 &amp;&amp; b&lt;=wins[i].y2))&#123; cout&lt;&lt;wins[i].index&lt;&lt;endl; flag = 1; temp = wins[i]; for(j=i;j&lt;n-1;j++)&#123; wins[j] = wins[j+1]; &#125; wins[n-1]=temp; break; &#125; &#125; if(flag == 0)&#123; cout&lt;&lt;"IGNORED"&lt;&lt;endl; &#125; m--; &#125; return 0;&#125; (声明：菜鸟拙见，大神勿喷)本文作者：Gong Jintao本文地址： https://gongjintao.com/post/27206541.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>CCF试题库</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF试题库201403-1————相反数]]></title>
    <url>%2Fpost%2Fcec28ff2.html</url>
    <content type="text"><![CDATA[问题描述 有 N 个非零且各不相同的整数。请你编一个程序求出它们中有多少对相反数 (a 和 -a 为一对相反数)。 输入格式 第一行包含一个正整数 N。(1 ≤ N ≤ 500)。第二行为 N 个用单个空格隔开的非零整数, 每个数的绝对值不超过 1000, 保证这些整数各不相同。 输出格式 只输出一个整数, 即这 N 个数中包含多少对相反数。 样例输入 51 2 3 -1 -2 样例输出 2 解题思路 思路较为简单，嵌套两层循环即可。 代码示例12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;stdlib.h&gt;using namespace std;int main()&#123; int n,i,j,sum=0; cin&gt;&gt;n; int *a; a = (int*)malloc(sizeof(int)*n); for(i=0;i&lt;n;i++)&#123; cin&gt;&gt;a[i]; &#125; for(i=0;i&lt;n-1;i++)&#123; for(j=i+1;j&lt;n;j++)&#123; if((a[i]+a[j])==0)&#123; sum++; continue; &#125; &#125; &#125; cout&lt;&lt;sum; return 0;&#125; (声明：菜鸟拙见，大神勿喷)本文作者：Gong Jintao本文地址： https://gongjintao.com/post/cec28ff2.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>CCF试题库</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF认证题库201409-2————画图]]></title>
    <url>%2Fpost%2F5c764364.html</url>
    <content type="text"><![CDATA[问题描述 在一个定义了直角坐标系的纸上，画一个(x1,y1)到(x2,y2)的矩形指将横坐标范围从x1到x2，纵坐标范围从y1到y2之间的区域涂上颜色。 下图给出了一个画了两个矩形的例子。第一个矩形是(1,1) 到(4, 4)，用绿色和紫色表示。第二个矩形是(2, 3)到(6, 5)，用蓝色和紫色表示。图中，一共有15个单位的面积被涂上颜色，其中紫色部分被涂了两次，但在计算面积时只计算一次。在实际的涂色过程中，所有的矩形都涂成统一的颜色，图中显示不同颜色仅为说明方便。 给出所有要画的矩形，请问总共有多少个单位的面积被涂上颜色。 输入格式 输入的第一行包含一个整数n，表示要画的矩形的个数。 接下来n行，每行4个非负整数，分别表示要画的矩形的左下角的横坐标与纵坐标，以及右上角的横坐标与纵坐标。 输出格式 输出一个整数，表示有多少个单位的面积被涂上颜色。 样例输入 21 1 4 42 3 6 5 样例输出 15 评测用例规模与约定 1&lt;=n&lt;=100，0&lt;=横坐标、纵坐标&lt;=100。 解题思路 总结此类题目的通法，即对原矩阵的变化无法直接对原矩阵进行操作，但可以设置标志矩阵进行模拟操作。如201512-2消除类游戏本题可设置一个100x100的二维数组map[100][100],然后对输入的进行画图矩阵在map[100][100]中进行涂抹，图上颜色则置为1，最后统计map[100][100]中1的个数即总的面积。 代码示例12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;int main()&#123; int n,i,j,s=0; cin&gt;&gt;n; int map[100][100]=&#123;0&#125;; int a[4]; while(n--)&#123; for(i=0;i&lt;4;i++)&#123; cin&gt;&gt;a[i]; &#125; for(i=a[0];i&lt;a[2];i++)&#123; for(j=a[1];j&lt;a[3];j++)&#123; map[i][j]=1; &#125; &#125; &#125; for(i=0;i&lt;100;i++)&#123; for(j=0;j&lt;100;j++)&#123; if(map[i][j]==1)&#123; s++; &#125; &#125; &#125; cout&lt;&lt;s; &#125; (声明：菜鸟拙见，大神勿喷)本文作者：Gong Jintao本文地址： https://gongjintao.com/post/5c764364.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>CCF试题库</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF认证题库201409-1————相邻对数]]></title>
    <url>%2Fpost%2F32600b60.html</url>
    <content type="text"><![CDATA[问题描述 给定n个不同的整数，问这些数中有多少对整数，它们的值正好相差1。 输入格式 输入的第一行包含一个整数n，表示给定整数的个数。第二行包含所给定的n个整数。 输出格式 输出一个整数，表示值正好相差1的数对的个数。 样例输入 610 2 6 3 7 8 样例输出 3 样例说明 值正好相差1的数对包括(2, 3), (6, 7), (7, 8)。 评测用例规模与约定 1&lt;=n&lt;=1000，给定的整数为不超过10000的非负整数。 解题思路 循环判断后面的数与当前数只差的绝对值是否等于1，然后累计即可。 代码实例1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; int n,i,j,sum=0; cin&gt;&gt;n; int *a=new int[n]; for(i=0;i&lt;n;i++)&#123; cin&gt;&gt;a[i]; &#125; for(i=0;i&lt;n-1;i++)&#123; for(j=i+1;j&lt;n;j++)&#123; if(abs(a[j]-a[i])==1)&#123; sum++; &#125; &#125; &#125; cout&lt;&lt;sum;&#125; (声明：菜鸟拙见，大神勿喷)本文作者：Gong Jintao本文地址： https://gongjintao.com/post/32600b60.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>CCF试题库</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF认证题库201412-2————Z字形扫描]]></title>
    <url>%2Fpost%2Ff761bd98.html</url>
    <content type="text"><![CDATA[问题描述 在图像编码的算法中，需要将一个给定的方形矩阵进行Z字形扫描(Zigzag Scan)。给定一个n×n的矩阵，Z字形扫描的过程如下图所示： 对于下面的4×4的矩阵， 1 5 3 9 3 7 5 6 9 4 6 4 7 3 1 3 对其进行Z字形扫描后得到长度为16的序列： 1 5 3 9 7 3 9 5 4 7 3 6 6 4 1 3 请实现一个Z字形扫描的程序，给定一个n×n的矩阵，输出对这个矩阵进行Z字形扫描的结果。 输入格式 输入的第一行包含一个整数n，表示矩阵的大小。 输入的第二行到第n+1行每行包含n个正整数，由空格分隔，表示给定的矩阵。 输出格式 输出一行，包含n×n个整数，由空格分隔，表示输入的矩阵经过Z字形扫描后的结果。 样例输入 41 5 3 93 7 5 69 4 6 47 3 1 3 样例输出 1 5 3 9 7 3 9 5 4 7 3 6 6 4 1 3 评测用例规模与约定 1≤n≤500，矩阵元素为不超过1000的正整数。 解题思路 注意不要被示例的图片局限了范围。要考虑全面。依图可知，可以将运动方向分为4个方向：向右、左下、向下、右上。当向右时，列号加1。然后判断若该数行号为1，则将向左下运动；若行号是n，则将向右上运动。当向左下时，行号加1，列号减1。然后判断该数若列号为1，则将向下运动；若行号是n，则将向右运动。当向下运动时，则行号加1。然后判断该数若列号为1，则将向右上运动，其他则是向左下运动。当向右上运动时，则行号减1，列号加1。然后判断该数若行号为1且不是最右边那个，则将向右运动，若是最右边那个，则将向下运动。 代码示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;using namespace std;int main()&#123; int n,i,j; cin&gt;&gt;n; int num[n+1][n+1]; for(i=1;i&lt;=n;i++)&#123; for(j=1;j&lt;=n;j++)&#123; cin&gt;&gt;num[i][j]; &#125; &#125; int d=1;//1 向右，2 左下，3 向下，4 右上 i=j=1; while(i+j&lt;2*n)&#123; switch(d) &#123; case 1: cout&lt;&lt;num[i][j++]&lt;&lt;" "; if(i == 1)&#123; d = 2; &#125; if(i == n)&#123; d = 4; &#125; break; case 2: cout&lt;&lt;num[i++][j--]&lt;&lt;" "; if(j == 1)&#123; d = 3; &#125; if(i == n)&#123; d = 1; &#125; break; case 3: cout&lt;&lt;num[i++][j]&lt;&lt;" "; if(j == 1)&#123; d = 4; &#125;else&#123; d = 2; &#125; break; case 4: cout&lt;&lt;num[i--][j++]&lt;&lt;" "; if(i == 1 &amp;&amp; j != n)&#123; d = 1; &#125;else if(j == n)&#123; d = 3; &#125; break; &#125; &#125; cout&lt;&lt;num[i][j]; return 0;&#125; (声明：菜鸟拙见，大神勿喷)本文作者：Gong Jintao本文地址： https://gongjintao.com/post/f761bd98.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>CCF试题库</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF认证题库201412-1————门禁系统]]></title>
    <url>%2Fpost%2Fdc6ecd66.html</url>
    <content type="text"><![CDATA[问题描述 涛涛最近要负责图书馆的管理工作，需要记录下每天读者的到访情况。每位读者有一个编号，每条记录用读者的编号来表示。给出读者的来访记录，请问每一条记录中的读者是第几次出现。 输入格式 输入的第一行包含一个整数n，表示涛涛的记录条数。 第二行包含n个整数，依次表示涛涛的记录中每位读者的编号。 输出格式 输出一行，包含n个整数，由空格分隔，依次表示每条记录中的读者编号是第几次出现。 样例输入 51 2 1 1 3 样例输出 1 1 2 3 1 评测用例规模与约定 1≤n≤1,000，读者的编号为不超过n的正整数。 解题思路 题目思路简单，只算前面有多少数字与当前数相等即可，注意的是设置的计数器num初始值为1。 代码示例123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123; int n,i,j,num=1; cin&gt;&gt;n; int *a=new int[n]; for(i=0;i&lt;n;i++)&#123; cin&gt;&gt;a[i]; &#125; vector&lt;int&gt; v; v.push_back(1); for(i=1;i&lt;n;i++)&#123; for(j=0;j&lt;i;j++)&#123; if(a[i]==a[j])&#123; num++; &#125; &#125; v.push_back(num); num=1; &#125; for(i=0;i&lt;v.size();i++)&#123; cout&lt;&lt;v[i]&lt;&lt;" "; &#125; return 0;&#125; (声明：菜鸟拙见，大神勿喷)本文作者：Gong Jintao本文地址： https://gongjintao.com/post/dc6ecd66.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>CCF试题库</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF认证题库201503-2————数字排序]]></title>
    <url>%2Fpost%2Fc45184a8.html</url>
    <content type="text"><![CDATA[问题描述 给定n个整数，请统计出每个整数出现的次数，按出现次数从多到少的顺序输出。 输入格式 输入的第一行包含一个整数n，表示给定数字的个数。第二行包含n个整数，相邻的整数之间用一个空格分隔，表示所给定的整数。 输出格式 输出多行，每行包含两个整数，分别表示一个给定的整数和它出现的次数。按出现次数递减的顺序输出。如果两个整数出现的次数一样多，则先输出值较小的，然后输出值较大的。 样例输入 125 2 3 3 1 3 4 2 5 2 3 5 样例输出 3 42 35 31 14 1 评测用例规模与约定 1 ≤ n ≤ 1000，给出的数都是不超过1000的非负整数。 解题思路 对于这类问题可以总结出一个通用的方法。即不是单纯的数字排序，而是有多个因素的结构体，按其中一个因素进行排序。如 201709-2公共钥匙盒。所以可以用 STL中的 sort 函数,然后用自定义排序方法进行排序。 代码示例1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;typedef struct Num&#123; int data; int num;&#125;Num;int cmp(const Num &amp;a,const Num &amp;b)&#123; if(a.num!=b.num) return a.num&gt;b.num; else return a.data&lt;b.data;&#125;int main()&#123; int n,i; cin&gt;&gt;n; int a[n]; int b[1001]=&#123;0&#125;; vector&lt;Num&gt; v; for(i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; b[a[i]]++; &#125; for(i=1;i&lt;1001;i++) &#123; Num t; if(b[i]!=0)&#123; t.data=i; t.num=b[i]; v.push_back(t); &#125; &#125; sort(v.begin(),v.end(),cmp); for(i=0;i&lt;v.size();i++)&#123; Num temp; temp=v[i]; cout&lt;&lt;temp.data&lt;&lt;" "&lt;&lt;temp.num&lt;&lt;endl; &#125; return 0;&#125; (声明：菜鸟拙见，大神勿喷)本文作者：Gong Jintao本文地址： https://gongjintao.com/post/c45184a8.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>CCF试题库</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF认证题库201503-1————图像旋转]]></title>
    <url>%2Fpost%2Fd74fc073.html</url>
    <content type="text"><![CDATA[问题描述 旋转是图像处理的基本操作，在这个问题中，你需要将一个图像逆时针旋转90度。 计算机中的图像表示可以用一个矩阵来表示，为了旋转一个图像，只需要将对应的矩阵旋转即可。 输入格式 输入的第一行包含两个整数n, m，分别表示图像矩阵的行数和列数。 接下来n行每行包含m个整数，表示输入的图像。 输出格式 输出m行，每行包含n个整数，表示原始矩阵逆时针旋转90度后的矩阵。 样例输入 2 31 5 33 2 4 样例输出 3 45 21 3 评测用例规模与约定 1 ≤ n, m ≤ 1,000，矩阵中的数都是不超过1000的非负整数。 解题思路 思路很简单，只是一个 反转输出数组的问题。需要注意的是要把数组定义成全局变量，而不是在函数内定义。(第一次提交一直是80分，后来上网搜说是定义在函数里，数组过大 DEV-CPP 崩了)。 代码示例1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;const int N=1000;int arr[N][N];int main()&#123; int m,n,i,j; cin&gt;&gt;m&gt;&gt;n; for(i=0;i&lt;m;i++) &#123; for(j=0;j&lt;n;j++) &#123; cin&gt;&gt;arr[i][j]; &#125; &#125; for(j=n-1;j&gt;=0;j--) &#123; for(i=0;i&lt;m;i++) &#123; cout&lt;&lt;arr[i][j]&lt;&lt;" "; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; (声明：菜鸟拙见，大神勿喷)本文作者：Gong Jintao本文地址： https://gongjintao.com/post/d74fc073.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>CCF试题库</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF认证题库201509-2————日期计算]]></title>
    <url>%2Fpost%2F263634da.html</url>
    <content type="text"><![CDATA[问题描述 给定一个年份y和一个整数d，问这一年的第d天是几月几日？ 注意闰年的2月有29天。满足下面条件之一的是闰年： 1） 年份是4的整数倍，而且不是100的整数倍； 2） 年份是400的整数倍。 输入格式 输入的第一行包含一个整数y，表示年份，年份在1900到2015之间（包含1900和2015）。 输入的第二行包含一个整数d，d在1至365之间。 输出格式 输出两行，每行一个整数，分别表示答案的月份和日期。 样例输入 201580 样例输出 321 样例输入 200040 样例输出 29 解题思路 设置一个12维数组days，即每个月的天数； 判断是否是闰年，若是则要将days[1]置为29； 累加数组中每一项，看是否和大于给出的总天数。若大于，则最后加的那一项即月份所在； 然后用累加和减去给出的天数，然后用所在月份的天数减去这个差值，即几号。 代码示例1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;int judgeY(int year)&#123; if((year%4 ==0 &amp;&amp; year%100!=0) || year%400==0) return 1; return 0;&#125;int main()&#123; int y,d,flag,sumd=0,month,day,i;//flag表示是否是闰年，1表示闰年，0表示平年 int days[]=&#123;31,28,31,30,31,30,31,31,30,31,30,31&#125;; cin&gt;&gt;y&gt;&gt;d; flag=judgeY(y); if(flag) days[1]=29; for(i=0;i&lt;12;i++)&#123; sumd+=days[i]; if(sumd&gt;=d)&#123; month=i+1; day=days[i]-(sumd-d);//记得要用该月的天数减去相差的天数才是第几号 break; &#125; &#125; cout&lt;&lt;month&lt;&lt;endl&lt;&lt;day; return 0;&#125; (声明：菜鸟拙见，大神勿喷)本文作者：Gong Jintao本文地址： https://gongjintao.com/post/263634da.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>CCF试题库</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF认证题库201509-1————数列分段]]></title>
    <url>%2Fpost%2F63fb49b9.html</url>
    <content type="text"><![CDATA[问题描述 给定一个整数数列，数列中连续相同的最长整数序列算成一段，问数列中共有多少段？ 输入格式 输入的第一行包含一个整数n，表示数列中整数的个数。 第二行包含n个整数a1, a2, …, an，表示给定的数列，相邻的整数之间用一个空格分隔。 输出格式 输出一个整数，表示给定的数列有多个段。 样例输入 88 8 8 0 12 12 8 0 样例输出 5 样例说明 8 8 8是第一段，0是第二段，12 12是第三段，倒数第二个整数8是第四段，最后一个0是第五段。 评测用例规模与约定 1 ≤ n ≤ 1000，0 ≤ ai ≤ 1000。 解题思路 循环录入的数组，当后一个数不等于前一个数时，段数加1。 代码示例12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int main()&#123; int n,i,sum=1; cin&gt;&gt;n; int num[n]; for(i=0;i&lt;n;i++)&#123; cin&gt;&gt;num[i]; &#125; for(i=1;i&lt;n;i++)&#123; if(num[i]!=num[i-1])&#123; sum++; &#125; &#125; cout&lt;&lt;sum; return 0; &#125; (声明：菜鸟拙见，大神勿喷)本文作者：Gong Jintao本文地址： https://gongjintao.com/post/63fb49b9.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>CCF试题库</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF认证题库201512-2————消除类游戏]]></title>
    <url>%2Fpost%2F8052574.html</url>
    <content type="text"><![CDATA[问题描述 消除类游戏是深受大众欢迎的一种游戏，游戏在一个包含有n行m列的游戏棋盘上进行，棋盘的每一行每一列的方格上放着一个有颜色的棋子，当一行或一列上有连续三个或更多的相同颜色的棋子时，这些棋子都被消除。当有多处可以被消除时，这些地方的棋子将同时被消除。 现在给你一个n行m列的棋盘，棋盘中的每一个方格上有一个棋子，请给出经过一次消除后的棋盘。 请注意：一个棋子可能在某一行和某一列同时被消除。 输入格式 输入的第一行包含两个整数n, m，用空格分隔，分别表示棋盘的行数和列数。 接下来n行，每行m个整数，用空格分隔，分别表示每一个方格中的棋子的颜色。颜色使用1至9编号。 输出格式 输出n行，每行m个整数，相邻的整数之间使用一个空格分隔，表示经过一次消除后的棋盘。如果一个方格中的棋子被消除，则对应的方格输出0，否则输出棋子的颜色编号。 样例输入 4 52 2 3 1 23 4 5 1 42 3 2 1 32 2 2 4 4 样例输出 2 2 3 0 23 4 5 0 42 3 2 0 30 0 0 4 4 样例说明 棋盘中第4列的1和第4行的2可以被消除，其他的方格中的棋子均保留。 样例输入 4 52 2 3 1 23 1 1 1 12 3 2 1 32 2 3 3 3 样例输出 2 2 3 0 23 0 0 0 02 3 2 0 32 2 0 0 0 样例说明 棋盘中所有的1以及最后一行的3可以被同时消除，其他的方格中的棋子均保留。 评测用例规模与约定 所有的评测用例满足：1 ≤ n, m ≤ 30。 解题思路 作矩阵flag[n][m]初始值都为0。 按行循环棋盘，若一行中有连续数字满足，则将flag中对应位置的数值置为1；同理再按列循环棋盘，操作一致。 然后循环判断flag矩阵，若值为0则输出原矩阵中对应位置中的值，若为1，则输出0。 代码示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;using namespace std;int main()&#123; int n,m,i,j,k; cin&gt;&gt;n&gt;&gt;m; int a[n][m];//原始矩阵 int flag[n][m] = &#123;0&#125;;//标记矩阵，1表示可以消去 for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;m;j++)&#123; cin&gt;&gt;a[i][j]; flag[i][j] = 0; &#125; &#125; for(i=0;i&lt;n;i++)&#123; int start=0; int num=1; for(j=0;j&lt;m;j++)&#123; if(j!=m-1 &amp;&amp; a[i][j]==a[i][j+1])&#123;//如果后一个数等于前一个数，计数器+1 num++; &#125;else&#123; if(num&gt;=3)&#123;//当不等于时，判断计数器 是否大于3 while(num--)&#123; flag[i][j-num] = 1; &#125; &#125; num=1;//计数器重置 &#125; &#125; &#125; for(j=0;j&lt;m;j++)&#123; int start=0; int num=1; for(i=0;i&lt;n;i++)&#123; if(i!=n-1 &amp;&amp; a[i][j]==a[i+1][j])&#123; num++; &#125;else&#123; if(num&gt;=3)&#123; while(num--)&#123; flag[i-num][j] = 1; &#125; &#125; num=1; &#125; &#125; &#125; for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;m;j++)&#123; if(flag[i][j]==1)&#123; cout&lt;&lt;"0 "; &#125;else&#123; cout&lt;&lt;a[i][j]&lt;&lt;" "; &#125; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; (声明：菜鸟拙见，大神勿喷)本文作者：Gong Jintao本文地址： https://gongjintao.com/post/8052574.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>CCF试题库</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF认证题库201512-1————数位之和]]></title>
    <url>%2Fpost%2F816710d7.html</url>
    <content type="text"><![CDATA[问题描述 给定一个十进制整数n，输出n的各位数字之和。 输入格式 输入一个整数n。 输出格式 输出一个整数，表示答案。 样例输入 20151220 样例输出 13 样例说明 20151220的各位数字之和为2+0+1+5+1+2+2+0=13。 评测用例规模与约定 所有评测用例满足：0 ≤ n ≤ 1000000000。 解题思路 录入数字为string类型，然后循环每个字符，将其变成数字，再累加。 代码示例12345678910111213#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string s; int sum=0,i; cin&gt;&gt;s; for(i=0;i&lt;s.size();i++)&#123;//求string的长度函数为s.length()和 s.size(); sum+=(s[i]-'0');//将字符串数字变成整型数字 &#125; cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125; (声明：菜鸟拙见，大神勿喷)本文作者：Gong Jintao本文地址： https://gongjintao.com/post/816710d7.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>CCF试题库</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF认证题库201604-2————俄罗斯方块]]></title>
    <url>%2Fpost%2F11ee9fba.html</url>
    <content type="text"><![CDATA[问题描述 俄罗斯方块是俄罗斯人阿列克谢·帕基特诺夫发明的一款休闲游戏。 游戏在一个15行10列的方格图上进行，方格图上的每一个格子可能已经放置了方块，或者没有放置方块。每一轮，都会有一个新的由4个小方块组成的板块从方格图的上方落下，玩家可以操作板块左右移动放到合适的位置，当板块中某一个方块的下边缘与方格图上的方块上边缘重合或者达到下边界时，板块不再移动，如果此时方格图的某一行全放满了方块，则该行被消除并得分。 在这个问题中，你需要写一个程序来模拟板块下落，你不需要处理玩家的操作，也不需要处理消行和得分。 具体的，给定一个初始的方格图，以及一个板块的形状和它下落的初始位置，你要给出最终的方格图。 输入格式 输入的前15行包含初始的方格图，每行包含10个数字，相邻的数字用空格分隔。如果一个数字是0，表示对应的方格中没有方块，如果数字是1，则表示初始的时候有方块。输入保证前4行中的数字都是0。 输入的第16至第19行包含新加入的板块的形状，每行包含4个数字，组成了板块图案，同样0表示没方块，1表示有方块。输入保证板块的图案中正好包含4个方块，且4个方块是连在一起的（准确的说，4个方块是四连通的，即给定的板块是俄罗斯方块的标准板块）。 第20行包含一个1到7之间的整数，表示板块图案最左边开始的时候是在方格图的哪一列中。注意，这里的板块图案指的是16至19行所输入的板块图案，如果板块图案的最左边一列全是0，则它的左边和实际所表示的板块的左边是不一致的（见样例）输出格式 输出15行，每行10个数字，相邻的数字之间用一个空格分隔，表示板块下落后的方格图。注意，你不需要处理最终的消行。 输出格式 输出15行，每行10个数字，相邻的数字之间用一个空格分隔，表示板块下落后的方格图。注意，你不需要处理最终的消行。 样例输入 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 1 0 00 0 0 0 0 0 1 0 0 00 0 0 0 0 0 1 0 0 01 1 1 0 0 0 1 1 1 10 0 0 0 1 0 0 0 0 00 0 0 00 1 1 10 0 0 10 0 0 03 样例输出 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 1 0 00 0 0 0 0 0 1 0 0 00 0 0 0 0 0 1 0 0 01 1 1 1 1 1 1 1 1 10 0 0 0 1 1 0 0 0 0 解题思路 将方格(15x10)输入为矩阵a;将图案(4x4)输入为矩阵b。 然后找出a中从第m列往右3列的每列第一个出现1的行号录入rowa(从上到下为0到14)；找出b中每列最后出现1的行号rowb(从上到下为0到4)。两个行号相距最大的那一列即约束列,设列号为index，则相距值minus=rowa[index]-rowb[index]。 然后计算图案中每个1在方格中的坐标：即遍历矩阵b，当b[i][j]==1,则对应的a[i+minus][m+j]=1;即该数行号在加上相差值，则对应在a中的行号，该数列号再加上起始列号m，则对应在a中的列号。 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;using namespace std;int main()&#123; int a[15][10],b[4][4],m,i,j,k; int rowa[4]=&#123;14,14,14,14&#125;; int rowb[4]=&#123;-1,-1,-1,-1&#125;; int num[4]=&#123;0&#125;; //输入数据 for(i=0;i&lt;15;i++)&#123; for(j=0;j&lt;10;j++)&#123; cin&gt;&gt;a[i][j]; &#125; &#125; for(i=0;i&lt;4;i++)&#123; for(j=0;j&lt;4;j++)&#123; cin&gt;&gt;b[i][j]; &#125; &#125; cin&gt;&gt;m; //约束条件为图案矩阵中的最下面出现的行数1与方格最开始出现1的行数之间的差值，那一列最小就是约束条件 //计算第j列的第i行可以开始安排放置 m=m-1; for(j=m,k=0;j&lt;m+4;j++,k++)&#123; for(i=0;i&lt;15 ;i++)&#123; if(a[i][j]==1)&#123;//如果第i行等于1，则从第i-1行开始安排放置 rowa[k]=i-1; &#125; &#125; &#125; //计算图案（即4x4的矩阵）中有1出现的最下面那一行 for(j=0;j&lt;4;j++)&#123; for(i=0;i&lt;4;i++)&#123; if(b[i][j]==1)&#123; rowb[j]=i; &#125; &#125; &#125; //然后计算连个行号之间相差最小的那个插值 int min = 15; int index = 0; for(i=0;i&lt;4;i++)&#123; if( (rowa[i]-rowb[i]) &lt; min)&#123; min = rowa[i]-rowb[i]; index = i; &#125; &#125; //计算坐标,将图案填充进表格 for(i=0;i&lt;4;i++)&#123; for(j=0;j&lt;4;j++)&#123; if(b[i][j]==1)&#123; a[rowa[index]+i-rowb[index]][m+j]=1; &#125; &#125; &#125; for(i=0;i&lt;15;i++)&#123; for(j=0;j&lt;10;j++)&#123; if(j!=9) cout&lt;&lt;a[i][j]&lt;&lt;' '; else cout&lt;&lt;a[i][j]&lt;&lt;endl; &#125; &#125; return 0;&#125; (声明：菜鸟拙见，大神勿喷)本文作者：Gong Jintao本文地址： https://gongjintao.com/post/11ee9fba.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>CCF试题库</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF认证题库201604-1————折点计算]]></title>
    <url>%2Fpost%2F51d4f4d3.html</url>
    <content type="text"><![CDATA[问题描述 给定n个整数表示一个商店连续n天的销售量。如果某天之前销售量在增长，而后一天销售量减少，则称这一天为折点，反过来如果之前销售量减少而后一天销售量增长，也称这一天为折点。其他的天都不是折点。如下图中，第3天和第6天是折点。 给定n个整数a1, a2, …, an表示销售量，请计算出这些天总共有多少个折点。 为了减少歧义，我们给定的数据保证：在这n天中相邻两天的销售量总是不同的，即ai-1≠ai。注意，如果两天不相邻，销售量可能相同。 输入格式 输入的第一行包含一个整数n。 第二行包含n个整数，用空格分隔，分别表示a1, a2, …, an。第二行包含n个正整数，依次表示每天的收盘价格。 输出格式 输出一个整数，表示折点出现的数量。 样例输入 75 4 1 2 3 6 4 样例输出 2 样例说明 所有评测用例满足：1 ≤ n ≤ 1000，每天的销售量是不超过10000的非负整数。 解题思路 本题思路简单，只需判断该点是否前后两点比该点大或者小即可，然后统计个数。 代码示例1234567891011121314151617#include &lt;iostream&gt;using namespace std;int main()&#123; int n,i,num=0; cin&gt;&gt;n; int *a = new int[n]; for(i=0;i&lt;n;i++)&#123; cin&gt;&gt;a[i]; &#125; for(i=1;i&lt;n-1;i++)&#123; if((a[i-1]&gt;a[i] &amp;&amp; a[i+1]&gt;a[i]) || (a[i-1]&lt;a[i] &amp;&amp; a[i+1]&lt;a[i]))&#123; num++; &#125; &#125; cout&lt;&lt;num; return 0;&#125; (声明：菜鸟拙见，大神勿喷)本文作者：Gong Jintao本文地址： https://gongjintao.com/post/51d4f4d3.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>CCF试题库</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF认证题库201609-2————火车购票]]></title>
    <url>%2Fpost%2Fb5e0b054.html</url>
    <content type="text"><![CDATA[问题描述 请实现一个铁路购票系统的简单座位分配算法，来处理一节车厢的座位分配。 假设一节车厢有20排、每一排5个座位。为方便起见，我们用1到100来给所有的座位编号，第一排是1到5号，第二排是6到10号，依次类推，第20排是96到100号。 购票时，一个人可能购一张或多张票，最多不超过5张。如果这几张票可以安排在同一排编号相邻的座位，则应该安排在编号最小的相邻座位。否则应该安排在编号最小的几个空座位中（不考虑是否相邻）。 假设初始时车票全部未被购买，现在给了一些购票指令，请你处理这些指令。 输入格式 输入的第一行包含一个整数n，表示购票指令的数量。第二行包含n个整数，每个整数p在1到5之间，表示要购入的票数，相邻的两个数之间使用一个空格分隔。 输出格式 输出n行，每行对应一条指令的处理结果。对于购票指令p，输出p张车票的编号，按从小到大排序。 样例输入 42 5 4 2 样例输出 1 26 7 8 9 1011 12 13 143 4 样例说明 1) 购2张票，得到座位1、2。2) 购5张票，得到座位6至10。3) 购4张票，得到座位11至14。4) 购2张票，得到座位3、4。 评测用例规模与约定 对于所有评测用例，1 ≤ n ≤ 100，所有购票数量之和不超过100。 解题思路 本题比较繁琐，采用的是暴力解法。希望大佬能指点一二。首先要理解题意，优先是考虑相邻空座进行派座，否则按从小到大进行派座(由于一开始这里没看清，所以一直是90分，弄了挺久)题目思虑其实比较简单，就是每一行进行判断，若有足够多的相邻空位就可以安排，所以设置函数 sum(){}//计算该行中0的个数；然后从该行的第一个空位开始，安排num个位置（这里无需判断是否连续了，因为派座的结果是连续的）。否则判断下一行。因为有不满足第一个规则的情况，所以要设置 flag,一开始设置 flag = 1，当进行循环后，若有满足前一个规则的，则置flag = 0，否则若循环完所有行数之后 flag依旧为1，表明无足够多的相邻空座可以安排，按另一个规则派座。 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;using namespace std;int sum(int a[])&#123; int s=0,k; for(k=0;k&lt;5;k++)&#123; if(a[k]==0)s++; &#125; return s;&#125;int main()&#123; int n,num,i,j,k,flag; cin&gt;&gt;n; int a[20][5]=&#123;0&#125;; while(n)&#123; cin&gt;&gt;num; flag=1; for(i=0;i&lt;20;i++)&#123; int s; s=sum(a[i]);//计算每一排是否有足够多的相邻空位 if(s&gt;=num)&#123; for(j=0;j&lt;5;j++)&#123; if(a[i][j]==0)&#123;//从这一排的第一个空位开始安排 for(k=j;k&lt;j+num;k++)&#123; a[i][k]=1;//将空位置为1，表明已坐 cout&lt;&lt;(i*5+k+1)&lt;&lt;" "; &#125; cout&lt;&lt;endl; break; &#125; &#125; flag=0; break;//表明已经安排座位坐下，跳出循环，继续下一次输入 &#125; continue; //表明当前排没有足够空位，继续判断下一排 &#125; if(flag)&#123;//表明没有足够多的相邻空位可以安排 for(i=0;i&lt;20 &amp;&amp; num&gt;0 ;i++)&#123; for(j=0;j&lt;5;j++)&#123; if(a[i][j]==0)&#123; a[i][j]=1; cout&lt;&lt;(i*5+(j+1))&lt;&lt;" "; num--; &#125; &#125; &#125; &#125; n--; &#125; return 0;&#125; (声明：菜鸟拙见，大神勿喷)本文作者：Gong Jintao本文地址： https://gongjintao.com/post/b5e0b054.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>CCF试题库</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF认证题库201609-1————最大波动]]></title>
    <url>%2Fpost%2F3c6abc55.html</url>
    <content type="text"><![CDATA[问题描述 小明正在利用股票的波动程度来研究股票。小明拿到了一只股票每天收盘时的价格，他想知道，这只股票连续几天的最大波动值是多少，即在这几天中某天收盘价格与前一天收盘价格之差的绝对值最大是多少。 输入格式 输入的第一行包含了一个整数n，表示小明拿到的收盘价格的连续天数。第二行包含n个正整数，依次表示每天的收盘价格。 输出格式 输出一个整数，表示这只股票这n天中的最大波动值。 样例输入 62 5 5 7 3 5 样例输出 4 样例说明 第四天和第五天之间的波动最大，波动值为|3-7|=4。评测用例规模与约定对于所有评测用例，2 ≤ n ≤ 1000。股票每一天的价格为1到10000之间的整数。 解题思路 只需循环的用后一个与前一个作差，去绝对值，然后保留与最大值比较即可 。 代码示例123456789101112131415161718192021#include&lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int n,i,max=0; cin&gt;&gt;n; int *a; a = new int[n]; for(i=0;i&lt;n;i++)&#123; cin&gt;&gt;a[i]; &#125; for(i=0;i&lt;n-1;i++)&#123; int temp; temp=abs(a[i+1]-a[i]); if(temp&gt;max)&#123; max=temp; &#125; &#125; cout&lt;&lt;max&lt;&lt;endl; return 0;&#125; (声明：菜鸟拙见，大神勿喷)本文作者：Gong Jintao本文地址： https://gongjintao.com/post/3c6abc55.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>CCF试题库</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF认证题库201612-1————中间数]]></title>
    <url>%2Fpost%2Ff5eadf3d.html</url>
    <content type="text"><![CDATA[问题描述 在一个整数序列a1, a2, …, an中，如果存在某个数，大于它的整数数量等于小于它的整数数量，则称其为中间数。在一个序列中，可能存在多个下标不相同的中间数，这些中间数的值是相同的。 给定一个整数序列，请找出这个整数序列的中间数的值。 输入格式 输入的第一行包含了一个整数n，表示整数序列中数的个数。 第二行包含n个正整数，依次表示a1, a2, …, an。 输出格式 如果约定序列的中间数存在，则输出中间数的值，否则输出-1表示不存在中间数。 样例输入 62 6 5 6 3 5 样例输出 5 样例说明 比5小的数有2个，比5大的数也有2个。 样例输入 43 4 6 7 样例输出 -1 样例说明 在序列中的4个数都不满足中间数的定义。 样例输入 53 4 6 6 7 样例输出 -1 样例说明 在序列中的5个数都不满足中间数的定义。 评测用例规模与约定 对于所有评测用例，1 ≤ n ≤ 1000，1 ≤ ai ≤ 1000。 解题思路 做两次循环对比即可解决问题。注意的是题目中说到中间数可能有多个 ，但是值是一样的，所以如果判断存在中间数，便可以跳出循环，然后每次判断完一个数，若不是中间数要将计数器重置为0。 代码示例12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;int main()&#123; int n,i,numl=0,numg=0,flag=1; cin&gt;&gt;n; int *arr = new int[n];//动态申请数组 for(i=0;i&lt;n;i++)&#123; cin&gt;&gt;arr[i]; &#125; for(i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n;j++)&#123; if(arr[j]&gt;arr[i])&#123; numg++; &#125;else if(arr[j]&lt;arr[i])&#123; numl++; &#125; &#125; if(numg==numl)&#123; cout&lt;&lt;arr[i]; flag=0; break; &#125; numg=numl=0;//表明该数不是中间数，计数器重置 &#125; if(flag)cout&lt;&lt;-1;//没有中间数 return 0;&#125; (声明：菜鸟拙见，大神勿喷)本文作者：Gong Jintao本文地址： https://gongjintao.com/post/f5eadf3d.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>CCF试题库</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF认证题库201703-2————学生排队]]></title>
    <url>%2Fpost%2Ff95d3e71.html</url>
    <content type="text"><![CDATA[问题描述 体育老师小明要将自己班上的学生按顺序排队。他首先让学生按学号从小到大的顺序排成一排，学号小的排在前面，然后进行多次调整。一次调整小明可能让一位同学出队，向前或者向后移动一段距离后再插入队列。 例如，下面给出了一组移动的例子，例子中学生的人数为8人。 0）初始队列中学生的学号依次为1, 2, 3, 4, 5, 6, 7, 8； 1）第一次调整，命令为“3号同学向后移动2”，表示3号同学出队，向后移动2名同学的距离，再插入到队列中，新队列中学生的学号依次为1, 2, 4, 5, 3, 6, 7, 8； 2）第二次调整，命令为“8号同学向前移动3”，表示8号同学出队，向前移动3名同学的距离，再插入到队列中，新队列中学生的学号依次为1, 2, 4, 5, 8, 3, 6, 7； 3）第三次调整，命令为“3号同学向前移动2”，表示3号同学出队，向前移动2名同学的距离，再插入到队列中，新队列中学生的学号依次为1, 2, 4, 3, 5, 8, 6, 7。 小明记录了所有调整的过程，请问，最终从前向后所有学生的学号依次是多少？ 请特别注意，上述移动过程中所涉及的号码指的是学号，而不是在队伍中的位置。在向后移动时，移动的距离不超过对应同学后面的人数，如果向后移动的距离正好等于对应同学后面的人数则该同学会移动到队列的最后面。在向前移动时，移动的距离不超过对应同学前面的人数，如果向前移动的距离正好等于对应同学前面的人数则该同学会移动到队列的最前面。 输入格式 输入的第一行包含一个整数n，表示学生的数量，学生的学号由1到n编号。 第二行包含一个整数m，表示调整的次数。 接下来m行，每行两个整数p, q，如果q为正，表示学号为p的同学向后移动q，如果q为负，表示学号为p的同学向前移动-q。输出格式 输出一行，包含n个整数，相邻两个整数之间由一个空格分隔，表示最终从前向后所有学生的学号。 样例输入 833 28 -33 -2 样例输出 1 2 4 3 5 8 6 7评测用例规模与约定对于所有评测用例，1 ≤ n ≤ 1000，1 ≤ m ≤ 1000，所有移动均合法。 解题思路 题目较为简单，只是将数组数据进行前后移动首先获取的同学p所在队伍中的位置pos，构造函数int position(int a[],int p,int len){},其中a表示队伍数组，p表示学号，len表示队伍长度;然后进行数组中数据的移动，构造函数int *change(int a[],int q,int pos){},其中a表示队伍数组，q表示前后移动的位数，pos表示同学p所在的位置。 代码示例1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;stdlib.h&gt;using namespace std;int position(int a[],int p,int len)&#123; int i; for(i=0;i&lt;len;i++)&#123; if(a[i]==p) return i; &#125;&#125;int *change(int a[],int q,int pos)&#123; int i,temp; temp=a[pos]; if(q&gt;0)&#123; for(i=pos;i&lt;pos+q;i++)&#123; a[i]=a[i+1]; &#125; &#125;else&#123; for(i=pos;i&gt;pos+q;i--)&#123; a[i]=a[i-1]; &#125; &#125; a[pos+q]=temp; return a;&#125;int main()&#123; int n,m,i,p,q,len; cin&gt;&gt;n&gt;&gt;m; int *a; a = (int*)malloc(sizeof(int)*n); len=n; for(i=0;i&lt;n;i++)&#123; a[i]=i+1; &#125; while(m--)&#123; cin&gt;&gt;p&gt;&gt;q; int pos; pos=position(a,p,len); a = change(a,q,pos); &#125; for(i=0;i&lt;len;i++)&#123; cout&lt;&lt;a[i]&lt;&lt;" "; &#125; return 0; &#125; (声明：菜鸟拙见，大神勿喷)本文作者：Gong Jintao本文地址： https://gongjintao.com/post/f95d3e71.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>CCF试题库</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF认证题库201703-1————分蛋糕]]></title>
    <url>%2Fpost%2F46a94ddc.html</url>
    <content type="text"><![CDATA[问题描述 小明今天生日，他有n块蛋糕要分给朋友们吃，这n块蛋糕（编号为1到n）的重量分别为a1, a2, …, an。小明想分给每个朋友至少重量为k的蛋糕。小明的朋友们已经排好队准备领蛋糕，对于每个朋友，小明总是先将自己手中编号最小的蛋糕分给他，当这个朋友所分得蛋糕的重量不到k时，再继续将剩下的蛋糕中编号最小的给他，直到小明的蛋糕分完或者这个朋友分到的蛋糕的总重量大于等于k。 请问当小明的蛋糕分完时，总共有多少个朋友分到了蛋糕。 输入格式 输入的第一行包含了两个整数n, k，意义如上所述。 第二行包含n个正整数，依次表示a1, a2, …, an。 输出格式 输出一个整数，表示有多少个朋友分到了蛋糕。 样例输入 6 92 6 5 6 3 5 样例输出 3 样例说明 第一个朋友分到了前3块蛋糕，第二个朋友分到了第4、5块蛋糕，第三个朋友分到了最后一块蛋糕。 评测用例规模与约定 对于所有评测用例，1 ≤ n ≤ 1000，1 ≤ k ≤ 10000，1 ≤ ai ≤ 1000。 解题思路先用数组a[]保存每次分配的蛋糕，然后循环数组a[]中。若a[i]小于 K，继续分配，并累加到临时变量temp中，当temp大于或等于K时，则人数加1；然后temp重置为0，再次计算。注意，当最后的temp值小于k时，未将人数加1，所以最后还需将人数再加1；而最后的temp值大于或等于k时，则无需加1。 代码示例12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;int main()&#123; int n,k,i; cin&gt;&gt;n&gt;&gt;k; int a[n]; //用来存放蛋糕分块 for(i=0;i&lt;n;i++)&#123; cin&gt;&gt;a[i]; &#125; int temp=0,sum=0; for(i=0;i&lt;n;i++)&#123; temp+=a[i]; if(temp&gt;=k)&#123;//当分配的蛋糕大于k时，人数sum+1 temp=0; sum++; &#125; &#125; if(temp!=0)sum++;//判断最后分配到蛋糕的人是否纳入计算 cout&lt;&lt;sum;&#125; (声明：菜鸟拙见，大神勿喷)本文作者：Gong Jintao本文地址： https://gongjintao.com/post/46a94ddc.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>CCF试题库</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF认证题库201709-2————公共钥匙盒]]></title>
    <url>%2Fpost%2Fd6d63a86.html</url>
    <content type="text"><![CDATA[问题描述 有一个学校的老师共用N个教室，按照规定，所有的钥匙都必须放在公共钥匙盒里，老师不能带钥匙回家。每次老师上课前，都从公共钥匙盒里找到自己上课的教室的钥匙去开门，上完课后，再将钥匙放回到钥匙盒中。 钥匙盒一共有N个挂钩，从左到右排成一排，用来挂N个教室的钥匙。一串钥匙没有固定的悬挂位置，但钥匙上有标识，所以老师们不会弄混钥匙。每次取钥匙的时候，老师们都会找到自己所需要的钥匙将其取走，而不会移动其他钥匙。每次还钥匙的时候，还钥匙的老师会找到最左边的空的挂钩，将钥匙挂在这个挂钩上。如果有多位老师还钥匙，则他们按钥匙编号从小到大的顺序还。如果同一时刻既有老师还钥匙又有老师取钥匙，则老师们会先将钥匙全还回去再取出。 今天开始的时候钥匙是按编号从小到大的顺序放在钥匙盒里的。有K位老师要上课，给出每位老师所需要的钥匙、开始上课的时间和上课的时长，假设下课时间就是还钥匙时间，请问最终钥匙盒里面钥匙的顺序是怎样的？ 输入格式 输入的第一行包含两个整数N, K。 接下来K行，每行三个整数w, s, c，分别表示一位老师要使用的钥匙编号、开始上课的时间和上课的时长。可能有多位老师使用同一把钥匙，但是老师使用钥匙的时间不会重叠。 保证输入数据满足输入格式，你不用检查数据合法性。输出格式 输出一行，包含N个整数，相邻整数间用一个空格分隔，依次表示每个挂钩上挂的钥匙编号。 样例输入 5 24 3 32 2 7 样例输出 1 4 3 2 5 样例说明 第一位老师从时刻3开始使用4号教室的钥匙，使用3单位时间，所以在时刻6还钥匙。第二位老师从时刻2开始使用钥匙，使用7单位时间，所以在时刻9还钥匙。 每个关键时刻后的钥匙状态如下（X表示空）： 时刻2后为1X345； 时刻3后为1X3X5； 时刻6后为143X5； 时刻9后为14325。 样例输入 5 71 1 143 3 121 15 122 7 203 18 124 21 195 30 9 样例输出 1 2 3 5 4 评测用例规模与约定 对于30%的评测用例，1 ≤ N, K ≤ 10, 1 ≤ w ≤ N, 1 ≤ s, c ≤ 30；对于60%的评测用例，1 ≤ N, K ≤ 50，1 ≤ w ≤ N，1 ≤ s ≤ 300，1 ≤ c ≤ 50；对于所有评测用例，1 ≤ N, K ≤ 1000，1 ≤ w ≤ N，1 ≤ s ≤ 10000，1 ≤ c ≤ 100。 解题思路 建议使用c++，STL中的函数可以提供便捷首先明确要对定义的教师进行排序，然而教师有取钥匙和还钥匙两种情况；所以根据题意，排序先按时间的大小进行排序（包括取钥匙时间和还钥匙时间）若时间相同则按取钥匙还是还钥匙进行排序，先还后取若动作是一致的则按钥匙的标号进行排序 代码示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int N,K,w,s,c;//定义教师结构体 typedef struct Teacher&#123; int index;//编号 int time;//开始时间或者结束时间 int flag;//0表示取钥匙，1表示还钥匙 &#125;T;//定义比较函数 //const T &amp;a，定义指向地址a的常量 int cmp(const T &amp;a,const T &amp;b)&#123; if(a.time!=b.time)&#123; return a.time&lt;b.time;//按时间排序，小的排在前面 &#125;else if(a.flag!=b.flag)&#123; return a.flag&gt;b.flag;//先还后取 &#125;else&#123; return a.index &lt; b.index;//按编号进行归还 &#125; &#125;int main()&#123; cin&gt;&gt;N&gt;&gt;K; int *key; key = (int*)malloc(sizeof(int)*(N+1));//动态申请数组用来存放钥匙 vector&lt;T&gt; v;//定义Teacher向量，每个教室对应取钥匙和还钥匙两个向量 //初始化钥匙位置 int i; for(i=1;i&lt;=N;i++)&#123; key[i]=i; &#125; for(i=0;i&lt;K;i++)&#123; cin&gt;&gt;w&gt;&gt;s&gt;&gt;c; T t; t.index = w; t.time = s; t.flag =0;//取钥匙 v.push_back(t);//将t插入向量中 t.index = w; t.time = s+c;//结束时间为 开始+上课时间 t.flag = 1;//还钥匙 v.push_back(t); &#125; //对向量按照重新定义的比较函数进行排序 sort(v.begin(),v.end(),cmp); for(i=0;i&lt;v.size();i++)&#123; T t= v[i]; if(t.flag == 0)&#123;//取钥匙 for(int j=1;j&lt;=N;j++)&#123; if(key[j]==t.index)&#123; key[j]=0; break; &#125; &#125; &#125;else&#123; for(int j=1;j&lt;=N;j++)&#123; if(key[j]==0)&#123; key[j]=t.index; break; &#125; &#125; &#125; &#125; //输出最终的钥匙串序列 for(i=1;i&lt;=N;i++)&#123; cout&lt;&lt;key[i]&lt;&lt;" "; &#125; return 0;&#125; (声明：菜鸟拙见，大神勿喷)本文作者：Gong Jintao本文地址： https://gongjintao.com/post/d6d63a86.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>CCF试题库</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF认证题库201709-1————打酱油]]></title>
    <url>%2Fpost%2F2c45e749.html</url>
    <content type="text"><![CDATA[问题描述 小明带着N元钱去买酱油。酱油10块钱一瓶，商家进行促销，每买3瓶送1瓶，或者每买5瓶送2瓶。请问小明最多可以得到多少瓶酱油。 输入格式 输入的第一行包含一个整数N，表示小明可用于买酱油的钱数。N是10的整数倍，N不超过300。 输出格式 输出一个整数，表示小明最多可以得到多少瓶酱油。 样例输入 40 样例输出 5 样例输入 80 样例输出 11 样例说明 把80元分成30元和50元，分别买3瓶和5瓶，其中3瓶送1瓶，5瓶送2瓶，共得到11瓶。 解题思路 题目较为简单。首先总共可以买k=N/10瓶，然后计算k可以由n1个5和n2个3组成；则总计的瓶数为num=n12+n21+k; 代码示例1234567891011#include&lt;stdio.h&gt;int main()&#123; int n,k,n1,n2,num; scanf("%d",&amp;n); k=n/10; n1=k/5; n2=(k-n1*5)/3; num=n1*2+n2*1+k; printf("%d",num); return 0;&#125; (声明：菜鸟拙见，大神勿喷)本文作者：Gong Jintao本文地址： https://gongjintao.com/post/2c45e749.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>CCF试题库</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF认证题库201712-1————最小差值]]></title>
    <url>%2Fpost%2Ff29a7c2e.html</url>
    <content type="text"><![CDATA[问题描述 给定n个数，请找出其中相差（差的绝对值）最小的两个数，输出它们的差值的绝对值。 输入格式 输入第一行包含一个整数n。第二行包含n个正整数，相邻整数之间使用一个空格分隔。 输出格式 输出一个整数，表示答案。 样例输入 51 5 4 8 20 样例输出 1 样例说明 相差最小的两个数是5和4，它们之间的差值是1。 样例输入 59 3 6 1 3 样例输出0 样例说明 有两个相同的数3，它们之间的差值是0. 数据规模和约定 对于所有评测用例，2 ≤ n ≤ 1000，每个给定的整数都是不超过10000的正整数。 解题思路 每个数后面的数一次与之相减得到差，然后取绝对值；然后设置一个最小差值，依次比较，当循环结束即得到结果。 代码示例123456789101112131415161718192021#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;int main()&#123; int n,i,j,min,temp; scanf("%d",&amp;n); int *a; a = (int*)malloc(sizeof(int)*n); for(i=0;i&lt;n;i++)&#123; scanf("%d",&amp;a[i]); &#125; min = abs(a[0]-a[1]); for(i=0;i&lt;n-1;i++)&#123; for(j=i+1;j&lt;n;j++)&#123; temp = abs(a[j]-a[i]); if(temp&lt;min) min = temp; &#125; &#125; printf("%d",min); return 0;&#125; (声明：菜鸟拙见，大神勿喷)本文作者：Gong Jintao本文地址： https://gongjintao.com/post/f29a7c2e.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>CCF试题库</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF认证题库201803-3————URL映射]]></title>
    <url>%2Fpost%2F1a472c8a.html</url>
    <content type="text"><![CDATA[问题描述 URL 映射是诸如 Django、Ruby on Rails 等网页框架 (web frameworks) 的一个重要组件。对于从浏览器发来的 HTTP 请求，URL 映射模块会解析请求中的 URL 地址，并将其分派给相应的处理代码。现在，请你来实现一个简单的 URL 映射功能。 本题中 URL 映射功能的配置由若干条 URL 映射规则组成。当一个请求到达时，URL 映射功能会将请求中的 URL 地址按照配置的先后顺序逐一与这些规则进行匹配。当遇到第一条完全匹配的规则时，匹配成功，得到匹配的规则以及匹配的参数。若不能匹配任何一条规则，则匹配失败。 本题输入的 URL 地址是以斜杠 / 作为分隔符的路径，保证以斜杠开头。其他合法字符还包括大小写英文字母、阿拉伯数字、减号 -、下划线 _ 和小数点 .。例如，/person/123/ 是一个合法的 URL 地址，而 /person/123? 则不合法（存在不合法的字符问号 ?）。另外，英文字母区分大小写，因此 /case/ 和 /CAse/ 是不同的 URL 地址。 对于 URL 映射规则，同样是以斜杠开始。除了可以是正常的 URL 地址外，还可以包含参数，有以下 3 种： 字符串 ：用于匹配一段字符串，注意字符串里不能包含斜杠。例如，abcde0123。 整数 ：用于匹配一个不带符号的整数，全部由阿拉伯数字组成。例如，01234。 路径 ：用于匹配一段字符串，字符串可以包含斜杠。例如，abcd/0123/。 以上 3 种参数都必须匹配非空的字符串。简便起见，题目规定规则中 和 前面一定是斜杠，后面要么是斜杠，要么是规则的结束（也就是该参数是规则的最后一部分）。而 的前面一定是斜杠，后面一定是规则的结束。无论是 URL 地址还是规则，都不会出现连续的斜杠。 输入格式 输入第一行是两个正整数 n 和 m，分别表示 URL 映射的规则条数和待处理的 URL 地址个数，中间用一个空格字符分隔。 第 2 行至第 n+1 行按匹配的先后顺序描述 URL 映射规则的配置信息。第 i+1 行包含两个字符串 pi 和 ri，其中 pi 表示 URL 匹配的规则，ri 表示这条 URL 匹配的名字。两个字符串都非空，且不包含空格字符，两者中间用一个空格字符分隔。 第 n+2 行至第 n+m+1 行描述待处理的 URL 地址。第 n+1+i 行包含一个字符串 qi，表示待处理的 URL 地址，字符串中不包含空格字符。 输出格式 输入共 m 行，第 i 行表示 qi 的匹配结果。如果匹配成功，设匹配了规则 pj ，则输出对应的 rj。同时，如果规则中有参数，则在同一行内依次输出匹配后的参数。注意整数参数输出时要把前导零去掉。相邻两项之间用一个空格字符分隔。如果匹配失败，则输出 404。 样例输入 5 4/articles/2003/ special_case_2003/articles/&lt;int&gt;/ year_archive/articles/&lt;int&gt;/&lt;int&gt;/ month_archive/articles/&lt;int&gt;/&lt;int&gt;/&lt;str&gt;/ article_detail/static/&lt;path&gt; static_serve/articles/2004//articles/1985/09/aloha//articles/hello//static/js/jquery.js样例输出year_archive 2004article_detail 1985 9 aloha404static_serve js/jquery.js 样例说明 对于第 1 个地址 /articles/2004/，无法匹配第 1 条规则，可以匹配第 2 条规则，参数为 2004。对于第 2 个地址 /articles/1985/09/aloha/，只能匹配第 4 条规则，参数依次为 1985、9（已经去掉前导零）和 aloha。对于第 3 个地址 /articles/hello/，无法匹配任何一条规则。对于第 4 个地址 /static/js/jquery.js，可以匹配最后一条规则，参数为 js/jquery.js。数据规模和约定 1 ≤ n ≤ 100，1 ≤ m ≤ 100。 所有输入行的长度不超过 100 个字符（不包含换行符）。 保证输入的规则都是合法的。 解题思路 本题参考了CSDN上的博文，如有侵权，随机删除 该题比较麻烦，（对本人而言）主要针对字符串的处理（不擅长）。由题目可知可分三种匹配规则：&lt;int&gt;、&lt;str&gt;、&lt;path&gt;。设置两个二维数组sn，name；分别表示匹配规则和名字后缀；然后将每条待处理的URL与sn中的每一项逐个字符串进行对比，输出结果。具体的对于&lt;int&gt;，当匹配函数中的s1匹配到’i’时，表明匹配到&lt;int&gt;,然后判断s2中的相应字符是否为数字，是则继续匹配，否则flag2 = 1；相应的&lt;str&gt;也如此；对于&lt;path&gt;则只需匹配然后输出。 代码示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;stdio.h&gt;#include&lt;string.h&gt;int match(char *s1,char *s2,int flag)&#123; int k1 = 0,k2 = 0,len1 = strlen(s1),len2 = strlen(s2);//k1代表s1的索引，k2代表s2的索引 while(k1 &lt; len1 &amp;&amp; k2 &lt;len2) &#123; if(s1[k1] == s2[k2])&#123; k1++,k2++; continue; &#125; if(s1[k1++] != '&lt;')return 0;//即为特殊匹配规则 if(flag)printf(" "); //匹配&lt;int&gt; if(s1[k1] == 'i')&#123; int flag2 = 0; while(s2[k2] &amp;&amp; s2[k2] &gt;= '0' &amp;&amp; s2[k2] &lt;= '9')&#123; if(s2[k2] &gt; '0')flag2 = 1; if(flag2 &amp;&amp; flag) printf("%c",s2[k2]); k2++; &#125; if(!flag2)return 0; k1 += 4; continue; &#125; //匹配&lt;string&gt; if (s1[k1] == 's')&#123; int flag2 = 0; while(s2[k2] &amp;&amp; s2[k2] != '/')&#123; flag2 = 1; if(flag)printf("%c",s2[k2]); k2++; &#125; if(!flag2)return 0; k1 += 4; continue; &#125; //匹配&lt;path&gt; if(s1[k1] == 'p')&#123; if(flag)&#123; while(s2[k2])&#123; printf("%c",s2[k2++]); &#125; &#125; return 1; &#125; &#125; return (k1 == len1 &amp;&amp; k2 == len2);&#125;int main()&#123; int n,m,i; scanf("%d %d",&amp;n,&amp;m); //输入规则条数和待处理URL字符串条数 char sn[100][100],name[100][100],s[100]; //sn为匹配规则，name为后缀名称 for(i=0;i&lt;n;i++)&#123; scanf("%s %s",&amp;sn[i],&amp;name[i]); &#125; for(i=0;i&lt;m;i++)&#123; scanf("%s",&amp;s); int flag = 1; int j; for(j=0;j&lt;n &amp;&amp; flag;j++)&#123; if(match(sn[j],s,0))&#123; flag = 0; printf("%s",name[j]); match(sn[j],s,1); &#125; &#125; if(flag)printf("404"); printf("\n"); &#125; return 0;&#125; (声明：菜鸟拙见，大神勿喷)本文作者：Gong Jintao本文地址： https://gongjintao.com/post/1a472c8a.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>CCF试题库</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF认证题库201803-2————碰撞的小球]]></title>
    <url>%2Fpost%2F477db5e9.html</url>
    <content type="text"><![CDATA[问题描述 数轴上有一条长度为L（L为偶数)的线段，左端点在原点，右端点在坐标L处。有n个不计体积的小球在线段上，开始时所有的小球都处在偶数坐标上，速度方向向右，速度大小为1单位长度每秒。 当小球到达线段的端点（左端点或右端点）的时候，会立即向相反的方向移动，速度大小仍然为原来大小。 当两个小球撞到一起的时候，两个小球会分别向与自己原来移动的方向相反的方向，以原来的速度大小继续移动。 现在，告诉你线段的长度L，小球数量n，以及n个小球的初始位置，请你计算t秒之后，各个小球的位置。提示 因为所有小球的初始位置都为偶数，而且线段的长度为偶数，可以证明，不会有三个小球同时相撞，小球到达线段端点以及小球之间的碰撞时刻均为整数。 同时也可以证明两个小球发生碰撞的位置一定是整数（但不一定是偶数）。。 输入格式 输入的第一行包含三个整数n, L, t，用空格分隔，分别表示小球的个数、线段长度和你需要计算t秒之后小球的位置。第二行包含n个整数a1, a2, …, an，用空格分隔，表示初始时刻n个小球的位置。 输出格式 输出一行包含n个整数，用空格分隔，第i个整数代表初始时刻位于ai的小球，在t秒之后的位置。。 样例输入 3 10 54 6 8 样例输出 7 9 9 解题思路 本题难度适当。主要是判断小球的位置和方向的改变。首先明确小球有两个属性：位置、方向；所以可以用结构体来定义小球。其次要判断所有小球中，位置相同的时候，方向的改变。此处可用冒泡排序的思想，逐一对比，然后让方向改变即可。 代码示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;stdio.h&gt;//定义小球属性 typedef struct &#123; int position; //小球位置 int direction; //小球运速度方向，1为右，-1为左 &#125;Ball;//判断小球位置 Ball judgePosition(Ball *balls,int num,int length)&#123; int i,j; for(i=0;i&lt;num-1;i++)&#123; if(balls[i].position == 0)balls[i].direction = 1; //左端点 if(balls[i].position == length)balls[i].direction = -1; //右端点 //判断是否位置是否相同，相同则方向取反 for(j=i+1;j&lt;num;j++)&#123; if(balls[i].position == balls[j].position)&#123; balls[i].direction = -balls[i].direction; balls[j].direction = -balls[j].direction; &#125; &#125; &#125; return *balls;&#125;int main()&#123; int n,L,t; //n为小球数量，L为线段长度，t为时间 int i; scanf("%d %d %d\n",&amp;n,&amp;L,&amp;t); Ball balls[n]; for(i=0;i&lt;n;i++)&#123; scanf("%d",&amp;balls[i].position); balls[i].direction = 1; &#125; while(t--)&#123; *balls = judgePosition(balls,n,L); for(i=0;i&lt;n;i++)&#123; if(balls[i].direction == 1)&#123; balls[i].position++; &#125;else&#123; balls[i].position--; &#125; &#125; &#125; for(i=0;i&lt;n;i++)&#123; printf("%d ",balls[i].position); &#125; return 0; &#125; (声明：菜鸟拙见，大神勿喷)本文作者：Gong Jintao本文地址： https://gongjintao.com/post/477db5e9.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>CCF试题库</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的apply()和call()--下]]></title>
    <url>%2Fpost%2Fb0d51126.html</url>
    <content type="text"><![CDATA[上篇中介绍到 call() 和 apply() 的基本使用方法，可以用来传递参数；但它们更重要的作用是在于能够扩充函数赖以运行的作用域，使得函数在不同作用域下拥有不同的功能。 示例123456789101112131415161718window.color = 'red';var o = new Object();o.color = 'blue';function sayColor()&#123; alert(this.color);&#125;sayColor(); //redsayColor.apply(this); //redsayColor.apply(window); //redsayColor.apply(o); //bluesayColor.call(this); //redsayColor.call(window); //redsayColor.call(o); //blue 解读 上例中 sayColor() 作为全局函数定义的，所以当在全局作用域中调用它时，会显示 “red”。而 sayColor.apply(this) 和 sayColor.apply(window) ，则是两种显示地在全局作用域中调用函数的方式，因此结果显示 “red”。当运行sayColor.apply(o)时，函数的执行环境发生改变，此时函数体内的 this 对象指向了 o ，于是结果显示地是 “blue”。 使用 call() 和 apply() 来扩充作用域的最大好处就是对象不需要与方法有任何耦合关系，即不需要将方法定义在对象中 补充 ECAMScript 5 中定义一个新的方法：bind() 。这个方法会创建一个函数的实例，其 this 值会被绑定到传给 bind() 函数的值。示例如下： 123456789window.color = "red";var o = &#123;color:'blue'&#125;;function sayColor()&#123; alert(this.color);&#125;var newSayColor = sayColor.bind(o);newSayColor(); //blue 需要注意的是: bind() 的使用会返回一个新的函数，而 newSayColor() 函数中的 this 值等于 o ，因此即使是在全局作用域中调用了这个函数，也会显示的是 “blue”。 本文作者：Gong Jintao本文地址： https://gongjintao.com/post/b0d51126.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的apply()和call()--上]]></title>
    <url>%2Fpost%2Fc7d221b0.html</url>
    <content type="text"><![CDATA[简明阐述 首要需要明确的是，在 ECMAScript 中，函数实际上是对象。因此每个函数都有其属性和方法，而每个函数都包含两个非继承而来的方法：apply() 和 call()。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内 this 对象的值。 具体介绍apply() 接收的参数： 在其中运行函数的作用域； 参数数组；可以是Array的实例，也可以是arguments对象。 示例：1234567891011121314function sum(num1,num2)&#123; return num1 + num2;&#125;function callSum1(num1,num2)&#123; return sum.apply(this,arguments); //传入的是arguments对象&#125;function callSum2(num1,num2)&#123; return sum.apply(this,[num1,num2]); //传入的是变量组成的数组&#125;alert(callSum1(10,10)); //20alert(callSum2(10,10)); //20 理解： 此处首先定义了函数 sum, 然后调用了 sum 的方法 apply()。着重理解传入的第一个参数 this。由上面解释可知 this 为 sum 函数的作用域。因为函数是在全局作用域中调用的，所以传入的 this 其实为 window 对象。传入的第二个参数有两种形式，在 callSum1 中为 arguments 对象，代表变量组成的对象；在 callSum2 中为变量实例化的数组 [num1,num2]。二者并无区别。 call() 其作用与 apply() 相同，区别仅在于接受参数的形式不同。第一个参数是函数作用域；其余则是传入参数的逐一列举。 示例：123456789function sum(num1,num2)&#123; return num1 + num2;&#125;function callSum(num1,num2)&#123; return sum.call(this,num1,num2);&#125;alert(callSum(10,10)); //20 总结： apply() 和 call() 具体作用是相同的，区别仅在于传入参数的方式不同。 注意：在严格模式下，未指定环境对象而调用函数。则 this 值不会转型为 window ,除非明确将函数添加到某个对象或者调用 apply() 和 call() ，否则其值为 undefined。 本文作者：Gong Jintao本文地址： https://gongjintao.com/post/c7d221b0.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF认证题库201803-1——跳一跳]]></title>
    <url>%2Fpost%2Fd58f9494.html</url>
    <content type="text"><![CDATA[问题描述 近来，跳一跳这款小游戏风靡全国，受到不少玩家的喜爱。简化后的跳一跳规则如下：玩家每次从当前方块跳到下一个方块，如果没有跳到下一个方块上则游戏结束。如果跳到了方块上，但没有跳到方块的中心则获得1分；跳到方块中心时，若上一次的得分为1分或这是本局游戏的第一次跳跃则此次得分为2分，否则此次得分比上一次得分多两分（即连续跳到方块中心时，总得分将+2，+4，+6，+8…）。现在给出一个人跳一跳的全过程，请你求出他本局游戏的得分（按照题目描述的规则）。 输入格式 输入包含多个数字，用空格分隔，每个数字都是1，2，0之一，1表示此次跳跃跳到了方块上但是没有跳到中心，2表示此次跳跃跳到了方块上并且跳到了方块中心，0表示此次跳跃没有跳到方块上（此时游戏结束）。 输出格式 输出一个整数，为本局游戏的得分（在本题的规则下）。 样例输入 1 1 2 2 2 1 1 2 2 0 样例输出 22 解题思路 本题较为简单，可直接进行条件判断求解。可知有以下几种情况： 输入为1，则得分grade=1； 输入为2，且为第一个输入或者前一个输入为1，则得分grade=2； 输入为2，且前一个输入为2，则得分grade=grade+2； 输入为0，结束游戏 本题难点在于不定长数组的录入问题 动态分配数组问题可用 realloc 函数解决：arr=realloc(arr,++n*sizeof(int)) 判断输入结束，即判断最后输入为换行符’\n’则结束输入：getchar()!=&#39;\n&#39; 代码示例1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123;int i=0,n=1,sum=0,j,grade; //n表示数组长度,sum表示总分,grade表示每次得分int *arr;char ch;arr=(int*)malloc(n*sizeof(int));do&#123; scanf("%d",&amp;arr[i++]); //录入数组数据 realloc(arr,++n*sizeof(int));&#125;while((ch=getchar())!='\n');for(j=0;j&lt;i;j++)&#123; if(arr[j]==1)&#123; grade=1; &#125;else if(arr[j]==2 &amp;&amp; (arr[j-1]==1 || j==0))&#123; grade=2; &#125;else if(arr[j]==2)&#123; grade+=2; &#125;else if(arr[j]==0)&#123; break; &#125; sum+=grade;&#125;printf("%d",sum);return 0;&#125; (声明：菜鸟拙见，大神勿喷)本文作者：Gong Jintao本文地址： https://gongjintao.com/post/d58f9494.html 版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>CCF试题库</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
</search>
